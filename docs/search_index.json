[["rendering-3d-rayshader-stage-route-maps.html", "13 Rendering 3D rayshader Stage Route Maps 13.1 Load in Base Data 13.2 Setting Up 3D Embedded Plots 13.3 Rendering a Simple Stage Route Model", " 13 Rendering 3D rayshader Stage Route Maps Having introduced interactive 3d rayshader models in the previous chapter, let’s now explore how we can generate interactive three dimensional models of our stage maps. 13.1 Load in Base Data As ever, let’s load in our stage data: library(tidyr) geojson_filename = &#39;montecarlo_2021.geojson&#39; geojson_sf = sf::st_read(geojson_filename) ## Reading layer `montecarlo_2021&#39; from data source `/Users/tonyhirst/Documents/GitHub/visualising-rally-stages/montecarlo_2021.geojson&#39; using driver `GeoJSON&#39; ## Simple feature collection with 9 features and 2 fields ## geometry type: LINESTRING ## dimension: XY ## bbox: xmin: 5.243488 ymin: 43.87633 xmax: 6.951953 ymax: 44.81973 ## geographic CRS: WGS 84 stage_bbox = sf::st_bbox(geojson_sf) We have already seen how we can overlay an elevation model raster on a leaflet map, as well as rendering two dimensional topographic models using the raytracer package. Generating 3D, rather than 2D, maps follows exactly the same steps as the 2D view apart from the final rendering step. Recall that the raytracer package itself works with a matrix of raster values. Having saved the download raster to a tif file, we can load the data back in from and convert it to a matrix using the rayshader::raster_to_matrix() function: library(rayshader) library(raster) # Previously downloaded buffered TIF digital elevation model (DEM) file stage_tif = &quot;buffered_stage_elevation.tif&quot; # Load in the previously saved image raster elev_img = raster(stage_tif) # Get the natural zscale auto_zscale = geoviz::raster_zscale(elev_img) # Note we can pass in a file name or a raster object elmat = raster_to_matrix(stage_tif) ## [1] &quot;Dimensions of matrix are: 468x626.&quot; Just as a reminder, here’s a quick review of what the 2D maps look like: # Use the raster extent for the plots stage_extent = extent(elev_img) yellow_route = generate_line_overlay(geojson_sf[1,], extent = stage_extent, heightmap = elmat, linewidth = 5, color=&quot;yellow&quot;) mapped_route_yellow = elmat %&gt;% sphere_shade(sunangle = -45, texture = &quot;bw&quot;) %&gt;% #add_water(watermap, color = &quot;bw&quot;) %&gt;% add_overlay(yellow_route) mapped_route_yellow %&gt;% plot_map() The 2D plots can be quite pretty, but we can also bring them even more alive as 3D rendered plots. 13.2 Setting Up 3D Embedded Plots Recall that to embed WebGL interactive models using rgl::rglwidget(), we need to fettle some settings first: options(rgl.useNULL = TRUE, rgl.printRglwidget = TRUE) 13.3 Rendering a Simple Stage Route Model We can render our 2D route model simply by passing it to the rayshader::plot_3d() function, along with the elevation model. If we set the zscale parameter to the auto_zscale determined previously as auto_zscale = geoviz::raster_zscale(elev_img), the relief is rendered using the “real” scaling that keeps the height of elevated areas in equal proportion to the scale used by the x and y scale values: rgl::clear3d() mapped_route_yellow %&gt;% plot_3d(elmat, zscale=auto_zscale) rgl::rglwidget() We can also disable the display of the base to give a view similar to the sort of view we might render using plot3d(). There are several approaches we can use to grabbing a flat image capture of a model. One is to the use an rgl::rglwidget(snapshot=TRUE) call which in headless mode uses webshot2 to launch a browser in the background, render the model inside a widget in that browser, and then grab a screenshot… rgl::rgl.open() rgl::clear3d() mapped_route_yellow %&gt;% plot_3d(elmat, zscale = auto_zscale, # Disable the solidbase display solid = FALSE, # But reserve the shadow shadow = TRUE, shadowcolor = &#39;lightblue&#39; ) r = rgl::rglwidget(webgl=FALSE, snapshot=TRUE) ## Error in s$close(): attempt to apply non-function render_fn = &#39;example_render.png&#39; file.rename(r[1], render_fn) ## Error in file.rename(r[1], render_fn): invalid &#39;from&#39; argument rgl::rgl.close() knitr::include_graphics(render_fn) The rayshader::render_snapshot() and `rayshader::render_highquality()`` functions provide alternative ways of rendering the current scene: rgl::rgl.open() rgl::clear3d() mapped_route_yellow %&gt;% plot_3d(elmat, zscale = auto_zscale) render_fn2 = &quot;demo_stage_3D_map_overlay.png&quot; render_snapshot(render_fn2) ## Error in s$close(): attempt to apply non-function rgl::rgl.close() knitr::include_graphics(render_fn2) 13.3.1 Decorating 3D Views With Map Tile Overlays As with the 2D views, we can drape map tile imagery over the 3D view and it will be shaped to fit the 3D elevation model. Let’s create a terrain layer using some tile imagery: library(geoviz) # For slippy_overlay overlay_image_terrain &lt;- slippy_overlay(elev_img, image_source = &quot;stamen&quot;, image_type = &quot;terrain&quot;, png_opacity = 0.9) Add the terrain to a model and render it in 2D: mapped_terrain_yellow = mapped_route_yellow %&gt;% add_overlay(overlay_image_terrain) %&gt;% add_overlay(yellow_route) mapped_terrain_yellow %&gt;% plot_map() And now, how about the 3D version? rgl::clear3d() mapped_terrain_yellow %&gt;% plot_3d(elmat, zscale=auto_zscale) rgl::rglwidget() As before, we should be able to a video from the model. However, for current package versions, trying to render the movie just leads to an error after a long time spent trying to render the movie: library(av) options(rgl.useNULL = FALSE, rgl.printRglwidget = FALSE) # Open a connection to the renderer rgl::rgl.open() rgl::clear3d() mapped_terrain_yellow %&gt;% plot_3d(elmat, zscale=auto_zscale) # Render the movie to an MP4 file video_fn = &#39;demo_3d_stage_tile_overlay.mp4&#39; render_movie(video_fn) rgl::rgl.close() # Embed the movie embedr::embed_video(video_fn, width = &quot;256&quot;, height = &quot;256&quot;) 13.3.2 Adding Labels to 3D rayshader Maps To highlight points of interest on a 3D model, we can we add a labels to the 3D view. A line can be used to connect a label to the point on the surface map that the label relates to. TO DO - this has stopped working now too…; neither OpenGL nor FreeType seem to be supported in the rgl version I’m using and if I try to roll back, the previous version doesn’t want to work at all. One to return to in the fullness of time perhaps… It’s not an efficient use of time to get stuck in finding workarounds for what may just be dev in progress. rgl::clear3d() mapped_terrain_yellow %&gt;% plot_3d(elmat, zscale=auto_zscale) render_label(elmat, lat = 44.7808, long = 5.909417, extent = stage_extent, #zscale = auto_zscale, offset=0, # Height above surface to start the line altitude=1036 + 500 , #32000, text = &quot;Split 1&quot;, textsize = 2, linewidth = 3) ## Error in rgl.texts(x = -19.0589232070939, y = 2477, z = -21.2727422878866, : FreeType not supported in this build rgl::rglwidget() "]]
