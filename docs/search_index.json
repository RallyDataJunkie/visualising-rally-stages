[["automatically-generating-stage-descriptions.html", "20 Automatically Generating Stage Descriptions 20.1 Jemba Inertia Notes System 20.2 Generating Stage Descriptions 20.3 Load in Base Data 20.4 Identifying Corners Based on trajr Step Gradients 20.5 Categorising Corners Using rLFT Convexity 20.6 Stage Segmenting 20.7 Corner Severity Numbering", " 20 Automatically Generating Stage Descriptions Having annotated each line segment that makes up a rally stage route, can we use that information to help us create visual or even written, descriptions of a stage? In terms of categorising turns in a way that’s meaningful in a rally context, let’s have a recap on what sorts of thing a rally navigator or co-driver is likely to be saying: embed_url(&quot;https://www.youtube.com/watch?v=KFjRj25uclQ&quot;) And let’s review what we actually mean by a corner… embed_url(&quot;https://www.youtube.com/watch?v=YXOYckDATWE&quot;) In terms of actual corners, the convexity interesting may be one of the more interesting properties. Finding a good way of representing variable radius turns (you did watch the “corners” video, didn’t you?!) will also be important if we want to be able to identify “tightens” or “lessens” (that is, “opens”) corner features. Any elevation changes in the vicinity of a corner are likely to be important if we are trying to characterise braking zone requirements… 20.1 Jemba Inertia Notes System In a section entitled Using data to assess the suitability of a special stage, the FIA Rally Safety Guidelines 2020 suggest that as well as using historic information, the “Jemba System” for recording terrain data, including “the inclines, the dips, the bends and crests”. By also taking the road terrain (for example, gravel or asphalt) into account, and likely car classes, average speeds over the stage as well as highest speed and heaviest braking areas can also be determined. THe system can also report the margin for critical braking dist before stop (“how far you may carry on at competitive speed until you have to start braking to be able to stop at the stop control”) and the Jemba Safety Index (J/kg), the average kinetic energy of a car going through the corners. The FIA Safety Guidelines illustrate how speeds might be visualised over a Google Earth map using a three colour scale (purple:over 150kph; red: over 90kph; yellow – 7590kph). The report also suggests that the Jemba system can predict the maximum cornering speed for any particular bend. A Wikipedia page describing the Jemba Inertia Notes System gives examples of the descriptive and numerical labels that the Jemba system can generate as it converts odometry and accelerometer data into something rather more human understandable. A visual grading shows how descriptive labels correspond to turn angle. 20.2 Generating Stage Descriptions Being able to display route profiles on a map as colour highlighted routes is very useful and could be made more so adding the data to a leaflet.js extension such as Leaflet.Heightgraph, which displays arbitrary traces (to integrate this in the current workflow properly would require the development of an extension to the R leaflet package). Another possibility would be to try to automate the creation of text based route descriptions (“robot journalism”), which I’ve crudely explored in other contexts elsewhere. The It Gets Faster Now blog publishes stage descriptions for WRC stage routes, so this could be a good place to learn tropes from. 20.3 Load in Base Data As ever, let’s load in our stage data and the elevation raster and create a demo map: library(sf) library(raster) library(rayshader) geojson_filename = &#39;montecarlo_2021.geojson&#39; geojson_sf = sf::st_read(geojson_filename) ## Reading layer `montecarlo_2021&#39; from data source `/Users/tonyhirst/Documents/GitHub/visualising-rally-stages/montecarlo_2021.geojson&#39; using driver `GeoJSON&#39; ## Simple feature collection with 9 features and 2 fields ## geometry type: LINESTRING ## dimension: XY ## bbox: xmin: 5.243488 ymin: 43.87633 xmax: 6.951953 ymax: 44.81973 ## geographic CRS: WGS 84 stage_route_gj = geojsonio::geojson_json(geojson_sf[1,]$geometry) # Previously downloaded TIF digital elevation model (DEM) file stage_tif = &quot;stage_elevation.tif&quot; # Load in the previously saved image raster elev_img = raster(stage_tif) # Note we can pass in a file name or a raster object elmat = raster_to_matrix(stage_tif) ## [1] &quot;Dimensions of matrix are: 382x565.&quot; demo_map = elmat %&gt;% sphere_shade(texture = &quot;desert&quot;, progbar = FALSE) Let’s also get a UTM projection of the stage routes: # Detect the UTM zone as an EPSG code lonlat2UTMzone = function(lonlat) { utm = (floor((lonlat[1] + 180) / 6) %% 60) + 1 if(lonlat[2] &gt; 0) { utm + 32600 } else{ utm + 32700 } } get_utm_projection = function(routes){ # Keep track of the original proj4 string old_crs = st_crs(geojson_sf[1,])$proj4string sample_location_x = st_coordinates(st_centroid(routes[1,]))[1] sample_location_y = st_coordinates(st_centroid(routes[1,]))[2] # Generate a new projection in the appropriate UTM zone crs_zone = lonlat2UTMzone(c(sample_location_x, sample_location_y)) new_proj4_string = st_crs(crs_zone)$proj4string # Transform the route to the UTM projection utm_routes = st_transform(geojson_sf, crs=new_proj4_string) utm_routes # Or should we returned a named list # e.g. including the original projection? #list(utm_routes = utm_routes, orig_crs=old_crs) } utm_routes = get_utm_projection(geojson_sf) 20.4 Identifying Corners Based on trajr Step Gradients Let’s start by trying to identify straight sections. Trivially, given that the stage route is given by a linestring made of straight line segments arranged at different angles relative to each other, every line segment is a straight. So what we really mean by a straight is a sequence of connected lines segments where each line segment is at an angle less than +/- 5 degrees to the to segment before it, for example, where the start of the straight has a preceding segment more than +/- 5 degrees to it (for example) and the end of the straight has a following line segment at more than +/- five degrees to it. Let’s use the trajr stepangle to try to categorise straights: library(trajr) trj &lt;- TrajFromCoords(as.data.frame(st_coordinates(utm_routes[1,]))) # Remove duplicate x,y rows - assume non-crossing route] # Should probably flag this removal via a warning trj = trj[!duplicated(trj[,c(&#39;x&#39;,&#39;y&#39;)]),] # displacement is a complex number, so we can get the actual distance: trj$distance = Mod(trj$displacement) # Find the accumulated distance at each step trj$cum_dist = cumsum(trj$distance) # Step angle in radians relative to previous trj$stepangle = c(NA, TrajAngles(trj, compass.direction = NULL) * 180 / pi, NA) trj$cumstepangle = cumsum(c(0, TrajAngles(trj, compass.direction = NULL) * 180 / pi, NA)) trj$stepheading = c(TrajAngles(trj, compass.direction = 0)* 180 / pi, NA) # Find the gradient of the accumulated angle trj$step_gradient = pracma::gradient(trj$cumstepangle, trj$cum_dist) We can view the gradients: g = ggplot(data=trj, aes(x=x, y=y)) + geom_path(color=&#39;grey&#39;) + coord_sf() g + geom_point( size=0.2, color=&#39;blue&#39;, data=trj[trj$step_gradient&gt;0.2,]) + geom_point(size=0.2, data=trj[trj$step_gradient&lt;=-0.2,], color=&#39;red&#39;) If we have several consecutive points with a gradient of the same sign, then we might consider them to be part of the same corner, albeit one that maybe tightens or opens. If the gradients of consecutive segments have a different sign, then we have a change of direction from e.g. left to right or right to left. We can create a flag that identifies when the sign changes across consecutive rows of the step_gradient column. We can check this by lagging the contents of the step_gradient column by one step using the dplyr::lag() function and comparing its sign to the sign of the unlagged value. If we then dplyr::lead() the result, we can see if a change in direction happens at the end of a step: trj = trj %&gt;% mutate(dirChange = lead(sign(step_gradient) != sign(lag(step_gradient)))) head(trj[,c(&#39;step_gradient&#39;, &#39;dirChange&#39;)]) ## step_gradient dirChange ## 1 0.02722146 FALSE ## 2 0.43059007 FALSE ## 3 1.18714584 FALSE ## 4 1.94367547 FALSE ## 5 1.42337267 TRUE ## 6 -0.07676768 FALSE Let’s plot points on the route where we seem to have a direction change: g + geom_point( size=0.2, color=&#39;blue&#39;, data=trj[trj$dirChange,]) + theme(axis.text.x = element_text(angle = 45)) Let’s zoom in a bit: # Zoom in on part of the route zoom1 = trj$y&gt;4964000 &amp; trj$y&lt;4965000 g1 = ggplot(data=trj[zoom1, ], aes(x=x, y=y)) + geom_path(color=&#39;grey&#39;) + coord_sf() g1 + geom_point( size=0.2, color=&#39;blue&#39;, data=trj[zoom1 &amp; trj$dirChange,]) + theme(axis.text.x = element_text(angle = 45)) We notice that we seem to be missing some corners that are perhaps not direction changes, but significant angle changes in the same direction. And we also notice a direction change flagged in what appears to be the middle of a straight. Let’s look at the apparent turn in the middle of the straight first. If we have opposing angles from one segment to the next, then we currently class the first point as a corner because the direction has changed. But we aren’t really interested in slight direction changes or even slight direction changes in the same direction. slight_gradient = 0.35 trj = trj %&gt;% mutate(straightish = (abs(step_gradient) &lt; slight_gradient)) ggplot(data=trj[zoom1, ], aes(x=x, y=y)) + geom_path(color=&#39;grey&#39;) + coord_sf() + geom_point( size=1, aes(color = straightish)) + theme(axis.text.x = element_text(angle = 45)) We now want to identify the first node in a close sequence of nodes that identify a turn that doesn’t change direction. Which is to say we want a not straightish node whose next node is nearby and not straightish and in the same direction, or not nearby: # Close distance threshold closeby = 25 trj = trj %&gt;% mutate(nearby = (distance &lt; closeby) ) %&gt;% mutate(firstish = !straightish &amp; ((nearby &amp; !lag(straightish) &amp; lag(dirChange)) | (!nearby) ) ) ggplot(data=trj[zoom1, ], aes(x=x, y=y)) + geom_path(color=&#39;grey&#39;) + coord_sf() + geom_point( size=1, aes(color = firstish)) + theme(axis.text.x = element_text(angle = 45)) That’s identifying some of the corners, but what’s going on top left? zoom2 = zoom1 &amp; trj$x&lt;730100 ggplot(data=trj[zoom2,], aes(x=x, y=y)) + geom_path(color=&#39;grey&#39;) + coord_sf() + geom_point( size=1, aes(color = firstish)) + theme(axis.text.x = element_text(angle = 45)) Ah, ok, maybe we could categorise those as turns, but perhaps gentle ones. We maybe need to flag these as “flowing” if they aren’t too tight and have a long run in and out: tight_gradient = 0.5 trj = trj %&gt;% mutate(significant = abs(step_gradient) &gt; tight_gradient ) %&gt;% mutate(flowing = !nearby &amp; !lead(nearby) &amp; !straightish &amp; !significant ) ggplot(data=trj[zoom2,], aes(x=x, y=y)) + geom_path(color=&#39;grey&#39;) + coord_sf() + geom_point( size=3, aes(color = flowing, shape = dirChange)) + theme(axis.text.x = element_text(angle = 45)) We can also tweak firstish to recognise significance: trj = trj %&gt;% mutate(firstish = (significant &amp; !lag(significant)) | (!straightish &amp; ((nearby &amp; !lag(straightish) &amp; lag(dirChange)) | (!nearby) ) )) %&gt;% # Desensitise firstish mutate(firstish = firstish &amp; !(lag(firstish))) And how about over a wider part of the stage? ggplot(data=trj[zoom1, ], aes(x=x, y=y)) + geom_path(color=&#39;grey&#39;) + coord_sf() + geom_point( size=2, aes(color = firstish, shape = flowing)) + theme(axis.text.x = element_text(angle = 45)) We could also then create a !flowing &amp; firstish flag to provide better indexing of the starts of corners. We’d need to test the approach on further stages to see whether it gives false positives or false negatives on identifying various corners, and we’d maybe also want to try to identify tightens and opens. Let’s have a go at tightens. At a first approximation, a corner tightens if a node isn’t firstish, is above a certain gradient, is close to the previous step and the magnitude of the gradient has increased and is the same sign as the previous step: trj = trj %&gt;% mutate(tightens = !firstish &amp; significant &amp; lead(nearby) &amp; ((sign(lead(step_gradient))==sign(step_gradient)) &amp; (abs(lead(stepangle)) &gt; abs(step_gradient)))) ggplot(data=trj[zoom1, ], aes(x=x, y=y)) + geom_path(color=&#39;grey&#39;) + coord_sf() + geom_point( size=2, aes(color = tightens, shape = firstish)) + theme(axis.text.x = element_text(angle = 45)) The corner opens (“lessens”) if a node isn’t firstish, is above a certain gradient, is close to the previous step and the gradient is in the same direction and has decreased: trj = trj %&gt;% mutate(opens = !firstish &amp; significant &amp; lead(nearby) &amp; ((sign(lead(step_gradient))==sign(step_gradient)) &amp; (abs(lead(stepangle)) &lt; abs(step_gradient)))) ggplot(data=trj[zoom1, ], aes(x=x, y=y)) + geom_path(color=&#39;grey&#39;) + coord_sf() + geom_point( size=2, aes(color = opens, shape = firstish)) + theme(axis.text.x = element_text(angle = 45)) We might also try for “continues” if the angle is about the same gradient but not tightening. 20.4.1 Plotting Trajectory Segments It will be convenient to be able ot plot segments of a trajectory for particular stretches of a route, so let’s create a function that helps us do that: trj_segment_plot = function(trj, start, end, x=&#39;x&#39;, y=&#39;y&#39;, title=&#39;&#39;, fix_coords=TRUE, rotate=NULL, gradients=0, gradient_size=2) { # Create the route distance filter limits segment_filter = trj$cum_dist &gt;= start &amp; trj$cum_dist &lt;= end # Filter the route route_segment = trj[segment_filter,] if (!is.null(rotate)) route_segment = TrajRotate(route_segment, angle = rotate, relative = TRUE) # Generate the stylised route plot g = ggplot(route_segment) + geom_path(aes_string(x=x, y=y)) + # Add a marker to show the start of the segment geom_point(data=head(route_segment,n=1), aes_string(x=x, y=y)) + theme_void() # Add a title title=as.character(title) if (startsWith(title,&#39;auto::&#39;)) { title = stringr::str_split(title,&#39;::&#39;)[[1]][2] title_ = paste0(start/1000, &#39;-&#39;, end/1000, &#39;km&#39;) if (title!=&#39;&#39;) title = paste(title, title_) else title = title_ } if (title!=&#39;&#39;) g = g + ggtitle(title) if (fix_coords) g = g + coord_fixed() if (gradients) g = g+ geom_point(aes_string(x=x, y=y), size=gradient_size, color=&#39;blue&#39;, data=route_segment[route_segment$step_gradient&gt;gradients,]) + geom_point(aes_string(x=x, y=y), size=gradient_size, data=route_segment[route_segment$step_gradient&lt;=-gradients,], color=&#39;red&#39;) g } We can then plot a trajectory as follows, optionally rotatint the segment to a horizontal left-right orientation: # Show a specified segment trj_segment_plot(trj, 9000, 12500, title=&#39;auto::SS1&#39;, rotate=TRUE) 20.4.2 Segmenting the Route We can automate the production of a single chart that will display the route a section at a time. This requires segmenting the route, then for each segment, generating the plot, which we add to a list of plots. # The final section goes to the end of the route trj_segment_multiplot = function(trj, i, title=&#39;&#39;, x=&#39;x&#39;, y=&#39;y&#39;, final=FALSE, segment_length = 1000, prefix_dist = 20, gradients=0, gradient_size=1, fix_coords=FALSE, rotate=NULL){ # Preface the start of the stage with a 20m lead start_prefix = prefix_dist start = segment_length*(i-1)-start_prefix if (final) end = Inf else end = (segment_length*i) trj_segment_plot(trj, start, end, x=x, y=y, title=title, fix_coords=fix_coords, rotate=rotate, gradients=gradients, gradient_size=gradient_size) } # Create a list to hold each plot as a separate item trj_segment_plots = list() # How many kilometers does the route extend over? length_1km = 1000 kms = floor(max(trj$cum_dist)/length_1km) # Iterate through each kilometer for (i in 1:kms){ # Add each plot to the plot list trj_segment_plots[[length(trj_segment_plots) + 1]] &lt;- trj_segment_multiplot(trj, i, title=i, final=(i==kms), fix_coords=TRUE, rotate=0, gradients=0.2, gradient_size=1) } We can use the ggpubr::ggarrange() function to plot the list of individual plots as a single image: library(ggpubr) gg = ggarrange(plotlist=trj_segment_plots, ncol=5, nrow=ceiling(kms/4)) annotate_figure(gg, top = text_grob(utm_routes[1,]$Name, color = &quot;black&quot;, face = &quot;bold&quot;, size = 14)) 20.4.3 Numbering Corners To make it easier to refer to corners, can we use the firstish flag as a way of counting corners? trj_corners = trj[trj$firstish,] trj_corners$corner_num = cumsum(trj_corners$firstish) zoom1_corners = trj_corners[trj_corners$y&gt;4964000 &amp; trj_corners$y&lt;4965000,] ggplot(data=trj[zoom1, ], aes(x=x, y=y)) + geom_path(color=&#39;grey&#39;) + coord_sf() + geom_text(data= zoom1_corners, aes(x=x, y=y, label=corner_num), size=3) + theme(axis.text.x = element_text(angle = 45)) 20.5 Categorising Corners Using rLFT Convexity The previous approach works to a certain extent with the limited dataset we tested it against but it feels rather contrived. Generally, just by looking at a curve we get a feel for how tight it is, rather than having to apply all sorts of decision-making rules and logical reasoning. Is there a simple metric we can use? One approach might be to consider using convexity measure, such as the one provided by the rLFT package. Let’s see how that might work using the rLFT::bct() (bounded convexity tool) function. This function finds the curvature at regular points along a track, in the following example, every 10 meters: library(rLFT) stepdist = 10 window = 20 route_convexity &lt;- bct(utm_routes[1,], # distance between measurements step = stepdist, window = window, ridName = &quot;Name&quot;) ## user system elapsed ## 0.201 0.063 0.266 ## [1] &quot;Features skipped due to size: &quot; ## logical(0) head(route_convexity) ## FID RID MidMeas WindowSize RawConvexity ConvexityIndex Sinuosity Midpoint_X ## 1 1 SS 1 10 20 0.000 0.000 0.500 729181.8 ## 2 1 SS 1 20 20 -0.040 -0.004 0.500 729186.1 ## 3 1 SS 1 30 20 -0.014 -0.001 0.500 729190.4 ## 4 1 SS 1 40 20 0.000 0.000 0.500 729194.6 ## 5 1 SS 1 50 20 -1.739 -0.174 0.509 729198.8 ## 6 1 SS 1 60 20 -0.093 -0.009 0.501 729199.6 ## Midpoint_Y ## 1 4957667 ## 2 4957676 ## 3 4957685 ## 4 4957694 ## 5 4957703 ## 6 4957713 Recalling the previous chapter: corner_conv = 0.1 tight_corners = route_convexity[abs(route_convexity$ConvexityIndex)&gt;corner_conv,] tight_corners_zoom1 = tight_corners$Midpoint_Y&gt;4964000 &amp; tight_corners$Midpoint_Y&lt;4965000 ggplot(data=trj[zoom1, ], aes(x=x, y=y)) + geom_path(color=&#39;grey&#39;) + coord_sf() + geom_text(data=tight_corners[tight_corners_zoom1,], aes(label = ConvexityIndex, x=Midpoint_X, y=Midpoint_Y), size=2) + geom_point(data=tight_corners[tight_corners_zoom1,], aes(x=Midpoint_X, y=Midpoint_Y, color= (ConvexityIndex&gt;0) ), size=1) + theme_classic()+ theme(axis.text.x = element_text(angle = 45)) So the absolute convexity index can help us find corners but we still need to do some work to find find the start of a corner. How does that top right area look? tight_corners_zoom2 = tight_corners_zoom1 &amp; tight_corners$Midpoint_X&lt;730100 ggplot(data=trj[zoom2,], aes(x=x, y=y)) + geom_path(color=&#39;grey&#39;) + coord_sf() + ggrepel::geom_text_repel(data=tight_corners[tight_corners_zoom2,], aes(label = ConvexityIndex, x=Midpoint_X, y=Midpoint_Y), size=3) + geom_point(data=tight_corners[tight_corners_zoom2,], aes(x=Midpoint_X, y=Midpoint_Y, color= (ConvexityIndex&gt;0) ), size=1) + theme_classic()+ theme(axis.text.x = element_text(angle = 45)) So we can probably apply a similar logic to previously to group these and identify the corner entry node, although we need to tweak the rules slightly so that we are identifying a corner entry node that is far from a previous tight corner node: cornerer = function (df, slight_conv=0.01, closeby=25){ df %&gt;% mutate(dirChange = sign(ConvexityIndex) != sign(lag(ConvexityIndex))) %&gt;% mutate(straightish = (abs(ConvexityIndex) &lt; slight_conv)) %&gt;% mutate(dist = (lead(MidMeas)-MidMeas)) %&gt;% mutate(nearby = dist &lt; closeby) %&gt;% mutate(firstish = !straightish &amp; ((nearby &amp; !lag(straightish) &amp; lag(dirChange)) | # We don&#39;t want the previous node nearby (!lag(nearby)) ) &amp; !lag(nearby) ) } tight_corners = cornerer(tight_corners) Let’s see how it looks. We can also label nodes showing how far away the next node is: ggplot(data=trj[zoom1,], aes(x=x, y=y)) + geom_path(color=&#39;grey&#39;) + coord_sf() + ggrepel::geom_text_repel(data=tight_corners[tight_corners_zoom1,], aes(label = dist, x=Midpoint_X, y=Midpoint_Y), size=3) + geom_point(data=tight_corners[tight_corners_zoom1,], aes(x=Midpoint_X, y=Midpoint_Y, color= (firstish) ), size=1) + theme_classic()+ theme(axis.text.x = element_text(angle = 45)) 20.6 Stage Segmenting One of the handy things about the rLFT::bct() is that it can chunk the route into very short segments. This provides us with an easy way to index into the route to generate a view over a particular section. For example, we can view the route over specific sections given a start and finish distance into the route. Note that the route will be discretised to step lengths used by the rLFT::bct() function and a stylised route will be approximated along step midmeasure points: segment_plot = function(start, end, title=&#39;&#39;, fix_coords=TRUE) { # Create the route distance filter limits segment_filter = route_convexity$MidMeas &gt;= start &amp; route_convexity$MidMeas &lt;= end # Filter the route route_segment = route_convexity[segment_filter,] # Generate the stylised route plot g= ggplot(route_segment) + geom_path(aes(x=Midpoint_X, y=Midpoint_Y)) + geom_point(data=head(route_convexity[segment_filter,],n=1), aes(x=Midpoint_X, y=Midpoint_Y)) + theme_void() if (title!=&#39;&#39;) g = g+ggtitle(title) if (fix_coords) g=g+coord_fixed() g } # Show the first 1000m segment_plot(0, 1000) We can automate the creation of route sections every kilometer and create a list of plots, one per kilometer section: segment_length = 1000 step_length=10 kms = floor(max(route_convexity$MidMeas)/segment_length) # The final section goes to the end of the route segment_multiplot = function(i, final=FALSE){ # Preface the start of the stage with a 20m lead start_prefix = 2*step_length start = segment_length*(i-1)-start_prefix if (final) end = Inf else end = (segment_length*i) segment_plot(start, end, i, fix_coords=TRUE) } # Create a list to hold each plot as a separate item segment_plots = list() # Iterate through each kilometer for (i in 1:kms){ # Add each plot to the plot list segment_plots[[length(segment_plots) + 1]] &lt;- segment_multiplot(i, final=(i==kms)) } We can now use the ggpubr::ggarrange() function to display all the stage route sections in a single plot: ggarrange(plotlist=segment_plots, ncol=5, nrow=ceiling(kms/4)) We can use a similar approach to create a more general function that will allow us to plot either the route, or generate a plot for each segment showing the convexity against distance into the segment: # Simple function to get a route segment get_route_segment = function (route, start, end){ segment_filter = route$MidMeas &gt;= start &amp; route$MidMeas &lt;= end route[segment_filter,] } segment_plot2 = function(route, start, end, title=&#39;&#39;, typ=&#39;route&#39;, themevoid=TRUE){ # Get route segment route_segment = get_route_segment(route, start, end) # Create plot base g = ggplot(route_segment) if (typ==&#39;convexity&#39;) { g = g + geom_bar(aes(x=MidMeas, y=-ConvexityIndex, col=(ConvexityIndex&gt;0)), stat=&#39;identity&#39;, show.legend = FALSE) } else { # plot route g = g + geom_path(aes(x=Midpoint_X, y=Midpoint_Y)) + geom_point(data=head(route_segment, n=1), aes(x=Midpoint_X, y=Midpoint_Y)) } if (title!=&#39;&#39;) g = g + ggtitle(title) if (themevoid) g = g + theme_void() g } Let’s see what a convexity report for the first kilometer looks like: segment_plot2(route_convexity, 0, 1000, typ=&#39;convexity&#39;) So we start off with a left (port-red-left!), a slight right, a straight, a right that tightens, a left, a straight, a nudge left and then end the kilometer with a tight right. Let’s remind ourselves to see if that looks about right: segment_plot2(route_convexity, 0, 1000, typ=&#39;route&#39;) We can use a similar approach before to automate the collection of multiple plots for each stretch of the stage: segment_multiplot2 = function(route, i, final=FALSE, typ=&#39;route&#39;){ start = segment_length*(i-1)-step_length if (final) end = Inf else end = (segment_length*i) segment_plot2(route, start, end, i, typ ) } We can now generate a plot of either the route sections, or the convexity based on distance into the route section: segment_plots2 = list() # Iterate through each kilometer for (i in 1:(kms-1)){ segment_plots2[[length(segment_plots2) + 1]] &lt;- segment_multiplot2(route_convexity, i, final= (i==kms), typ = &#39;convexity&#39;) } ggpubr::ggarrange(plotlist=segment_plots2, ncol=5, nrow=ceiling(kms/4)) At a glance, we can now start to identify segments of the route that contain particular sorts of feature. For example, we can readily see that kilometers 12, 15 and 16 include significant straight stretches. 20.7 Corner Severity Numbering Although they may differ in the specifics, all rally pace note systems find some way to categorise the corner severity (also referred to as the turn intensity). Many systems use a convention that numbers corner severity with a value from 1 to 6, where 1 is the most severe and 6 is the least severe; alternatively, therallydriver.com pacenotes system, (which has the added benefit of being well documented in the To See the Invisible tutorial series published by the system’s creator, David Nafría), uses a range from 1 to 10. Variations on the following diagram are often used to illustrate how the numbers scheme applies to different severity corners. library(ggforce) # ggforce::geom_arc rallynotes = data.frame(n=1:10, r=c(10, 15, 20, 27.5, 35, 45, 60, 77.5, 100, 175)) rallynotes_arcs &lt;- data.frame( start = -pi/2, end = mapply(min, 50/rallynotes$r, pi/2), r = rallynotes$r, n = rallynotes$n ) # Plot a representation of corner severity along the route ggplot(rallynotes_arcs) + geom_arc_bar(aes(x0 = -15+r-6*n, y0 = 0, r0 = r, r = r+2, start = start, end = end,fill = factor(n), color = factor(n)), show.legend=FALSE) + geom_text(aes(label=n, x=-15-6*n , y=-10), size=3, hjust=&#39;right&#39;) + coord_fixed()+ theme_void() Note that with increasing number, the radius of curvature (that is, the radius of the circle describing the corner) also increases. This gives us one way of mapping from a measurement we can apply to a corner (such as its radius of curvature) to the turn severity number. Two other properties of a corner that we might attempt to describe are the length of the corner either as a linear distance (20m, for example) or as an angular distance (45 degrees, for example). The “distance” might also map on to a descriptive term, such as “long”, as in “long right”. Descriptive terms are more ambiguous because they are normative: they assume a “standard” length corner in comparison with which a “long” corner is longer. curvature = function(x,y){ #729181.8, 729186.1, 729190.4 #4957667 , 4957676, 4957685 tryCatch({ # circlefit gives an error if we pass a straight line # ALso hide the print statement in circlefit pracma::circlefit(x,y)[3] }, error = function(err) { # For a straight, return the first co-ord and Inf diameter # Alternatively, pass zero diameter? c(x[1], y[1], Inf)[3]}) } curvature2 = function(x1, x2, x3, y1, y2, y3){ curvature(c(x1, x2, x3), c(y1, y2, y3)) } curvatures = Vectorize(curvature2) curvatures2 = function(route, x=&#39;Midpoint_X&#39;, y=&#39;Midpoint_Y&#39;) { curvatures(route[[x]], lead(route[[x]], 1), lead(route[[x]],2), route[[y]], lead(route[[y]]), lead(route[[y]],2) ) } route_convexity$turn_intensity = curvatures2(route_convexity) Preview the result: head(route_convexity) ## FID RID MidMeas WindowSize RawConvexity ConvexityIndex Sinuosity Midpoint_X ## 1 1 SS 1 10 20 0.000 0.000 0.500 729181.8 ## 2 1 SS 1 20 20 -0.040 -0.004 0.500 729186.1 ## 3 1 SS 1 30 20 -0.014 -0.001 0.500 729190.4 ## 4 1 SS 1 40 20 0.000 0.000 0.500 729194.6 ## 5 1 SS 1 50 20 -1.739 -0.174 0.509 729198.8 ## 6 1 SS 1 60 20 -0.093 -0.009 0.501 729199.6 ## Midpoint_Y turn_intensity ## 1 4957667 Inf ## 2 4957676 Inf ## 3 4957685 Inf ## 4 4957694 28.64928 ## 5 4957703 534.95134 ## 6 4957713 18.13793 "]]
