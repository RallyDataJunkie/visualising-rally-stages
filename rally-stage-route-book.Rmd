---
title: "Visualising WRC Rally Stages With `rayshader` and R"
subtitle: "A RallyDataJunkie Adventure"
author: "Tony Hirst"
description: "Rally stage maps often appear on rally websites displayed via interactive web maps. The data used to generate the routes is often available as a digital data file of some sort. This book takes one such file and embarks on an adventure into the wilds of geocomputing using the R programming language to see just where such a file may take us. From web maps and elevation maps to interactive 3D displays, let the exploration commence..."
knit: "bookdown::render_book"
site: bookdown::bookdown_site
always_allow_html: yes
new_session: no
---
```{r message=FALSE, warning=FALSE, echo=FALSE}
knitr::opts_chunk$set(cache = T)
library(tidyr)
```


<!--chapter:end:index.Rmd-->

# In the beginning... {-}

*... was a rally stage route map in the form of a KML file. This was all well and good, but what could you do with it, exactly?*

This book is an exploration of just that: what you can do with a digital file containing the geographical co-ordinates of a rally stage route map and a handful of R packages to help us on our way.

So get strapped in, and we'll be off... There's a lot to take in, with the occasional *don't cut* and *caution* along the way, but there are ruts we can follow and a flying finish to look forward to...

# Acknowledgements {-}

This book would not have been possible without the wide range of packages developed and supported by the R community, not least (but certainly no limited to) those responsible for developing the `raster`, `ggplot2`, `leaflet`, `rayshader`, `rgl` and `htmlwidgets` packages. The `sf`, `sp`  and `regeos `packages provide many of the foundational components I used to reporesent and manipulate spatial data.

I also benefited greatly from package documentation and vignettes, tutorials, blog post and Stack Overflow questions and answers.

<!--chapter:end:welcome.Rmd-->

---
output:
  pdf_document: default
  html_document: default
---
# Preface {-}

Idly skimming through my news feeds, I was reminded by some stunning mountain views of the `rayshader` R package for creating 3D visualisations of map terrain.

I've been sketching various ways of displaying rally stage results for some time (see the forthcoming *Rally Data Junkie Guide to Visualising Rally Results Data*), but geo data is another beast entirely. I already had a pile of half-started recipes for visualising and stage routes and car telemetry data, so maybe this was the reason I needed to write up those notes and finish them off with a recipe for creating 3D stage maps.

As it turned out, I dumped my original stage route analysis code, which was written in the Python programming language, and moved to the R language. In part, this was because it gave a more direct route to working with `rayshader` (although we can, if we have to, be quite promiscuous in what language we use, because we can, if we want to, run Python code from R). In part, it also allowed me to update my R knowledge from my original learning journey into that language several years ago, previously written up as [*Wrangling F1 Data With R*](https://leanpub.com/wranglingf1datawithr).

Along the way, I started to make a bit more sense of the data structure minefield surrounding geodata representations, although always with a focus of *getting stuff done* and solving practical problems associated with generating particular map views, rather than immersing myself in abstract academic conceptualisations.

So this book is the result of that journey, a journey that started with a single XML downloaded from the WRC website. The XML file contained the stage routes for the 2021 *Rallye Monte Carlo* and the book is record of the next 10 days, a period that started out with the goal of visualising the route on a 3D map generated using `rayshader`, but took in many more views along the way. I didn't get quite as far as making a start on the telemetry data either. That will have to wait for another day, another learning journey, and perhaps another book.

*--tony.hirst, Isle of Wight, February, 2021*

<!--chapter:end:preface.Rmd-->

---
output:
  pdf_document: default
  html_document: default
---
# Introduction

Rally fans the world over will undoubtedly be familiar with the [Rally-Maps.com](https://www.rally-maps.com/) website, This website publishes a comprehensive selection of stage maps for a wide variety of events across the world using *OpenStreetMap* interactive web maps . WRC+ subscribers will also be familiar with the live interactive web maps used to display the progress of cars through stages and along road section liaison routes during WRC events.

In this recipe collection, I'll describe various ways of visualising WRC rally stage routes using KML data files downloaded from the WRC website. The techniques should apply equally to  a wider range of data that may also be available from sites such as *rally-maps.com*, as well as downloaded directly from websites associated with particular rallies.

The visualisations we'll look at include:

- visualising simple 2D renderings of rally stages;
- visualising stages overlaid on interactive *OpenStreetMap* maps;
- visualising stages on 2D relief shaded maps;
- visualising elevation and curvature profiles of stages;
- visualising stages in 3D raytraced maps.

We'll also explore how to categorise rally stages in terms of their elevation profiles and "curviness". Our interest may be rally stages, but researchers in areas such as ecology also have an interest in the shape of trails, animal trails in particular, and we can pinch some of their ideas to help us categorise and classify rally stages in a research-led way.

## Who This Book Is For

Firstly, this book is for *me*: it's a write of a learning journey that started with me wondering if I could use `rayshader` to render 3D maps of WRC stage routes and then rapidly become rather more.

Secondly, this book is for rally fans wanting who fancy tinkering with a bit of code, either to get into using R, or who want to get a feel for what geocomputing may have to offer, or both.

Thirdly, this book is for rally fans and perhaps sports journalists who are interested in exploring the data hinterland of rallying. A lot is spoken about th technology led nature of Formula One, but top-flight rallying is also global in reach, technologically led with manufacturer support, and one of the most friendly, welcoming and accessible forms of motorsport for fans, volunteers and competitors alike.

Fourthly, it's for anyone who wonders whether their peculiar interest could provide enough scope for a theme led learning journey into a particular area of programming or data analysis. This book started with a stage map KML file and a passing glimpse of a `rayshader` 3D map that made me wonder *Could I do that?*. From that simple start, my curiosity then took me on a journey I hadn't quite anticipated when I first set out on it...

And finally, it may be useful as a resource for R geo hackers working with linear geometries and single route data, if only to demonstrate how *not* to do things!


## What This Book Isn't

If you're looking for an academic course on how to write R, this book isn't that: it's more of a recipe book in which I bluff my way through using a wide range of R specialised and properly written R packages glues together with as few lines of R code as I can muster to perform particular tasks.

Unlike many "teach yourself to code" books, there will be *bad practice* demonstrations along the way. I often don't appreciate why certain things are best done a particular way until I do them the wrong way first and see why they're wrong. I think you may benefit from some of that pain too! For a novice, a particular approach may seem eminently reasonable, and then turn out to lead to problems. As a learner myself, I'll show you some of those "as might be expected" false starts, and then backtrack to show how, and why, there's a better way.

A major part of this book is engaged in wrangling data representations that allow us to work with data objects in a spatially relevant way. When working with time series data, if you represent the data as datetime or time-interval objects you can do natural timey-wimey things with them, like group them by day of week, or month of year, or plot them against time of day. Similarly, geodata becomes more powerful if you can process it in a geospatial way and do spacy-wacy things with it. Combining the two forms of representation — time series based telemetry data with added spatial location data goodness — is left for another day.

Making sense of spatial data representations can be both bewildering and confusing, and I remain bewildered and confused by them. So this book is also not in any sense a formal primer for working with the `sp`, `sf`, `proj4` and `raster` packages. However, I hope that it does serve as a practical data junkie's guide to using those packages to get stuff done and that the overview I do provide of spatial data representations is useful.

Finally, it's worth reminding ourselves that this journey into geocomputation is focused on a single, particular, and some might say, peculiar, context: rally stage data. This focus provides us with a rationale for exploring certain geospatial ideas, or specific functions in geocomputation packages, in a motivated way. As a result, you will hopefully pick up some ideas that you might be able to apply in other contexts. But if the rally stage route theme doesn't motivate you, then find some other for of route data and try to visualise that: the computer doesn't care what the data represents, as long as it's a route...

## Structure of the Book

The structure of the book broadly follows my own learning journey the various topics, at least on a first pass. As I continued to explore various themes I started to return to various sections to extend them or revise and improve some of the Frankenstein techniques I'd used to get various things working when I was still flying blind and working with only a very hazy understanding of the various packages and functions within them that support working in this particular area.

The book opens with a brief consideration of how to set up a computational environment to work through the executable elements of this content yourself.

I then describe how to open the KML file that started me on my journey, along with other geodata file formats and how to convert between them. With data in hand, we see how quickly preview simple routes using `ggplot2` charts, as well as overlaying them on interactive `leaflet` maps. It is at this point that geographical projections also make their first appearance. Annotating stage routes with additional information, some derived from the route itself (such as stage start and end locations), some from other sources, such as the location of split points described in terms of distance into the stage, comes next.

Elevation data is essential for generating three-dimensional renderings of landscapes, so the next part introduces sources of open elevation data in the form of elevation raster data. Demonstrations of how to download and preview this data for specific areas, as well as buffered regions comes next, along with a review of how to access metadata and information about the rasters themselves. We also see how we can derive additional geometric layers, such as contour line overlays, from the elevation data itself.

With elevation data in hand, we then see how it can be rendered in two dimensions using `rayshader`, followed by sections on how to add overlays to such maps, including map tile overlays, and how to annotate them with "derived" data such as contour lines. We also see how to add stage routes to the maps.

Three dimensional rendering of maps is preceded with a short aside, showing how `rayshader` can be used to render models of an arbitrary type as long as they can be represented by a 2D matrix of height values. It is quite straightforward to map an image to such a representation using the RGB pixel values as a base 256 elevation value, so we run with this idea to render a Penny Red stamp as a 3D model, using the colour values to determine elevation.

The story now moves on to rendering maps in three dimensions using `rayshader`, along with stage route overlays, my original motivation for this whole adventure. The `rayshader` package includes a wide variety of tools for setting up camera shots, as well as rendering videos to show off a model, are covered next. Lighting effects are consider too, most notably in the form of setting sun position appropriate to particular dates and times of day so we can get a feel for how shade and light might fall across a stage.

The next section introduces something that had never really occurred to me before I stumbled across the term *sinuosity*, a metric often used to describe the "twistiness" of rivers in environmental and ecological research. This led me to a wide range of packages produced by ecological researchers who provide a variety of tools for processing and analysing animal tracks. Many of the techniques they have developed can also be applied to describing the structure of a rally stage and also provide a basis for working with geolocated telemetry data, although that particular consideration will have to wait for another book and another day.

Having analysed stage route structure in two dimensions, we then revisit stage elevation data, visualising it using `rayshader`s three dimensional `ggplot2` plotting tools to render 3D ribbon traces of stage routes. `rayshader`s support for exporting 3D print model files suggests some exciting possibilities for producing stage route models here!

Returning to the theme of annotating maps, the final section looks at enriching maps with the addition of data retrieved from the *OpenStreetMap* Overpass API. *OpenStreetMap* publish a wide range of datasets from tracks and roads information, as geodata, as well building outlines, and a wide range of data points covering labeled sites of interest, such as campsites, car parks and viewpoints. We review how to retrieve such data and add it to our maps.

The book closes with a brief consideration of what may be next...

## Further Reading

There are several other freely available books out there do provide a more principled guide to some of the topics consider herein.

For a slightly more principled overview of geocomputing in R, see [*Geocomputation with R*](https://geocompr.robinlovelace.net/) by Robin Lovelace, Jakub Nowosad, Jannes Muenchow.


<!--chapter:end:intro.Rmd-->

# Getting Started

One of the biggest obstacles to using code is, or at least, *used to be*, setting up the computational environment you need in order to be able to read, write and execute code.

But in recent years, thinks have got a lot easier, so 

If you want to try working through the examples yourself, you will need ?? Jupyter book??


## Setting Up a Working Code Execution Environment

To try to make it possible to follow along with running the code contained within this book, I have created a Docker container containing all th necessary packages, as well as version of the original Rmd files used to create this book.


### Installing the Docker Environment

The container is built up from a [`rocker/geospatial` Docker image](https://github.com/rocker-org/geospatial) base. You can find the Dockerfile in the[`RallyDataJunkie/visualising-rally-stages`](https://github.com/RallyDataJunkie/visualising-rally-stages) Github repository.

To install the container, you will need to install Docker first. Installation instructions for installing Docker Desktop, which includes the Docker community edition, on Windows, Mac and Linux computers can be found on the Docker website: [*Get Docker*](https://docs.docker.com/get-docker/).

At the time of writing, the Docker image has not been built for `arm64` devices, which means that it currently *will not* run on Mac M1 or Raspberry Pi 64 bit operating system devices.

To launch the docker container, run the following command on the command line:

`docker run -d -p 8788:8787 psychemedia/rayshader`

When mounting a volume into the container (`-v localDirPath:containerDirPath`), be aware that the default working directory inside the container is `/home/rstudio`.

With the container running, visit `localhost:8788` in your browser and you should be presented with an RStudio login screen. The default username/password combination is `rstudio/rstudio`.

*At the current time, the Rmd files are not bundled in the container but they can be found in the [`RallyDataJunkie/visualising-rally-stages`](https://github.com/RallyDataJunkie/visualising-rally-stages) Github repository.*

#### Connecting the Docker Container to Other Containers

Docker containers running different services or applications can be linked together, and share mounted storage columes, using [Docker Compose](https://docs.docker.com/compose/). For an example of linking an RStudio container to a Jupyter server container and a Neo4J graph database seever, see [Accessing a Neo4j Graph Database Server from RStudio and Jupyter R Notebooks Using Docker Containers](https://blog.ouseful.info/2016/04/12/accessing-a-neo4j-graph-database-server-from-rstudio-and-jupyter-r-notebooks-using-docker-containers/). For an example of linking an RStudio container to a container running an `ergast` F1/Formula-E results database server, see [`psychemedia/ergast-f1-api`](https://github.com/psychemedia/ergast-f1-api). The blog post [Rolling Your Own Jupyter and RStudio Data Analysis Environment Around Apache Drill Using docker-compose](https://blog.ouseful.info/2017/06/16/rolling-your-own-jupyter-and-rstudio-data-analysis-environment-around-apache-drill-using-docker-compose/) demonstrates how to mount a common storage volume between two containers.

### Installing the Required R Packages Manually

The code described in this books uses a large number of specialised R packages. Many of them can be found on CRAN, but some need to be installed directly from their original code repository on Github.

If you are not using the pre-defined environment, you will need to ensure that all the required packages are in stalled in your R environment in order to run the code.

The required packages are listed in the Dockerfile used to create the Docker container used to support this book. The Dockerfile can be found in the [`RallyDataJunkie/visualising-rally-stages`](https://github.com/RallyDataJunkie/visualising-rally-stages) Github repository.

You may find that in order to *install* some packages requires other, non-R packages to be installed on your computer first. Check the *Other Installation Dependencies* section first for details of these pre-requisites. 
You may also find that in order *run* some of the packages requires other application dependencies, even if the package installs correctly. As with the installation dependencies, check the *Other Installation Dependencies* section first for details of these pre-requisites. 


### Other Installation Dependencies

Several of the R packages have dependencies on operating system applications or packages.

Know dependencies include:

- GDAL
- ImageMagick


## Using the RStudio Environment

The RStudio integrated development environment (IDE) is bundled in the original `rocker` container that provides the original basis for the container developed to support this book.

An overview of the RStudio IDE can be found on the RStudio website: [`rstudio/features`](https://rstudio.com/products/rstudio/features/). A [video tour](https://rstudio.com/products/rstudio/) is also available.

## Using a Jupyter Notebook Environment

Whilst Rmd documents can be opened within a Jupyter notebook environment with [Jupytext](https://jupytext.readthedocs.io/) installed, and the code contained within them executed from that environment

To run the Rmd files with Jupyter notebooks, along with the other dependencies, you will need to:

- install Jupyter
- install Jupytext
- install an R Jupyter kernel

Note that the required R packages must be installed into the R environment made available via the Jupyter R kernel.


## Exploring the Book as an Online Interactive Textbook (Not Yet!)

The original rendering of this book was created with the [R `bookdown` package](https://bookdown.org/). It should also be possible to create [Jupyter Book](https://jupyterbook.org/intro.html) version of the materials from the original Rmd source files through the magic of Jupytext.

## Serving Your Own Map Tiles and Elevation Raster Images

In order to display interactive web maps, overlay `rayshader` maps with third party map tiles, and access elevation data raster files, we need to call on a tile server, at least initially.

All the tools described in this book make use of third party tileservers, called via APIs. However, it is also possible to doanload map tiles and sever them from our own tile server (although we will then need to find how to configure tile using packages to use our local server).

The lightweight and easy to use `datasette` SQLite database server is a Python package that provides a simple route to running a tileserver through its [`datasette-tiles`](https://datasette.io/plugins/datasette-tiles) plugin. Tiles can easily be downloaded for adding the the server using the [`datasette/download-tiles`](https://datasette.io/tools/download-tiles) tool.

An overview of how to set up a tileserver is described in [*Serving map tiles from SQLite with MBTiles and datasette-tiles*](https://simonwillison.net/2021/Feb/4/datasette-tiles/). For downloading raster elevation tiles, see for example [*Downloading MapZen elevation tiles*](https://til.simonwillison.net/gis/mapzen-elevation-tiles).


## Donate

If I didn't have to work for a living, I'd be able to do more of this sort of thing, and spend more time volunteering as a rally marshal... In the meantime, consider this as a tip jar: any monies received will go towards [covering the costs](https://revdancatt.com/2021/02/05/a-short-essay-on-pricing-pen-plotter-art) of my rally-related activities...

<form action="https://www.paypal.com/donate" method="post" target="_top">
<input type="hidden" name="hosted_button_id" value="RJ7ZF3A9BXTRU" />
<input type="image" src="https://www.paypalobjects.com/en_GB/i/btn/btn_donate_SM.gif" border="0" name="submit" title="PayPal - The safer, easier way to pay online!" alt="Donate with PayPal button" />
<img alt="" border="0" src="https://www.paypal.com/en_GB/i/scr/pixel.gif" width="1" height="1" />
</form>

If you're interested in learning more about rally marshalling, check out [volunteering opportunites via *motorspot uk*](https://www.motorsportuk.org/volunteers/marshals/) and the [British Rally Marshals Club (BRMC)](https://www.brmc.org.uk/). For a taste of what's involved, read my [*Rally marshal taster event* review](https://blog.ouseful.info/2018/01/27/rally-marshal-taster-event/).

<!--chapter:end:getting-started.Rmd-->

```{r cache = F, echo = F, message=F}
# 2Allow knitr to continue to execute even in the presence of errors
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/stage-route-import-")
```

# (PART) Accessing Stage Data {-}

# Importing the Stage Route Data

The starting point for this adventure is an XML text file downloaded from the WRC website. The file contains data that describes the stage routes for the 2021 *Rallye Monte Carlo* using the KML file format. This format ("Keyhole Markup Language") was originally developed as a way loading data into the application that became Google Earth following its acquisition by Google. KML is now an [international standard](https://www.ogc.org/standards/kml) maintained by the Open Geospatial Consortium, Inc. (OGC).

*If you see the `.kmz` file suffix attached a file, the file is a compressed (zipped) KML file.* 

The first part of this chapter is the boring part, describing how to load the data in and some differences that arise depending on *how* you load it in. (If you do a web search, you'll find there are various tools for opening KML files into an R program.) The second part shows how we can actually start to preview the data in a graphical way.


## Downloading the Stage Data File

Let's start by downloading the data from its web location:

```{r}
file.url = 'https://webapps.wrc.com/2020/web/obc/kml/montecarlo_2021.xml'
downladed.filename = 'montecarlo_2021.xml'

# Download the file from a specified web location to a specifically named file
download.file(file.url, downladed.filename)
```

## Opening KML Geodata Files

A wide variety of geodata file formats can be opened using general purpose geodata packages as well as certain specialist packages.

Two powerful general purpose packages are `rgdal` and `sf`, the *simple features* package.

### Using `rgdal` and `sp` to Open Geodata Files
One way of reading in the file we have just downloaded is to use the `readOGR()` function found in the `rgdal` package. We can call this function explicitly from the package as `rgdal::readOGR()` or we can import the package and then access the function simply by calling it by name:

```{r message=FALSE}
# Import the rgdal package
library(rgdal)

kml.file <- "montecarlo_2021.xml"

kml_sp = readOGR(kml.file)
```

The `readOGR()` function is capable of loading in a wide variety of geo-related file formats and automatically detecting what sort of format the file represents.

We can see what sort of object is loaded in by inspecting its `class()`:

```{r}
class(kml_sp)
```

In this case, the KML file is loaded in and parsed into a `SpatialLinesDataFrame` object although as you may have noticed from a warning message when the file was loaded that the Z (altitude) dimension  been discarded (as we shall see later, it is actually contains zero values anyway).

The `SpatialLinesDataFrame` datatype, along with other spatial datatypes, is defined in the R `sp` package. To a certain extent, the classes (that is, data types) declared by this package have been superseded by a different datatype hierarchy defined by the more recent `sf` package. However, the `sp` package is still a dependency of many of R's spatial data packages and some functions rely on being presented with `SpatialLinesDataFrame` object data, for example.


### Using `sf` to Open Geodata Files

The `sf` package is a more recently created package for working with geodata primitives and is maintained under the auspices of the [`r-spatial` Github organisation](https://github.com/r-spatial).

We can load in data from a wide range of geodata file formats using the `sf::st_read()` function:

```{r warning=FALSE, message=FALSE}
library(sf)

kml_sf = st_read(kml.file)
```

In this case, we notice that the data has been loaded into a spatial features *simple feature* collection.

The data loaded into each object is the same, but it is represented differently. There are ways of converting between various forms of the two representations as we shall see later.

One thing to note in each case that the data appears to have been loaded in from a particular *layer*. The KML file format is capable of grouping various sets of data together in different ways. Where the datafile contains only one element that is decoded as a "layer", that is loaded in by default. If multiple layers are detected they will be reported and can then be loaded in and "unpacked" by name.

We can also review the contents of the file by opening it with the `sf::st_layers()` function:

```{r}
# Preview the file layers
st_layers(kml.file)
```

If there is more than one layer, we can load it in by name:

```{r}
kml_sf = st_read(kml.file, "Meine Orte")
```

#### Reviewing the `sf` Feature Collection

The layer contains a feature collection with features containing linestrings in 3-dimensions (XYZ). There are several keys things to note:

- the *projection* is WGS 84, the common "lat long" projection
- the Z-range (altitude, or elevation) appears to be zeroed.

If we refer back to the data object loaded in using the `rdgal::readOGR` function, we note that it does not contain the Z co-ordinate. We can see this more clearly if we convert that `sp` *SpatialDataFrame* object to a simple features object using the `sf::st_as_sf()` function:

```{r}
st_as_sf(kml_sp)
```

A conversion also exists back from the `sf` object to the `sp` representation:

```{r}
round_trip = as( st_as_sf(kml_sp), "Spatial")
```

However, if we try the same conversion on the simple features collection created directly from the parsed KML file, we get an error:

```{r}
#round_trip2 = as( kml_sf, "Spatial")
```

The problem appears to be the Z layer. If we drop the zeroed Z layer manually, whilst preserving the projection:

```{r}
kml_sf = st_zm(kml_sf, drop = TRUE, what = "ZM")
```

we can then convert this simple feature collection to a *SpatialDataFrame*  `Spatial` object:

```{r}
round_trip2 = as( kml_sf, "Spatial")
```


### Accessing Route Data as a geojson String

GeoJSON is a widely used format for getting geodata into web pages. We can get the route for a stage from the routes spatial collection and cast it to JSON using the `geojsonio::geojson_json` function:

```{r message=FALSE}
# Retrieve the geojson for a single stage and
# from within that, the linestring geometry,
# casting it to a geojson string
stage_route_gj = geojsonio::geojson_json(kml_sf[1,]$geometry)
```


### Saving Simple Features Data to Various Geodata File Formats

The `st_write` function has a range of output drivers for writing geodata to different output types. although data may be last and/or the conversion of a dataset loaded from one format and output to another may not be as meaningful as may be desired.

For example, we can write an object out to a geojson file:

```{r message=FALSE}
geojson_filename = 'montecarlo_2021.geojson'

# The st_write function can update files or create new ones, but not
# replace existing ones. So let's make sure the file doesn't exist
# by deleting it if it does...
if (file.exists(geojson_filename)) {
  #Delete file if it exists
  file.remove(geojson_filename)
}

st_write(kml_sf, geojson_filename, driver='geojson')
```

Equally, we can we write out the data loaded as a GPX data file (GPX data files are often used to share data collected from cycling or running route logging applications and devices):

```{r message=FALSE}
gpx_filename = 'route.gpx'

# Remove any previous instances of this file
if (file.exists(gpx_filename)) {
  #Delete file if it exists
  file.remove(gpx_filename)
}

st_write(kml_sf, gpx_filename, 
         driver='GPX', dataset_options ="GPX_USE_EXTENSIONS=yes" )
```

If we have access to car telemetry data in a simple tabular form, it may be convenient to save it using the GPX format as a convenient way of serialising that data.

## Important Geodata File Formats

The `sf::st_read()` (as well as the `rdgal::readOGR()` function) is capable of reading in data from a wide variety of file formats.

We have already seen how it can load in data from a KML file, so let's see how it copes with some other file formats.

### Loading geojson Data

As well as KML files, route data is may be available in the GeoJSON text format. We can read *geojson* data file into R using the `sf::st_read()` function , returning the data as a spatial object:

```{r}
geojson_sf = sf::st_read(geojson_filename)
```

As before, we can convert the simple features object to a `Spatial` dataframe by dropping the z-axis and then converting:

```{r}
geojson_sf = as(st_zm(geojson_sf, drop = TRUE, what = "ZM"), "Spatial")
```

If you have a geojson string, you can cast it to a spatial object using the `geojsonio::geojson_sp(geojson_str)` function:

```{r}
geojson_str = '{"type": "Point","coordinates": [-105.01621,39.57422]}'

class( geojsonio::geojson_sp(geojson_str) )
```

### Loading GPX Data

Route data collected by personal GPS devices is often shared using GPX files.

We can read in GPX files using `sf::st_read`:

```{r}
st_read(gpx_filename)
```

The `plotKML` package, which has a wide range of tools for creating KML files and rendering KML into Google Earth, also has a custom function for loading in GPX files:
 
```{r warning=FALSE, message=FALSE}
#http://plotkml.r-forge.r-project.org/readGPX.html
library(plotKML)

gpx = readGPX(gpx_filename)
```

In this particular case, the GPX file contains multiple routes which we index by name.

A dataframe of point values, one point per row, is associated with each route:

```{r}
head(gpx$routes$`SS 1`, 3)
```
In a "born GPX" file, we might expect to see more of the columns populated. As it currently stands, the GPX file we created from the original data, which was more or less limited to simple 2D linestrings, contains just the latitude and longitude data, albeit still in distinct stage identifiable routes.

### Loading Flight Data Using IGC format GPS Files

GPS route data contained in [IGC](https://xp-soaring.github.io/igc_file_format/igc_format_2008.html) formatted flight data files can be loaded in using the `geoviz::read_igc("path/to/your/file.igc")` function.

### Reading Data from GPS Devices

The [`pgirmess` *Spatial Analysis and Data Mining for Field Ecologists) package*](https://rdrr.io/cran/pgirmess/) package provides a range of tools for retrieving data from GPS devices and then analysing them. The `pgirmess::gps2gpx()` function provides support from retrieving GPS data from a range of devices via the *GPSBabel* application](http://www.gpsbabel.org/), writing waypoint or track data to GPX files to local storage with the `pgirmess::writeGPX()` function, and uploading GPX data back up to Garmin GPS devices (`pgirmess::uploadGPS()`).


<!--chapter:end:stage-route-import.Rmd-->

```{r cache = T, echo = F, message=F}
# 1Allow knitr to continue to execute even in the presence of errors
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/stage-route-preview-")
```

# Working with Route Data

Having learned how to load in the route data in the previous chapter, we'll use this chapter to explore in a little bit more detail what we can actually do with it.

## Loading in the Route Data

Each chapter in this book is intended to be self-contained in terms of the code contained within the chapter. So we'll need to start by loading the data in.

For convenience, I'll load the data in from the geojson file that we created from the original KML data file in the previous chapter.

```{r warning=FALSE, message=FALSE}
library(sf)

# We previously converted the KML file to a geojson file
geojson_filename = 'montecarlo_2021.geojson'

# The geojson file contains essentially the same data (except the zeroed Z values)
# as the original KML file
geojson_sf = st_read(geojson_filename)
```

Howsoever we have loaded in the data, we should have some sort of data structure that contains one or more routes. In the case of our loaded in KML file, or the geojson object,  each route is presented in the form of a linestring, made up as a list of consecutive co-ordinate pairs along the route.

To simplify the view of the data we might expect to see, let's cast the original KML object obtained from the WRC KML file directly into a dataframe:

```{r}
kml_df = as.data.frame(geojson_sf)
kml_df
```

## Access a specific stage

We can access a specific stage, which is to say, a specific row of the features dataframe, by direct indexing:

```{r}
geojson_sf[3,]
```

We can find the length of each stage route using the `sf::st_length()` function:

```{r}
st_length(geojson_sf)
```

Or the length of a specific stage:

```{r}
st_length(geojson_sf[1,])
# 21069.62
```

Note that you may need to take this distances with a pinch of salt. The WRC website gives the stage length of SS1 as 20.58 km, for example, not 21.07 km, so it's not clear whether the route in the KML file is the competitive route, or whether is starts and finishes with time controls at either end of the route. It may be that the stage distance also follows the racing line, which is likely to be shorter than than the piecewise linear route we access from the KML file.

There are also several different ways in which we can calculate the distance each of which may have slightly different parameter settings baked in, such as the distance round the equator, that are likely to influence the result of any distance calculations we perform.

It is also worth noting that elevation changes mean that the actual route length is likely to be *greater* than the distance measured over a 2 dimensional route in the XY (longitude-latitude) plane.


## Visual Preview of Route Geodata

Let's generate a quick preview of all the stages. The dataframe contains a column of encoded linestrings. We can preview these directly with a simple plot:

```{r kml_peview}
plot(st_geometry(geojson_sf))
```

This shows the rough outline of each stage, and their relative positions, but represents little more than a back of a napkin sketch.  

## Previews using `ggplot2`

In some circumstances, we may want to work with the route data in `ggplot2`.

The `ggplot2` package is aware of simple features (`sf`) representations, although we need to inform it that such a dataset has been provided via the [`ggplot2::geom_sf()` function](https://ggplot2.tidyverse.org/reference/ggsf.html).

We can preview the data as follows, firstly over all features:

```{r gg-preview}
# https://ggplot2.tidyverse.org/reference/ggsf.html
library(ggplot2)

ggplot(data=geojson_sf) + geom_sf()
```

Note how the co-ordinate axes are rendered in degrees longitude (x coordinate) and degrees latitude (y co-ordinate) using a familiar projection (that is, the x and y axes are in a proportion that you are likely to recognise from most atlases and (web) maps).

The `ggpubr::ggarrange()` function allows us to create an arrangement of plots made up from a list separate plot for each stage. We can also take the opportunity to demonstrate how we might start styling the x-tick labels using the `axis.text.x` parameter to the `ggplot::theme()`:

```{r gg-pubr}
stageplot = function(x, output) {
  ggplot(data=x) + geom_sf() +
    theme(axis.text.x = element_text(angle = 90,
                                     face='italic',  size = 7),
          axis.text.y = element_text(face='italic',  size = 7))
}
 

stages_kml = kml_df$geometry

#apply(X, MARGIN, FUN, …)
ggpubr::ggarrange(plotlist=lapply(stages_kml, stageplot))
```

We can visualise the data for just a single route by limiting the data we pass to the `ggplot()` function:

```{r gg-single-route}
g = ggplot(data=geojson_sf[1,]) + geom_sf()
g
```
In rendering this map, note how we can assign the plot to a variable (`g`) and then display the map by referencing the variable.

## Identifying the Start and End of the Stage

We can grab the co-ordinates of locations at the start and end of the stage, assuming that the linestrings are presented in the order *start-finish*:

```{r}
stage_coords = as.data.frame(st_coordinates(kml_df[1, ]$geometry))

stage_start_coords = stage_coords[1, ]
stage_end_coords = stage_coords[nrow(stage_coords), ]

first_and_last = stage_coords[c(1,nrow(stage_coords)),]
first_and_last$label=c('SS1 stage start', 'SS1 stage end')
first_and_last$typ=c('start', 'stop')
first_and_last$color=c('green', 'red')
first_and_last
```

We can then highlight these features on our stage plot:

```{r gg-route-start-stop}
g + 
  geom_point(aes(x=X, y=Y,  color = typ),size =5, alpha = 0.5,
             data=first_and_last) +
  scale_color_manual(values=c("blue", "red"))
```

## Extracting Route Fragments

We can readily extract a fragment from a line by indexing against the line segment indices. For example, to gran the first 10 straighline segments from the linestring we can extract just those coordinates and build a new linestring from them:

```{r}
cc = as.data.frame(st_coordinates(geojson_sf[1,]))[1:10,]

route_segment = st_linestring(cbind(x=cc[,1], y=cc[,2]))

# We can plot the linestring using the same sort of geo projection
# as was applied to the original route
ggplot(route_segment) + geom_sf(crs=st_crs(geojson_sf[1,]))

```

## Previews Using `leaflet` Interactive Maps

Simple plots of the route gives us a snapshot of the shapes of various routes and their relative positioning, but it's far more useful to preview the routes over a simple map background, such as an interactive OpenStreetMap map.

The [`leaflet` package](https://rstudio.github.io/leaflet/) provides a range of tools for working with the *leaflet* Javascript package to visualise such maps.

The `leaflet::leaflet` function creates interactive maps based around map tiles that can be retrieved from a variety of map tile providers. Some providers may require an API key or access credentials. For moderate use, we can freely access *OpenStreetMap* or [*Stamen*](http://maps.stamen.com/) tiles in a variety of themes without any form of authentication:

```{r warning=FALSE, message=FALSE}
library(leaflet)

# Alternatively, we might set:
# stages_kml = kml[,'geometry']

# Note that leaflet seems to requires us to to have dropped 
# the Z and M dimensions from the linestrings
leaflet(stages_kml) %>% 
  addProviderTiles("Stamen.TonerLite",
                   # Other themes include:
                   # Stamen.TonerLite, Stamen.Terrain, OpenStreetMap.Mapnik
                   # Stamen.TerrainBackground, OpenTopoMap
                   group = "OSM") %>% 
  addPolylines(color = "red", weight = 3)
```

The *Stamen.TonerLite* theme is very clear for identifying where the stages are whilst the *OpenTopoMap* and *Stamen.TerrainBackground* themes are using for showing relief, particularly in mountainous or hilly stages.

As well as previewing all the stage routes in the features collection, we can extract the linestring geometry for a single route:

```{r}
kml_geom = kml_df[1, ]$geometry
kml_geom
# kml_df[kml_df$Name=='SS 1' , ] # Get row
```

We can now generate a quick map preview of that particular stage:

```{r}
leaflet(stages_kml[1]) %>% 
  addProviderTiles("OpenTopoMap", group = "OSM") %>% 
  addPolylines(color = "red", weight = 5)
```

We can also highlight the stage start and end points as simple circle markers, as pin "balloon" markers, in this case with a fixed label to annotate the stage start and finish:

```{r}
# Create a palette that maps factor levels to colors
pal <- colorFactor(c("darkgreen", "darkred"),
                   domain = c("start", "stop"))

m = leaflet(stages_kml[1]) %>% 
      addProviderTiles("OpenTopoMap", group = "OSM") %>% 
      addPolylines(color = "red", weight = 5)

m %>%
  addMarkers(~X, ~Y, #popup = ~label,
             label = ~label,
             labelOptions = labelOptions(noHide = T,
                                         direction = "bottom",
                                         style = list(
                                          "color" = 'black',
                                          "font-family" = "serif",
                                          "font-style" = "italic",
                                          "box-shadow" = "3px 3px rgba(0,0,0,0.25)",
                                          "font-size" = "12px",
                                          "border-color" = "rgba(0,0,0,0.5)"
                                          )),
            data=first_and_last) %>%
  addCircleMarkers(~X, ~Y,  radius =10, color = ~pal(typ),
                   stroke = FALSE, fillOpacity = 0.5,
                   data=first_and_last)
```

As well as using default markers, we can define custom markers:

```{r}
# https://fontawesome.com/v4.7.0/icons/ 
start_stop_markers <- awesomeIconList(
  "start" = makeAwesomeIcon(
    icon = "play-circle",
    markerColor = "blue",
    library = "fa"
  ),
    "stop" = makeAwesomeIcon(
    icon = "stop-circle",
    markerColor = "red",
    library = "fa"
  )
)
```

We can add the markers directly to our earlier created leaflet map object:

```{r}
m %>% 
  addAwesomeMarkers(~X, ~Y,
                    icon = ~ start_stop_markers[typ],
                    label = ~ label,
                    data=first_and_last)
m
```

We can save a map to an image file using the `mapview` package:

```{r}
library(mapview)
# mapview also provides tools for generating leaflet maps from R
image_fn = "demomap.png"

mapshot(m, file = image_fn)
```

We can then review the saved image captured from the map:

```{r embed-demo-map}
knitr::include_graphics(image_fn)
```

## Creating Buffer regions around features

One thing we note from the map is that the display is cropped quite close to the extent of the displayed stage. It would be useful to provide a small buffer around the stage to provide a margin that allows us to see the start and stop clearly.

We can get the bounds of the stage quite simply:

```{r}
stage_bbox = st_bbox(stages_kml[1])
stage_bbox
```

A convenient way of representing the bounding box is to use the *extent()* function from the `raster` package to create an `Extent` class object:

```{r}
raster::extent(stage_bbox)
```

In some functions, we may be able to pass an *extent* object in directly as a function argument.

We can also create a dataframe containing those limits:

```{r}
ex.df <- data.frame(x= c(stage_bbox[['xmin']], stage_bbox[['xmax']]), 
                    y= c(stage_bbox[['ymin']], stage_bbox[['ymax']]))
ex.df
```

The contents of the dataframe representation can be cast as a spatial points object containing two features, whose extent matches the original extent:

```{r}
# For SpatialPoints
library(sp)

bb_sp = SpatialPoints(ex.df)
bb_sp
```

This is useful because we can  create a "buffer" region around those points that will "push out" the extent and give us some co-ordinates that represent a buffered area around the original path.

Let's add a buffer around the trace of five hundred meters:

```{r}
library(spatialEco)

#In passing, recall that WGS84 (latlon) is st_crs(4326) 
proj4string(bb_sp) <- '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs' 

# Create a new, buffered region
stage_bbox = st_bbox(geo.buffer(x=bb_sp, r=500))

# Also update the dataframe of points with these bounds
ex.df <- data.frame(x= c(stage_bbox[['xmin']], stage_bbox[['xmax']]), 
                    y= c(stage_bbox[['ymin']], stage_bbox[['ymax']]))

stage_bbox
```

We can pass these new bounds into the leaflet widget to try to encourage it to show a little more of the map, although noting that it doesn't always force the issue if the buffer isn't big enough...

```{r}
leaflet(stages_kml[1]) %>% 
  fitBounds(stage_bbox[['xmin']], stage_bbox[['ymin']],
            stage_bbox[['xmax']], stage_bbox[['ymax']])  %>% 
  #fitBounds(5.879966, 44.732916,
  #          5.944508, 44.822432)  %>% 
  addProviderTiles("OpenTopoMap", group = "OSM") %>% 
  addPolylines(color = "red", weight = 5)
```

## Adding Additional Features to `leaflet` maps

Several packages exist that allow us to add additional controls and features to interactive *leaflet* maps, including "minimap" navigational support, the ability to add logos and charts to maps, and support for arbitrary HTML and chart content within popups.

### Add "minimap" navigation

To support navigation(?!), we can also add a "minimap", with it's own location and display settings, as well as its own tileset, to show more clearly where in the world is being displayed by the current view.

```{r}
m %>%
 addMiniMap( tiles="Stamen.TonerLite", toggleDisplay = TRUE,
    position = "bottomleft")
```

### Add Custom Symbol Legends

We could add eg rally signs to start and end of stage (and if we have richer detail, radio points, etc). The [`leaflegend`](https://roh.engineering/post/2021-02-04-introduction-to-leaflegend/) R package provides several utilities for creating custom icons.

Rally stage symbols can be found in various custom fonts such as [*dafont/rally-symbols*](https://www.dafont.com/rally-symbols.font) or [*wfonts/rally-symbols*](https://www.wfonts.com/font/rally-symbols).

#### Adding a Logo
The [`r-spatial::leafem` package](https://github.com/r-spatial/leafem) adds several extension features to leaflet maps. For example, we can add a logo to the map:

```{r}
img <- "https://acm.mc/wp-content/uploads/2020/04/Plaque-rouge-2021.png"

# Can we control the size? Or do we have to make a square logo?
m %>% leafem::addLogo(img)
```


### Adding Mini-Charts to Maps

The [`leaflet.minicharts`](https://cran.r-project.org/web/packages/leaflet.minicharts/vignettes/introduction.html) R package allows simple charts to be displayed at specific locations on a map.

### Adding HTML content to popups

The [`leafpop`](https://github.com/r-spatial/leafpop) R package allows us to add HTML tables, images or graphs to `leaflet` or `mapview` popups, as well as `ggplot2` graphics and `htmlwidgets`.

This packages might be useful for adding stage results displays to maps, for example.

## Using `mapview` To Create *leaflet* Maps

As well as using the `leaflet` package to generate *leaflet* maps, the [`mapview` R package](https://r-spatial.github.io/mapview/) provides an alternative way of .

```{r message=FALSE}
library(mapview)

mv = mapview(geojson_sf)
mv
```

The `r-spatial/leafem` package that we can use to enrich maps using the `leaflet` package was in part developed as an abstraction of functions contained within the `mapview` package; both `mapview` and `leafem` are maintained by the [*r-spatial* Github organisation](https://github.com/r-spatial).

<!--chapter:end:stage-route-preview.Rmd-->

```{r cache = T, echo = F, message=F}
# 14Allow knitr to continue to execute even in the presence of errors
#knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/intro-map-projections-")
```
# Introducing Map Projections

At this point, we should probably talk about *coordinate reference systems* (CRS) and  *projections*...

## Load in the Route Data 

Let's load in our route data to give us something to work with:

```{r message=FALSE}
library(sf)

geojson_filename = 'montecarlo_2021.geojson'
geojson_sf = st_read(geojson_filename)
```

## Previewing a Map Route

Recall how our stage map looked when we plotted the *simple features* geo object using `ggplot()` with the `geom_sf()` geometry:

```{r proj-ggplot-example}
library(ggplot2)

g_sf = ggplot(data=geojson_sf[1,]) + geom_sf() +
        theme(axis.text.x = element_text(angle = 45))
g_sf
```

The `geom_sf()` geometry took into account the fact that the co-ordinates were in degrees latitude and longitude and then scaled the visual representation accordingly.

## Plotting LatLong Naively

But what if we plot the coordinates just as numbers...?

We can grab the coordinates from our route using the `sf::st_coordinates()` function and then cast them to a dataframe:

```{r}
coords_df = as.data.frame( st_coordinates(geojson_sf[1,]) )
head(coords_df)
```

If we naively plot those coordinates using the [`ggplot2::geom_path()`] (https://ggplot2.tidyverse.org/reference/geom_path.html) geometry which ensures that we draw a line from the first point to the second, the second to the third, and so on, we get a view that is different to the original view we plotted — the route appears to be more "squashed". Even if we ensure that the x and y scales are in unit proportion by means of the `coord_fixed()` constraint, the projection still look wrong:

```{r squashed_coords}
g_ll = ggplot(coords_df, aes(x=X, y=Y)) +
          geom_path() #+ coord_fixed()

g_ll
```

The difference in appearance relates to how we project the coordinate system that identifies points that identify locations on a large spherical (ish) object – the globe – on a "flat", two dimensional display surface.

*For a good review of geographical projection systems, see this set of lecture notes on [Projections and Coordinate Systems](http://courses.washington.edu/gis250/lessons/projection/) from the University of Washington course "Introduction to Geographic Information Systems in Forest Resources (ESRM250)".*

To render the "geo" view, we need to map the co-ordinates to a scale with regular units, such as meters, rather than spherical coordinates, such as degrees.

In the original object, we see that the coordinates reference system (CRS) is defined in terms of longitude and latitude:

```{r}
st_crs(geojson_sf)$proj4string
```

## Using the UTM Co-ordinate Reference System

The UTM (*Universal Transverse Mercator*) coordinate system uses units of meters rather than degrees. It allows us to represent spatial extents using  "metric" two dimensional grid squares. To map from latlong to UTM coordinates, we need to know where on the earth a point roughly corresponds to. The world is imagined in terms of a series of zones, marked off a bit like time zones, in vertical "bands" that extend around the world.

The bands are given numerical codes according to the [EPSG system](http://epsg.io/) that can be determined from latitude and longitude coordinates as follows:

```{r}
# Detect the UTM zone as an EPSG code
lonlat2UTMzone = function(lonlat) {
  utm = (floor((lonlat[1] + 180) / 6) %% 60) + 1
  if(lonlat[2] > 0) {
    utm + 32600
  } else{
    utm + 32700
  }
}
```

We can define a new projection string that identities the UTM CRS and an appropriate zone using the coordinates from the starting point of our route:

```{r}
# Keep track of the original proj4 string
old_crs = st_crs(geojson_sf[1,])$proj4string

# Generate a new projection in the appropriate UTM zone
crs_zone = lonlat2UTMzone(c(st_coordinates(geojson_sf[1,])[1,1],
                            st_coordinates(geojson_sf[1,])[1,2]))

new_proj4_string = st_crs(crs_zone)$proj4string
new_proj4_string
```


### Using `st_transform` for Projection Transformations

We can transform our route to the new projection using the `sf::st_transform()` function:

```{r}
# Transform the route to the UTM projection
utm_routes = st_transform(geojson_sf, crs=new_proj4_string)
```

Now let's look at our coordinates under this projection:

```{r}
utm_df = as.data.frame(st_coordinates(utm_routes[1,]))

head(utm_df)
```
We see the X and Y values have been transformed from their original latitude and longitude values into UTM coordinates in meters.

What happens if plot the coordinates now?

```{r gg-utm-demo}
g_utm = ggplot(utm_df, aes(x=X, y=Y)) + 
          geom_path() + coord_fixed() +
          theme(axis.text.x = element_text(angle = 45))
g_utm
```

Does that shape look familiar?

If we plot the three charts side by side with a vertical alignment, we see how the "geo sensitive" plot and the UTM plot roughly correspond to each other, whereas the the latlong plot is differently proportioned:

```{r three-projections}
no_labels = theme(axis.text.x = element_blank(),
                  axis.text.y = element_blank())
                    
ggpubr::ggarrange(g_sf + no_labels,
                  g_ll + no_labels,
                  g_utm + no_labels,
                  ncol=3, align='v')
```

Well, it works, but it's painful to have to go through the motions to fo it; surely there's a better way?

### Using `ggplot2::coord_sf` to Render Projections

Having the transform the coordinates from one CRS to another is a hassle; it would be so much easier if we could pass latitude and longitude coordinates into the data frame in units of degrees and let the chart map to an appropriate direction.

It so happens that we can. By setting `ggplot2::coord_sf(crs)`, we can force the chart to use an appropriate projection:

```{r gg_coord_sf}
ggplot(coords_df, aes(x=X, y=Y)) +
          geom_path() +
          coord_sf(crs=st_crs(geojson_sf[1,]))
```

There's a huge range of projections available, but these two are perhaps the most convenient due to their familiarity and widespread use.


### Exporting the Route Data As a Dataframe

For convenience, it may be useful to export the route data as a dataframe that includes both the latlong and the UTM coordinates. However, taking such a route would require creating an appropriate dataframe format for writing to a CSV file, for example, as well as means of parsing the data back in in an appropriate way.

## Alternative CRS Projections

At times, finding the correct UTM zone can be a faff. In such cases, it may be convenient to use an *Azimuthal equidistant (AEQD) projection*: `sf::st_transform(route, crs="+proj=aeqd")`.

For more discussion about selecting projections, see for example [*Geographic projections and transformations: which projection to use?* (Robin Lovelace)](https://geocompr.github.io/post/2019/crs-projections-transformations/#which-projection-to-use) and [Geographic vs projected coordinate reference systems (Python code examples)](https://www.earthdatascience.org/courses/use-data-open-source-python/intro-vector-data-python/spatial-data-vector-shapefiles/geographic-vs-projected-coordinate-reference-systems-python/).

<!--chapter:end:introducing-projections.Rmd-->

```{r cache = T, echo = F, message=F}
# 3Allow knitr to continue to execute even in the presence of errors
#knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/stage-route-annotations-")
```
# Stage Route Annotations

As well as reviewing the stage route, we may also want to annotate the route with additional information such as markers showing the location of split points or other points of interest.

We have already seen how we can add stage start and end markers at specific locations using custom markers, but how might we add markers to other locations?

## Load in the Route Data 

Let's load in our route data to give us something to work with:

```{r message=FALSE}
library(sf)

geojson_filename = 'montecarlo_2021.geojson'
geojson_sf = st_read(geojson_filename)
```

and quickly preview a map with start and end markers:

```{r message=FALSE}
library(leaflet)
# https://fontawesome.com/v4.7.0/icons/ 
start_stop_markers <- awesomeIconList(
  "start" = makeAwesomeIcon(
    icon = "play-circle",
    markerColor = "blue",
    library = "fa"
  ),
    "stop" = makeAwesomeIcon(
    icon = "stop-circle",
    markerColor = "red",
    library = "fa"
  )
)

# TO DO - we need a better way (dplyr?) to extract this data
# for each stage
stage_coords = as.data.frame(st_coordinates(geojson_sf[1, ]$geometry))

stage_start_coords = stage_coords[1, ]
stage_end_coords = stage_coords[nrow(stage_coords), ]

first_and_last = stage_coords[c(1,nrow(stage_coords)),]
first_and_last$label=c('SS1 stage start', 'SS1 stage end')
first_and_last$typ=c('start', 'stop')
first_and_last$color=c('green', 'red')

m = leaflet(geojson_sf[1,]) %>% 
  addProviderTiles("OpenTopoMap", group = "OSM") %>% 
  addPolylines(color = "red", weight = 5) %>% 
  addAwesomeMarkers(~X, ~Y,
                    icon = ~ start_stop_markers[typ],
                    label = ~ label,
                    data=first_and_last)
m
```

With a base map in place, what other information might we add?

## Adding Split Point Locations

One of the useful locations to mark on the stage are the split points. Split times are reported by WRC live timing, so it can be useful to see just where are on the stage they are recorded.

A live timing data feed from the WRC live timing service includes the distance into the stage of each split point, as the following JSON fragment taken from the feed demonstrates:

```
# https://api.wrc.com/results-api/rally-event/1695/split-times/stage-external/1701
{
  "stageId": 1701,
  "splitPoints": [
    {
      "splitPointId": 3506,
      "stageId": 1701,
      "number": 2,
      "distance": 10.99
    },
    {
      "splitPointId": 3509,
      "stageId": 1701,
      "number": 3,
      "distance": 17.5
    },
    {
      "splitPointId": 3527,
      "stageId": 1701,
      "number": 1,
      "distance": 6.46
    },
    {
      "splitPointId": 3543,
      "stageId": 1701,
      "number": 4,
      "distance": 19.1
    }
  ]
}
```

We can grab this JSON from the original URL and parse the data out:

```{r message=FALSE}
library(jsonlite)
library(dplyr)

stage_splits_url = 'https://api.wrc.com/results-api/rally-event/1695/split-times/stage-external/1701'
splits_json = fromJSON( stage_splits_url ) 

# Lets also save a local copy of that JSON data
write(toJSON(splits_json), "split_times_example.json")

splitPoints = arrange(splits_json$splitPoints, number)

# We also have access to splits_json$entrySplitPointTimes and splits_json$stageId
splitPoints
```

### Using geojson to Find the Distance Along a Route

The *turf.js* is a widely used Javascript package for working with and processing geojson data. The package has been ported to other languages, including R and Python, using similar APIs.

The [`geoops` R package](https://github.com/sckott/geoops) provides an R port of many of the functions in the `turf.js` Javascript package, so let's see how it works.

We can get the distance into stage (in km) for one of the split points from the split time JSON data:

```{r}
splits_json$splitPoints[2, 'distance']
# A distance of 17.5km
```

We can use this distance to index along the geojson object using  the `geoops:geo_along()` function. Specifically, `geo_along()` take a GeoJSON string (rather than a spatial object) and then returns the location of a point a specific distance along it, again in a GeoJSON string format:

```{r message=FALSE}
library(geojsonio)

route_as_geojson = geojsonio::geojson_json(geojson_sf[1,]$geometry)
             
gj_point_along = geoops::geo_along(route_as_geojson,
                                   17.5, units='kilometres')

gj_point_along
```

We can parse the geojson point as a simple feature using the `geojsonio::geojson_sf()` function and then plot the split time waypoint directly from that object:

```{r}
m %>% 
  addCircleMarkers(data=geojson_sf(gj_point_along),
                   radius =10,
                   stroke = FALSE, fillOpacity = 0.8)
```

### Using `rgeos::gInterpolate` to Find the Distance Along a Route 

The following provides a rather clunky workaround to finding the distance along the line from a *Spatial* object (a more streamlined approach can be found in a later chapter).

I present the recipe here as a useful (useless?!) exercise in how to come up with a recipe from basic principles when you don't really know what you're doing!

To begin with, let's reuse some of the code we used in the chapter on projections that allow us to project from the degree based latlong CRS to the meters based UTM coordinate systems: 

```{r}
# Detect the UTM zone as an EPSG code
lonlat2UTMzone = function(lonlat) {
  utm = (floor((lonlat[1] + 180) / 6) %% 60) + 1
  if(lonlat[2] > 0) {
    utm + 32600
  } else{
    utm + 32700
  }
}

# Keep track of the original proj4 string
old_crs = st_crs(geojson_sf[1,])$proj4string

# Generate a new projection in the appropriate UTM zone
crs_zone = lonlat2UTMzone(c(st_coordinates(geojson_sf[1,])[1,1],
                            st_coordinates(geojson_sf[1,])[1,2]))

new_proj4_string = st_crs(crs_zone)$proj4string

# Transform the route to the UTM projection
utm_routes = st_transform(geojson_sf, crs=new_proj4_string)

st_crs(utm_routes)$proj4string
```

Now that we are in a projection system based on meters, we can use the `rgeos::gInterpolate()` function to find a point a certain number of meters along the route. Note that the coordinates that are returned are UTM based coordinates:

```{r warning=FALSE}
# Find the distance along the route in meters
# rgeos seems to want a Spatial object?
utm_point_along = rgeos::gInterpolate(as(utm_routes[1,],'Spatial'),
                                     12500, normalized = FALSE)

utm_point_along
```

We now need to transform this point *back* to the latlong CRS:

```{r}
latlon_point = st_transform(st_as_sf(utm_point_along),
                            st_crs(geojson_sf)$proj4string)

latlon_point
```

We can add a marker to the map showing the location of the point the required distance along the line by casting the transformed point location(s) into a dataframe and extracting the desired coordinate columns:

```{r}
m = leaflet(geojson_sf[1,]) %>% 
  addProviderTiles("OpenTopoMap", group = "OSM") %>% 
  addPolylines(color = "red", weight = 5)%>% 

  addCircleMarkers(~X, ~Y,  radius =10,
                   stroke = FALSE, fillOpacity = 0.9,
                   data= as.data.frame(st_coordinates(latlon_point)))
m
```

For convenience, we can cast all the split point distances into stage as actual location points and create a simple feature containing the points:

```{r}
splitPoints
```
Create a simple function to handle the creation of a point:

```{r}
library(rgeos)

point_from_dist_along = function(route, dist){
  st_as_sf(gInterpolate(as(route,'Spatial'),
                        dist, normalized = FALSE))
}

coords_from_dist_along = function(route, dist){
  st_coordinates(point_from_dist_along(route, dist))
}

point_from_dist_along(utm_routes[1,], 1200)
coords_from_dist_along(utm_routes[1,], 1200)
```

And add the point to the dataframe:

```{r}
geometry = st_sfc(lapply(1:nrow(splitPoints),
                         function(x) st_point()))

splitPoints = arrange(splits_json$splitPoints, number)
splitPoints = st_sf(splitPoints, geometry = geometry)

splitPoints = splitPoints %>% mutate(geometry = st_geometry(point_from_dist_along(utm_routes[1,], distance))) 

splitPoints
st_coordinates(splitPoints )
```

We could also cast all the points to a multipoint:

```{r}
st_multipoint(st_coordinates(splitPoints))
```

## Parallel Routes

If we have access to multiple datasets along route, such as telemetry data sets for different cars, it may be useful to be able to plot each set on its own route line translated from the provided route.

The following example of how we might be able to achieve this is taken from [*One sided line buffers in R using rgeos*](https://andrewpwheeler.com/2015/10/08/one-sided-line-buffers-in-r-using-rgeos/) and represents a minimal proof of concept.

```{r parallel-routes-simple}
library(sp)

TwoBuf <- function(line,width,minEx){
  Buf0 <- gBuffer(line, width=minEx, capStyle="SQUARE")
  Buf1 <- gBuffer(line, width=width, capStyle="FLAT")
  return(disaggregate(gDifference(Buf1,Buf0)))
}

# Sample the first few points from a route
cc = st_coordinates(geojson_sf[1,])[1:10,]

# Create a linestring from the first few coordinates
# st_linestring expects a matrix,
# so create one with cbind on the long and lat columns
partial_route = st_linestring(cbind(x=cc[,1], y=cc[,2]))

TortBuf <- TwoBuf(line=as(partial_route,'Spatial'),
                   width=0.0001, minEx=0.00001)

plot(TortBuf, col=c('red', 'blue'))  #First object on left, second on right
```

To make this approach more useful, it would probably make sense to project into UTM coordinates and set the parameters in units of meters.

<!--chapter:end:stage-route-annotations.Rmd-->

```{r echo = T, message=F}
library(knitr)
opts_chunk$set(fig.path = "images/elevation-data-")
```
# Accessing and Working With Elevation Data Raster Files

Having access to the stage route data allows us to render its shape using  a recognisable map projection using tools such as `ggplot2()`. We can also display a route in an interactive map overlaid over familiar map tiles using `leaflet`.

Being able to plot the route on a simple 2D map gives us a good sense of how twisty and turny a route may be, and plotting it on a terrain themed tileset gives us an impression of how the elevation may vary along the route. But can we do better than that, by getting actual elevation data?

## Introducing Digital Elevation Model (DEM) Raster Images

In recent decades, international efforts have combined to produce a wide range of openly licensed and freely available topographic datasets that contain elevation data spanning the globe. Known as *digital elevation models* (DEM), the data is often published using two dimensional raster images that can be indexed and retrieved in a similar way to map tiles but where colour channels within separate image layers may used to encode elevation values, as well as other data sets.

In this chapter, we will review various ways of obtaining and downloading elevation raster data, as well as some simple ways of previewing it.

In particular, we will introduce two different techniques for downloading elevation data for specified geographical areas:

- using the `elevatr` R package to download data ;
- using the `geoviz::mapzen()` R package to download image data via [Mapzen](mapzen.com).

### What Is Raster Data?

A raster or raster image is a pixel based representation in which  each pixel represents an area on the Earth's surface. Many popular file formats, including JPEG, PNG and TIFF image formats, as well as more specialised forms.

The *spatial resolution* of the image describes the surface covered by each pixel, from coarse grained resolutions of 1km square or more to finer resolutions at the 50-100m level to detailed imaging at the sub-1 meter square level.

The *extent* of the raster describes the geographical extent covered by the image. A *coordinate reference system* (CRS) string describes the co-ordinate system and geographical projection that identifies how a grid based co-ordinate system overlaid on a globe model of the Earth is "projected" onto a two dimensional map based view of the world.

### What Are Digital Elevation Models (DEMs)?

*Digital Elevation Models* (DEM), also known as *digital terrain models* (DTM), are digital models that encode the elevation of the area on the Earth's surface they correspond to. DEMS seek to represent the elevation of the Earths surface level, rather than the elevation of surface features such as buildings or trees, which tend to be described using digital *surface* models. DEMs are typically represented using image raster files where pixel values encode elevation values rather than visual features.

Further reading:

- [*GIS Wiki: Digital Elevation Model*] (http://wiki.gis.com/wiki/index.php/Digital_Elevation_Model)
- *Introduction to Geographic Information Systems*, R. Adam Dastrup, [6.2: Raster Data Models*](https://gist.pressbooks.com/chapter/6-2/)
- *Essentials of Geographic Information Systems*, Campbell and Shin, [4.1: Raster Data Models](https://geo.libretexts.org/Bookshelves/Geography_(Physical)/Book%3A_Essentials_of_Geographic_Information_Systems_(Campbell_and_Shin)/04%3A_Data_Models_for_GIS/4.01%3A_Raster_Data_Models)
- For a review of raster image file formats, see [Raster data file format lists in GIS](https://www.igismap.com/raster-data-file-format/)
- For sources of openly available DEM data, see for example [Mapzen terrain data sources ](https://github.com/tilezen/joerd/blob/master/docs/data-sources.md

### The R `raster` Package

The [R `raster` package](https://rspatial.org/raster/pkg/1-introduction.html) provides a wide range of tools for opening, viewing, manipulating and saving raster images.

For a good introduction to raster image data in general, and working with raster images in R in particular, see the National Ecological Observatory Network (NEON) tutorial on [Raster Data in R - The Basics](https://www.neonscience.org/resources/learning-hub/tutorials/raster-data-r).

For working with distance calculations over rasters, see the [`geodist` *R* package](https://github.com/statnmap/GeoDist).

## Downloading Elevation Data

Requesting data from an elevation data service requires us to provide the area for which we want to retrieve the elevation data in terms of an identifying location and an extent.

We can look-up the latitude and longitude co-ordinates and general extent of each stage route from the stage route file, so let's start by loading in some sample stage data.

Elevation data is published by a wide variety of sources with national and international scope. National datasets are often at a higher spatial resolution (smaller grid size on the ground)

### Loading in some stage data

We can load in some example stage data from a geojson file we have downloaded  previously:

```{r}
# Load in the tidyr package to provide various utilities, such as %>%
library(tidyr)

# Load in the stage data from a geojson file
geojson_filename = 'montecarlo_2021.geojson'
geojson_sf = sf::st_read(geojson_filename)
```

From the loaded in simple features object, we can access the bounding box encompassing all the stages in the rally or the bounding box from a selected stage or stages:

```{r}
# Obtain the bounding box around the first stage
stage_bbox = sf::st_bbox(geojson_sf[1,])
```


### Obtaining relief / elevation raster data using `elevatr`

The [`elevatr`](https://www.rdocumentation.org/packages/elevatr/versions/0.3.1) package allows us to retrieve elevation rasters from various sources, including the Amazon Web Services Terrain Tiles, the Open Topography Global Datasets API, and the USGS Elevation Point Query Service.

The `raster::get_elev_raster()` functions downloads DEMs as a raster image covering one or more locations, the extent of `sp` or `sf` data object, and a zoom level.

Note that when passing `sf` or `sp` objects, a projection that uses meters is required.

If we are in the latlong projection with units of degrees, we can create a simple dataframe containing the locations of the bounding box co-ordinates:

```{r}
ex.df <- data.frame(x= c(stage_bbox[['xmin']], stage_bbox[['xmax']]), 
                    y= c(stage_bbox[['ymin']], stage_bbox[['ymax']]))
ex.df
```

and then pass that to the `elevatr::get_elev_raster()` function:

```{r message=FALSE}
library(raster)
library(elevatr)

# The zoom level, z, impacts on how long it takes to download the imagery
# z ranges from 1 to 14
# https://www.rdocumentation.org/packages/elevatr/versions/0.3.4/topics/get_elev_raster
prj_dd <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
elev_img <- get_elev_raster(ex.df, prj = prj_dd, z = 12, clip = "bbox")
#elev_img <- get_elev_raster(as(geojson_sf[1,],'Spatial'), z = 12, clip = "bbox")
elev_img
```

We can preview the raster image by plotting it:

```{r basic-raster}
raster::plot(elev_img)
```


### Plotting Rasters As `ggplot` Objects

Using the `rasterVis::gplot()` function, we can render an a raster image as a `ggplot2` object:

```{r}
library(rasterVis)

gr = gplot(elev_img) +
        geom_tile(aes(fill = value)) +
        scale_fill_gradientn(colours = rev(terrain.colors(225))) +
        coord_equal() + theme_void() + theme(legend.position = "none")

gr
```

### Interactive Raster Previews with `plainview` 

The [`plainview` R package](https://cran.r-project.org/web/packages/plainview/index.html) provides an interactive HTML viewer, much as we might use to present an interactive map, for previewing raster images. The viewer supports zooming and panning  and can also detect mouse location information. 

The `plainview::plainView()` function provides a straightforward way of rendering a raster object in the interactive viewer:

```{r message=FALSE}
library(plainview)

plainView(elev_img, legend = FALSE, verbose=FALSE)
```

*The output seems to not work properly with `bookdown`. A navigation bar appears at the top of the bookdown content frame.*

If a raster image is very large, this can provide a convenient way of reviewing it.

We can also overlay a raster image as a semi-transparent overlay on a map using the `mapview::mapview()` function:

```{r message=FALSE, warning=FALSE}
library(mapview)
mapview(elev_img)
```

### Saving the Image Raster Data to a Local File

In cases where we download the image raster into memory, rather than as an image file, we can save it out to a raster file and then load it in as a local file on future occasions, rather than having to retrieve it again from its online source.

We can save the raster image as a tif file:

```{r basic-raster-plot}
stage_tif = "stage_elevation.tif"

# elev_img is a DEM, digital elevation model
# It may be more convenient to reference it as such
dem = elev_img
 
# Write the data to an elevation data raster tif
raster::writeRaster(elev_img, stage_tif, overwrite= TRUE)

# Load the raster image back in
elev_tif <- raster::raster(stage_tif)

# Get the dimensions in pixels?
dim <- dim(elev_tif)

elev_matrix <- matrix(
      raster::extract(elev_img, raster::extent(elev_img), buffer = 1000), 
      nrow = ncol(elev_img), ncol = nrow(elev_img)
)

# Preview the raster image
plot(elev_tif)
```

### From `raster` to `terra`

The `raster` package has a long history and as such is widely encountered in examples of how to work with raster images. However, the more recent [`terr` *R* package](https://github.com/rspatial/terra) ([docs](https://rspatial.org/terra/index.html)), maintained via the `rspatial` Github organisation, looks like it may be set to challenge the `raster` package due its presumably closer integration with other `rspatial` maintained packages.

```{r terra-example, message=FALSE}
library(terra)

r <- terra::rast(stage_tif)

plot(r, main='Elevation raster via terra')
```

## Overlaying Raster Images on Leaflet Maps 

One way of checking that the raster covers the area of interest is to preview this image as a raster overlay on a leaflet map:

```{r leaflet-raster-overlay}
library(leaflet)
# Although we import the leaflet package, let's also prefix
# the functions imported from that package explicitly

pal <- leaflet::colorNumeric(c("#0C2C84", "#41B6C4", "#FFFFCC"), # span of values in palette
                    values(elev_img), #range of values
  na.color = "transparent")

leaflet() %>% 
  addProviderTiles("OpenTopoMap", group = "OSM") %>%
  addRasterImage(elev_img,
                 color=pal, 
                 opacity = 0.6) %>%
  leaflet::addLegend(values = values(elev_img),
                     pal = pal,
                     title = "Digital elevation model") %>%
  leaflet::addPolylines(color = "red",
                        weight = 5,
                        data=geojson_sf[1,])
```

## Retrieving Descriptive Information About the Raster

We can retrieve the extent of the raster image using the `raster::extent()` function:

```{r}
dem_extent = extent(dem)
dem_extent
```

Individual values can be retrieved from the `extent` class object using the `base::attr()` function:

```{r}
attr(dem_extent, 'xmin')
```

In general, the coordinate system used to represent the x and y co-ordinates uses the same units for the x and y dimension. However, a different measurement unit may be used describe the elevation. The `zscale` parameter can be used to scale the elevation (z) units relative to the base x/y units. When creating a 3D plot, setting the `zscale` value allows us to render a "true" representation of the landscape, where the elevation (z co-ordinate)  is in proportion to the x/y co-ordinates. Decreasing the zscale value increases the "spikiness" of the elevation, and allows us emphasise relief where the elevation changes are slight. Increasing the zscale value squashes the relief and flattens the rendered view.

The `geoviz::raster_zscale()` function returns the "true" z-scale value for a raster that keeps the x, y and z scale co-ordinates in proportion in a 3D rendered view:

```{r}
# Get the zscale from the DEM

auto_zscale = geoviz::raster_zscale(elev_img)
auto_zscale
```

We can use the `raster::crs()` or `raster::projection()` functions to return the co-ordinate system used by a raster, optionally returning the object as a text string:

```{r}
raster::crs(dem, asText = TRUE)
```


### Using Mapzen to Retrieve DEM raster data

We can source DEM raster data without the need for an API key from Amazon Public Datasets using MapZen.

The `geoviz::mapzen(lat, long, square_km*, width_buffer*)` function retrieves rasters based on a bottom left corner lat-long and a specified extent. The `lat` and `long` parameters take either a single WGS84 point to use as the centre for a square_km sized raster, or a vector of track points. Where a single location is provided, the `square_km` parameter takes the side length of the square to be covered by the raster. Where multiple points are provided, the `width_buffer` defines buffer distance in km around the points.

For example, we can retrieve a square raster covering the stage area by defining a square extent around a central location on the stage (the centroid of the stage data):

```{r square-raster-plot, warning=FALSE, message=FALSE}
# Set an explicit side length in km
square_km = 6

stage_centroid = sf::st_centroid(geojson_sf[1,]) %>% 
                      sf::st_geometry() %>%  
                      sf::st_coordinates()

#Make sure we pass the co-ordinates in in the correct order
dem <- geoviz::mapzen_dem(stage_centroid[1,2],
                          stage_centroid[1,1],
                          square_km=square_km)

raster::plot(dem)
```

#### Retrieving Stage Level Mapzen Elevation Data

To retrieve data for a particular stage, we might alternatively identify all the co-ordinates in a stage and then retrieve an elevation raster that at least covers the extent of all points buffered by a particular amount:

```{r mapzen-raster-plot, warning=FALSE}
# Get stage co-ordinates
stage_coords = as.data.frame(sf::st_coordinates(geojson_sf[1,]))

# Retrieve elevation raster buffered to 0.5km extent
dem2 <- geoviz::mapzen_dem(stage_coords$Y, stage_coords$X,
                           width_buffer=0.5)

raster::plot(dem2)
```

We can check we have got the co-ordinates in the correct order, and are using an appropriate buffer distance, by overplotting the raster on a leaflet map and making sure it covers the area of interest:

```{r leaflet-raster-overlay-2}
pal <- colorNumeric(c("#0C2C84", "#41B6C4", "#FFFFCC"), 
                    values(elev_img), #range of values
                    na.color = "transparent")

leaflet() %>% 
  addProviderTiles("OpenTopoMap", group = "OSM") %>%
  addRasterImage(dem,
                 color=pal, 
                 opacity = 0.6) %>%
  addLegend(values = values(dem),
            pal = pal,
            title = "Digital elevation model") %>%
  addPolylines(color = "red", weight = 5,
               data=geojson_sf[1,])
```

#### Setting a Square Side Value

If we want to retrieve the data using a square side value, we can derive it from the stage bounding box by setting the square side to the longer of the width or the height of the bounding box.

Since the square side needs to be in meters, we need to either retrieve the bounding box from a projection where the units are meters, or, for the likes of the WGS84 / latlong projection where the units are in degrees, use a function that can determine the distance in meters rather than degrees.

In the first case, if we know the UTM zone for our location of interest, we can transform the stage co-ordinates to the UTM projection and get the bounding box in meters:

```{r}
utm_proj_string = "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs"

stage_bbox = sf::st_bbox(sf::st_transform(geojson_sf[1,],
                                          crs=utm_proj_string))

stage_bbox
```

We can then calculate the square side as the longer of the bounding box sides:

```{r}
stage_bbox[['xmax']] -  stage_bbox[['xmin']]
stage_bbox[['ymax']] -  stage_bbox[['ymin']]
```

In the second case, we have the bounding box in degrees:

```{r}
sf::st_bbox(geojson_sf[1,])
```

To simplify things, let's create a function to get the corners:

```{r}

get_corners = function(stage_bbox) {
  
  bottom_left = cbind(stage_bbox[['xmin']], stage_bbox[['ymin']])
  top_left = cbind(stage_bbox[['xmin']], stage_bbox[['ymax']] )
  bottom_right = cbind(stage_bbox[['xmax']], stage_bbox[['ymin']] )
  
  rbind(bottom_left, top_left, bottom_right)
}
```

Return the corners:

```{r}
corners = get_corners(sf::st_bbox(geojson_sf[1,]))

bottom_left = corners[1,]
top_left = corners[2,]
bottom_right = corners[3,]
```

To calculate the distance in meters, rather than degrees, we can use a quick Haversine distance function such as `geosphere::distHaversine()` to look up the distance as a great circle distance on a spherical representation of the Earth. This is likely to be "good enough" for short distances:

```{r}
geosphere::distHaversine(bottom_left, top_left) # vertical side
geosphere::distHaversine(bottom_left, bottom_right) # horizontal side
```

Alternatively, we can use the more accurate, but more computationally intensive, `geosphere::distVincentyEllipsoid()` Vincenty distance calculation on an ellipsoid representation of the Earth:

```{r}
a = 6378137 # Equatorial axis of ellipsoid
b = 6356752.3142 # Polar axis of ellipsoid
f = 1/298.257223563 # Inverse flattening of ellipsoid

geosphere::distVincentyEllipsoid(bottom_left, top_left,
                                 a=a, b=b, f=f)
geosphere::distVincentyEllipsoid(bottom_left, bottom_right,
                         a=a, b=b, f=f)
```

Distances in meters can also be returned by calling the`sp::spDists()` or  `sp::spDistsN1()` function:

```{r}
# Calculate the length of each side as the distance between two points
# The spDistsN1() function takes a matrix of points and a comparison point
# and then returns the distance from each point in the matrix
# to the comparison point
# great circle on WGS84 ellipsoid) 

sp::spDistsN1(matrix(rbind(bottom_right, top_left), nrow=2),
              bottom_left, longlat=TRUE)
```

One thing we notice from all these techniques is that they give slightly different values for the distance measures. Whilst this doesn't create too many problems for the current use cases, if we demand accuracy then it may be problematic. Either I'm doing something wrong, or you need to be really sure what calculation method is being applied and what parameter values (eg for the Earth ellipsoid) are being used.

### Additional Elevation Data Downloading Tools

Additional tools for download elevation data can be found here:

- [Interline PlanetUtils](https://github.com/interline-io/planetutils#elevation_tile_download): Dockerised tools for downloading and merging GeoTIFF elevation rasters.

## Manipulating Raster Images

One of the more useful techniques for working with raster images is the ability to add a buffer area around the raster by padding the raster margins. 

One way of adding a buffer is to redefine the raster extent using the `raster::extent()` function:

```{r raster-margins-extend-plot}
e0=extent(elev_img)
# Top/bottom and left/right side 
#raster::plot(extend(elev_img, c(100,20), value = 0))
e2 = extent(attr(e0,'xmin')-0.1, attr(e0,'xmax')+0.05,
            attr(e0,'ymin'), attr(e0,'ymax')+0.1)
#attr(extent(elev_img),'xmin') = attr(extent(elev_img),'xmin') -0.5
raster::plot(extend(elev_img, e2, value = 0))
```

Changing the extent requires us to know the original extent and then extend is *using the appropriate coordinate system*.

A simpler approach is to use the following `modify_raster_margins()` function retrieved from the `spatial.tools` package that appears to have been removed from CRAN. This function lets you add a specified number of rows or columns of padding, as appropriate, to each dimension:

```{r}
# From spatial.tools - no longer on CRAN?
#' Add/subtract rows and columns from Raster*
#' 
#' 
#' @param x A Raster* object.
#' @param extent_delta Numeric vector. How many rows/columns to add/subtract to the left,right,top, and bottom of an image.  Default is c(0,0,0,0) (no change).
#' @param value Value to fill in when adding rows/columns.
#' @return A Raster* object.
#' @author Jonathan A. Greenberg
#' @details A quick way to add/subtract margins from a Raster* object.  extent_delta is a four-element integer vector that 
#' describes how many rows/columns to add to the (left,right,top,bottom) of the image (in that order).  Negative values remove rows,
#' positive values add rows.
#' 
#' @examples
#' tahoe_highrez <- brick(system.file("external/tahoe_highrez.tif", package="spatial.tools"))
#' dim(tahoe_highrez)
#' # Remove one row and column from the top, bottom, left, and right:
#' tahoe_highrez_cropped <- modify_raster_margins(x=tahoe_highrez,extent_delta=c(-1,-1,-1,-1))
#' dim(tahoe_highrez_cropped)
#' # Add two rows to the top and left of the raster, and fill with the value 100.
#' tahoe_highrez_expand <- modify_raster_margins(x=tahoe_highrez,extent_delta=c(2,0,2,0),value=100)
#' dim(tahoe_highrez_expand)
#' @import raster
#' @export

modify_raster_margins <- function(x,extent_delta=c(0,0,0,0),value=NA)
{
	x_extents <- extent(x)
	res_x <- res(x)
	
	x_modified <- x
	
	if(any(extent_delta < 0))
	{
		# Need to crop
		# ul:
		ul_mod <- extent_delta[c(1,3)] * res_x
		ul_mod[ul_mod > 0] <- 0
		lr_mod <- extent_delta[c(2,4)] * res_x
		lr_mod[lr_mod > 0] <- 0
	# This works fine, but for some reason CRAN doesn't like it:	
	#	crop_extent <- as.vector(x_extents)
		crop_extent <- c(x_extents@xmin,x_extents@xmax,x_extents@ymin,x_extents@ymax)
		crop_extent[c(1,3)] <- crop_extent[c(1,3)] - ul_mod
		crop_extent[c(2,4)] <- crop_extent[c(2,4)] + lr_mod
		
		x_modified <- crop(x_modified,crop_extent)
	}
	
	if(any(extent_delta > 0))
	{
		# Need to crop
		# ul:
		ul_mod <- extent_delta[c(1,3)] * res_x
		ul_mod[ul_mod < 0] <- 0
		lr_mod <- extent_delta[c(2,4)] * res_x
		lr_mod[lr_mod < 0] <- 0
#		Again, a hack for CRAN?		
#		extend_extent <- as.vector(x_extents)
		extend_extent <- c(x_extents@xmin,x_extents@xmax,x_extents@ymin,x_extents@ymax)
		extend_extent[c(1,3)] <- extend_extent[c(1,3)] - ul_mod
		extend_extent[c(2,4)] <- extend_extent[c(2,4)] + lr_mod
		
		x_modified <- extend(x_modified,extend_extent,value=value)
	}
	
	return(x_modified)
}
```

We can then add margins around a raster image with a specified pixel extent:

```{r raster-margins-modify-plot}
elev_img_margin = modify_raster_margins(elev_img, c(100,100,25,200), 5000)
plot(elev_img_margin)
```


## Ridge maps

If you're an aficionado of fantasy novels, you're probably familiar with ridge maps, woodcut style views of mountainous landscapes that provide the setting for many a heroic tale or adventure.

```{r raster-ridgemap, message=FALSE, warning=FALSE}
library(ggplot2)

# eg via https://udurrani.netlify.app/posts/2020-12-25-elevation-maps-in-r/
library(ggridges)

need_raster_df = data.frame(sampleRegular(elev_img, 10000, xy=TRUE))
names(need_raster_df) = c('x', 'y', 'elevation')
ggr = ggplot() 

ggr = ggr +
      geom_density_ridges(data = need_raster_df,
                          aes(x, y, 
                              group=y,
                              height = elevation),
                          stat = "identity", scale=100,
                          fill="black", color="white") +
      theme_void() + 
      theme(panel.background = element_rect(fill = "black"),
            plot.background = element_rect(fill = "black"))

ggr
```

By default we are taking lines across the raster matrix, essentially giving us a view from the south. If we rotate matrix 90 degrees by finding its transpose, we can essentially view the scene from the west.

## Further Information

We will explore various ways of working with elevation raster images in more detail in a later chapter.

It is also worth noting that additional tools for working with raster images may be provided in other R packages. For example, the [`rasterVis`](https://oscarperpinan.github.io/rastervis/) package provides additional tools for visualising data over 2D rasters although the tools used in that package are not of immediate relevance here.

<!--chapter:end:elevation-data.Rmd-->

```{r cache = T, echo = F, message=F}
# 15Allow knitr to continue to execute even in the presence of errors
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/terrain-features-raster-")
```
# Determining Terrain Features from Raster Data

Based on the elevation data associated with a raster image, we can depict the raster image in various ways. For example, we can select different colour plots to colour the tiles, as well as adding contour lines.

## Load in Base Data 

As ever, let's load in our stage data:

```{r}
geojson_filename = 'montecarlo_2021.geojson'
geojson_sf = sf::st_read(geojson_filename)
```

And also load in the elevation data raster:

```{r message=FALSE, warning=FALSE}
library(raster)
library(rayshader)

# Previously downloaded TIF digital elevation model (DEM) file
stage_tif = "stage_elevation.tif"

# Load in the previously saved image raster
elev_img = raster(stage_tif)
auto_zscale = geoviz::raster_zscale(elev_img)

# Note we can pass in a file name or a raster object
elmat = raster_to_matrix(stage_tif)
```

## Rendering Terrain Over Raster Images

By default, a plot of a raster image will render a colour mapping sensitive to elevation:

```{r elev-preview}
plot(elev_img, col = terrain.colors(25), axes=FALSE)
```

As well as height / elevation information, we can also extract additional information from the raster image using the `raster::terrain()` function. This function can compute various terrain characteristics from a raster with elevation data, ideally in a projected (planar) raster data image with units in meters.

Terrain features include *aspect*, *slope* and *flowdir* (the direction of water flow as determined by the direction in which the greatest drop in elevation (or smallest rise) is to be found at any given point). *TPI* (Topographic Position Index, *"the difference between the value of a cell and the mean value of its 8 surrounding cells"), *TRI* (Terrain Ruggedness Index, *"the mean of the absolute differences between the value of a cell and the value of its 8 surrounding cells"*) and *roughness* (*"the difference in elevation between the maximum and the minimum value of a cell and its 8 surrounding cells"*) terrain measures are also supported:

```{r terrain-preview}
plot(terrain(elev_img, "TRI"),
     # Remove legends, bounding box etc
      bty="n", box=FALSE, axes=F, frame.plot=F, legend=F)
```

To give the appearance of relief as highlighted by shadow, we can shade the terrain using the the `raster::hillshade()` function with slope and aspect values determined by the `raster::`terrain()` function:

```{r hill-preview}
hill_shadows = hillShade(slope = terrain(elev_img, "slope"),
                         aspect = terrain(elev_img, "aspect"),
                         # azimuthal direction of sun in degrees:
                         angle = 45, 
                         add=TRUE)
plot(hill_shadows)
```


## Adding Contours to `raster` Images

Consider again our original raster image, plotted here using a "terrain style" colour palette:

```{r terrain-preview2}
plot(elev_img, col = terrain.colors(25), axes=FALSE)
```

We can use the `raster::rasterToContour` function to generate a set of contour lines over the raster:

```{r terrain-contour}
# Plot the original raster image
plot(elev_img, col = terrain.colors(25), axes=FALSE)

# Add a contour plot over the raster image
plot (rasterToContour(elev_img), add=TRUE)

#nlevels - number of contour levels desired iff levels is not supplied.
#levels - numeric vector of levels at which to draw contour lines.
```

We have a certain amount of control over the contours that are plotted, notably through the following two parameters that can be passed through the `rasterToContour()` function to the `grDevices::contourLines` function [[docs](https://www.rdocumentation.org/packages/grDevices/versions/3.0.3/topics/contourLines)] that actually generates the contour lines:

- `nlevels`: the number of contour levels desired iff `levels` is not supplied;
- `levels`: a numeric vector of levels at which to draw the contour lines.

So for example, let's set the contour lines to appear at elevations of 1000m and 1500m:

```{r terrain-raster-contour}
# Plot the original raster image
plot(elev_img, axes=FALSE)

# Add a contour plot over the raster image
plot(rasterToContour(elev_img, levels=c(1000, 1500)), add=TRUE)
```
Alternatively, we may choose to let "the algorithm" decide the levels whilst we still determine how many contour levels there are to be:

```{r terrain-raster-contour2}
# Plot the original raster image
plot(elev_img, axes=FALSE)

# Add a contour plot over the raster image
plot (rasterToContour(elev_img, nlevels=4),
      add=TRUE)
```

Another `raster` package function, `raster::contour`, produces a contour plot with labeled contour values:

```{r contour-plot}
contour(elev_img)
```

Again, we can overplot this on the original raster image, optionally setting the contour line color:

```{r contour-plot2}
plot(elev_img)

contour(elev_img, add=TRUE, col='navyblue')
```


<!--chapter:end:terrain-features-from-raster.Rmd-->

```{r cache = T, echo = F, message=F}
# 21Allow knitr to continue to execute even in the presence of errors
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/rayshader-2d-")
```

# (PART) Introducing `rayshader` {-}

# Using `rayshader` to Render 2D Elevation and Shade Views

The `rayshader` package provides a range of tools for visualising elevation rasters, and overlays placed on top of them, in both two-dimensional and three-dimensional views.

In this chapter, we will learn how to view rasters in a two-dimensional view using `rayshader`, leaving it to later chapters to show how to overlay additional layers and render three dimensional models.

## Load in Base Data 

As ever, let's load in our stage data:

```{r message=F, warning=F}
geojson_filename = 'montecarlo_2021.geojson'
geojson_sf = sf::st_read(geojson_filename)
stage_bbox = sf::st_bbox(geojson_sf)
```


## Rendering imagery from the DEM raster

As well as overlaying the elevation model raster on a leaflet map, we can also render topographic models from the data using the `raytracer` package.

The packages works with a matrix of raster values, so having saved the download raster to a tif file, let's load the data back in from that raster image tif file (to demonstrate round tripping!), and then convert the data to a matrix using the` # And convert it to a matrix using the `rayshader::raster_to_matrix()` function:

```{r}
library(rayshader)
library(raster)

# Previously downloaded TIF digital elevation model (DEM) file
stage_tif = "stage_elevation.tif"

# Load in the previously saved image raster
elev_img = raster(stage_tif)

# Note we can pass in a file name or a raster object
# rayshader::raster_to_matrix
elmat = raster_to_matrix(stage_tif) 
```

We can now render a raytraced 2D image using that data with the `rayshader` package:

```{r desert-2d}
#We use another one of rayshader's built-in textures:
elmat %>%
  sphere_shade(texture = "desert", progbar=FALSE) %>%
  plot_map()
```

Alternatively, save to a png image file:

```{r}
image_fn = 'demo_2d_stage.png'

#We use another one of rayshader's built-in textures:
elmat %>%
  sphere_shade(texture = "desert", progbar=FALSE) %>%
  save_png(filename=image_fn)
```

And then view the image file via markdown:

```{r demo-stage-image}
knitr::include_graphics(image_fn)
```


## Roundtripping `rayshader` Rasters and Matrices

*This section is purely academic / artistic research into the medium as I try to make sense of the relationship between the original raster image and the `rayshader` elevation matrix.*

The `rayshader` plotting functions take an input elevation matrix that is processed by the application of various shading functions, such as `rayshader::sphere_shade()` as well as functions that add a variety of other overlays onto the image, such as terrain maps or route lines.

The `rayshader::sphere_shade(heightmap)` function takes a *heightmap* in the form of an elevation matrix and calculates a surface color map in the form of a *hillshade* object, an RGB array of hillshaded texture mappings. From the documentation:

> `sphere_shade` calculates a color for each point on the surface using the surface normals and hemispherical UV mapping. This uses either a texture map provided by the user (as an RGB array), or a built-in color texture. It returns an RGB array of hillshaded texture mappings.

The *hillshade* object returned in this case is thus an image that can represent terrain colouring.

The `rayshader:ray_shade(heightmap)` function also takes a *heightmap* argument and returns a raytraced shadow map in the form of a simpler greyscale *hillshade* object:

> `ray_shade` calculates shadow map for a elevation matrix by propogating rays from each matrix point to the light source(s), lowering the brightness at each point for each ray that intersects the surface.

The `rayshader::plot_map(hillshade)` function takes a `hillshade` object as the only required input and then renders it as a visual 2 dimensional image:

> `hillshade`:	a three-dimensional RGB array or 2D array of shadow intensities.

We can additionally add shadows to the *hillshade* object
The `rayshader::add_shadow(hillshade, shadowmap)` function takes an additional *shadowmap* argument:

> `shadowmap`: a two dimensional array that indicates the intensity of the shadow at that point. 0 is full darkness, 1 is full light.

If we inspect the dimensions of this associated matrices we see that not only does the RGB array have three values associated with each location (the red, green and blue values) but the matrix is also rotated compared to the input matrix. The `ray_shade` array, with just two dimensions, has values limited to the range 0..1.

```{r}
# Dimensions of heightmap elevation matrix
"heightmap:"
heightmap = elmat
class(heightmap)
range(heightmap)
dim(heightmap)

"hillshade (sphere):"
hillshade = sphere_shade(heightmap, progbar=FALSE)
class(hillshade)
dim(hillshade)

"hillshade (ray):"
hillshade2 = ray_shade(heightmap, progbar=FALSE)
class(hillshade)
range(hillshade2)
dim(hillshade2)
```

So let's see what each of those elements looks like and how we map between them.

To begin with, we can view the elevation image raster:

```{r sketch-elev_img-raster}
plot(elev_img)
```

Let's now create the `heightmap` matrix:

```{r}
# Render the 'rayshader' scene 

# for some reason, we do a rotate rayshader
heightmap = matrix(
  raster::extract(elev_img, raster::extent(elev_img), method = 'bilinear'),
  nrow = ncol(elev_img),
  ncol = nrow(elev_img)
)
```

And render the matrix as a simple greyscale raster:

```{r sketch-raster-heightmap}
plot(raster(heightmap))
```
We note that this is rotated compared to the original elevation raster image. 


In passing, let's note the following function from the `rayshader` repository also the means of flipping the matrix from left to right to right to left orientation:

```{r}
#https://github.com/tylermorganwall/rayshader/blob/master/R/flipfunctions.R
fliplr = function(x) {
  if(length(dim(x)) == 2) {
    x[,ncol(x):1]
  } else {
    x[,ncol(x):1,]
  }
}
```

We can find the transpose of the heightmap matrix to reorient it in accordance with the original raster image:

```{r sketch-raster-heightmap-flip}
# Transpose the matrix, then generate the raster
heightmap_raster  = raster( t(heightmap) )

plot(heightmap_raster)
```

If required, we can render the image as a greyscale image:

```{r sketch-raster-heightmap-flip-bw}
plot(heightmap_raster,
     col = grey.colors(10, start=0, end=1) )
```

One thing we notice about these array based raster plots is that they do not retain the original projection since they were created from simple matrices. To fully describe the raster, we need to add an appropriate extent and CRS projection. We can get the details of these from the original raster image:

```{r}
extent(elev_img)
crs(elev_img)
```

We can then assign these properties to our matrix originated raster:

```{r sketch-height-raster}
extent(heightmap_raster) = extent(elev_img)
crs(heightmap_raster) = crs(elev_img)

plot(heightmap_raster)
```

If we now look at the `plot_map()` function, recall how we can use it to render terrain features created via the application of the `sphere_shade()` function:

```{r sketch-shade}
heightmap %>%
  sphere_shade(texture = "desert", progbar=FALSE) %>%
  plot_map()
```

We can also view a greyscale shadow layer:

```{r sketch-rayshade-array}
ray_shade_array = ray_shade(heightmap, progbar=FALSE)

ray_shade_array %>% 
  plot_map()
```
If we want to get the shadow layer as a raster, we can do so using the following function that pulls together some of the previous steps and adds an additional left-right flip :

```{r}
rasterify_rayshade = function(rayshade, original_raster){
  # Transpose and flip the shade matrix
  reorient_rayshade = fliplr(t( rayshade ))
  # Generate the raster
  rayshade_raster  = raster( reorient_rayshade )
  # Set the extent
  extent(rayshade_raster) = extent(original_raster)
  # Set the CRS
  crs(rayshade_raster) = crs(original_raster)
  
  rayshade_raster
}

ray_shade_raster = rasterify_rayshade(ray_shade_array, elev_img)
ray_shade_raster
```

We can plot the raster using `plot_map()`:

```{r sketch-rayshade-raster-map}
# TO DO - BROKEN?
#plot_map(ray_shade_raster)
```

Or plot the raster naively using a simple base `plot()`:

```{r sketch-rayshade-rasterified}
plot(ray_shade_raster)
```

Or with a grey scale mapping:

```{r sketch-rayshade-rasterified-bw}
plot(ray_shade_raster,
     col = grey.colors(10, start=0, end=1))
```

Let's save that shadow raster to a file:

```{r}
shadow_tif = "stage_shadow.tif"
  
writeRaster(ray_shade_raster, shadow_tif, overwrite= TRUE)
```

We could then use this raster as a "shade raster" to identify shade levels at particular time and date in the same way we can use the elevation raster to identify elevation levels.

<!--chapter:end:rayshader-2d.Rmd-->

```{r cache = T, echo = F, message=F}
# 13Allow knitr to continue to execute even in the presence of errors
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/rayshader-2d-overlays-")
options(rgl.useNULL = TRUE,
        rgl.printRglwidget = TRUE)
```
# Overlaying 2D `rayshader` Maps

In this chapter, we will explore in more detail how we can add overlays to `rayshader` two-dimensional maps such as water feature overlays, map tiles or stage routes.

## Load in Base Data 

As ever, let's load in our stage data:

```{r}
geojson_filename = 'montecarlo_2021.geojson'
geojson_sf = sf::st_read(geojson_filename)
```

And also load in the elevation data raster:

```{r raster-preview, message=FALSE}
library(raster)
library(rayshader)

# Previously downloaded TIF digital elevation model (DEM) file
stage_tif = "stage_elevation.tif"

# Load in the previously saved image raster
elev_img = raster(stage_tif)

# Note we can pass in a file name or a raster object
elmat = raster_to_matrix(stage_tif)
```

## Adding overlays

The `rayshader` package includes various tools for styling the rendering of the 2d image.



### Adding Shadows to `rayshader` Maps

It can often be convenient to construct shadow layers for a particular `rayshader` map that we can add to the rendering as required:

```{r}
# Add shade
raymat <- ray_shade(elmat, zscale = auto_zscale, lambert = TRUE)
# And "ambient occlusion shadow"
ambmat <- ambient_shade(elmat, zscale = auto_zscale)
```

The shading functions accept `sunaltitude` and `sunangle` paramters to specify the sun / light source position. The `suncalc` *R* package can be used to determine sun altitude and and angle settings for a particular date and time at a specified location.

We can also create a composite shadow layer constructed from several shadow operators piped together:

```{r}
# More shadow style from:
# https://www.tylermw.com/adding-open-street-map-data-to-rayshader-maps-in-r/
                      
# We can build up layers that can be generated once then added
# as overlays to construct views from basic parts
shadow_layer = height_shade(elmat) %>% 
  add_overlay(sphere_shade(elmat, texture = "desert", 
                           zscale=auto_zscale, colorintensity = 5),
              alphalayer=0.5) %>%
  add_shadow(lamb_shade(elmat, zscale = auto_zscale),0) %>%
  add_shadow(texture_shade(elmat,detail=8/10,contrast=9,brightness = 11), 0.1)
```

The layers can be added to the `rayshader` map in the normal way:

```{r shadows-preview}
# Add water
watermap <- detect_water(elmat, zscale = 8)

demo_map = elmat %>%
              add_overlay(shadow_layer)  %>% 
              add_water(watermap, color = "desert")

demo_map %>%
  plot_map()
```

#### Retrieving Shadow Data Along a Route

If we can access just the shadow layer data, one interesting possibility is that we could produced a "shadow depth" profile of a route identifying which bit are in shadow at a particular time and date.

### Adding Water Features

We can detect water (and even modify the height of the water to model raising water levels) to create a layer that we can later add to the rendered map.

```{r meassage=FALSE}
# Add water
watermap <- detect_water(elmat, zscale = 8)
```

Let's add that layer to the 2d map:

```{r water-map, message=FALSE}
# Texture palettes:
# `imhof1`,`imhof2`,`imhof3`,`imhof4`,`bw`,`desert`, and `unicorn`
elmat %>%
  #sphere_shade(texture = "imhof1") %>%
  # Optionally set sun angle
  sphere_shade(sunangle = -45, texture = "imhof1") %>%
  add_water(watermap, color = "bw") %>%
  plot_map()
```

### Overlaying Map Tiles

We can also add tiles as an overlay.

For example, the `geoviz` package provides a way for us to retrieve popular map tilesets and then overlay them onto the `rayshader` map.

Let's grab some tiles covering the extent of our original raster image and create overlays from them:

```{r warning=FALSE}
# via https://github.com/neilcharles/geoviz
library(geoviz)

# stamen: toner, watercolor, terrain
overlay_image_watercolor <-
  slippy_overlay(elev_img, 
                 image_source = "stamen",
                 image_type = "watercolor",
                 png_opacity = 0.5)

overlay_image_tonerlite <-
  slippy_overlay(elev_img, 
                 image_source = "stamen",
                 image_type = "toner",
                 png_opacity = 0.5)

overlay_image_terrain <-
  slippy_overlay(elev_img, 
                 image_source = "stamen",
                 image_type = "terrain",
                 png_opacity = 0.9)
```

We can now overlay a tileset onto the rendered map.

In the following example, notice how I have further separated out the map creation phase from the map plotting phase:

```{r overlay-map, message=FALSE}
scene <- elmat %>%
  sphere_shade(sunangle = 270, texture = "desert") %>% 
  add_overlay(overlay_image_watercolor)

scene  %>%
  plot_map()
```

#### Setting Elevation Sensitive Tile Transparancy

We can also specify different elevations at which we want to apply an overlay as a transparency.

For example, we can turn mountainous parts of the overlay transparent, showing the tiles overlaid on the lower altitude areas but not on the higher regions, which in this case are rendered with a black and white texture:

```{r overlay-toner, message=FALSE}
overlay_image_tonerlite_low_alt <-
  elevation_transparency(overlay_image_terrain,
                        elev_img,
                        pct_alt_high = 0.5,
                        alpha_max = 0.9)

scene <- elmat %>%
  sphere_shade(sunangle = 270, texture = "bw") %>% 
  add_overlay(overlay_image_tonerlite_low_alt) %>%
  plot_map()
```


## Adding a Stage Route Layer

When adding overlays, we ofter need to specify the extent of the area covered by the overlay.

For our stage route, we can take the extent directly from the geojson loaded data:

```{r message=FALSE}
library(sf)

extent(st_bbox(geojson_sf[1,]))
```

We can then create a route layer as a line overlay:

```{r}
yellow_route = generate_line_overlay(geojson_sf[1,],
                                    extent = extent(geojson_sf[1,]),
                                    heightmap = elmat,
                                    linewidth = 5, color="yellow")
```

We can add the line overlay to our map to show the path followed by the stage route:

```{r overlay-yellow, message=FALSE}
mapped_route_yellow = elmat %>%
  sphere_shade(sunangle = -45, texture = "bw") %>%
  #add_water(watermap, color = "bw") %>%
  add_overlay(yellow_route) 

mapped_route_yellow %>%
  plot_map()
```

*The `geoviz::add_gps_to_rayshader()` can also add a route to a `rayshader` model from longitude, latitude and elevation vectors.*


### Buffering the Stage Route View

One problem with that view is that the route extent borders on the edge of the rendered image. It would be easier to see the route if the extent of the image was increased to provide a bordered area around the route.

We can create a "buffered boundary box" around the stage extent as follows:

```{r  message=FALSE, warning=FALSE}
library(spatialEco)

bb_sp = SpatialPoints(extent(geojson_sf[1,]))
proj4string(bb_sp) <- st_crs(geojson_sf[1,])$proj4string

# Create a new, buffered region
stage_bbox_buffered = st_bbox(geo.buffer(x=bb_sp, r=500))
stage_bbox_buffered
```

We can then use those extended bounds to retrieve a buffered elevation raster image:

```{r}
ex.df2 <- data.frame(x= c(stage_bbox_buffered[['xmin']],
                          stage_bbox_buffered[['xmax']]), 
                    y= c(stage_bbox_buffered[['ymin']],
                         stage_bbox_buffered[['ymax']]))

library(elevatr)

# The zoom level, z, impacts on how long it takes to download the imagery
# z ranges from 1 to 14
# https://www.rdocumentation.org/packages/elevatr/versions/0.3.4/topics/get_elev_raster
prj_dd <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
elev_img2 <- get_elev_raster(ex.df2, prj = prj_dd, z = 12, clip = "bbox")

# Save out the buffered image
stage_tif = "buffered_stage_elevation.tif"
# Write the data to an elevation data raster tif
raster::writeRaster(elev_img2, stage_tif, overwrite= TRUE)

elmat_buffered =  raster_to_matrix(elev_img2)
```

To create a buffered yellow route, we generate the line overlay with an extend matching that of the buffered image and the heightmap associated with that image:

```{r}
yellow_route_b = generate_line_overlay(geojson_sf[1,],
                                       extent = extent(elev_img2),
                                       heightmap = elmat_buffered,
                                       linewidth = 5, color="yellow")


```

Plotting the buffered route in the buffered image now provides us with a marginal border around the edge of the route:

```{r mapped-yellow}
mapped_route_yellow = elmat_buffered %>%
  sphere_shade(sunangle = -45, texture = "bw") %>%
  add_overlay(yellow_route_b)  %>%
  plot_map()
```

## Modeling Increased Water Levels

The `rayshader::plot_3d()` function takes a *water_depth* parameter that allows us to model changing water levels. This is not really relevant to rally route analysis and visualisation, although it may be of interest in other contexts (eg raising sea levels, historical views over land that as since been reclaimed from the sea, dam bursts, etc.)

<!--chapter:end:rayshader-2d-overlays.Rmd-->

```{r cache = T, echo = F, message=F}
# 16Allow knitr to continue to execute even in the presence of errors
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/annotating-rayshader-maps-")
```
# Annotating `rayshader` maps

As well as adding computed shading, contour and water overlays to maps, we can also enrich `rayshader` maps with additional annotations such as title information, or, of

## Load in Base Data 

As ever, let's load in our stage data and the elevation raster and create a demo map:

```{r message=FALSE}
geojson_filename = 'montecarlo_2021.geojson'
geojson_sf = sf::st_read(geojson_filename)

library(raster)
library(rayshader)

# Previously downloaded TIF digital elevation model (DEM) file
stage_tif = "stage_elevation.tif"

# Load in the previously saved image raster
elev_img = raster(stage_tif)

# Note we can pass in a file name or a raster object
elmat = raster_to_matrix(stage_tif)

demo_map = elmat %>%
              sphere_shade(texture = "desert")

```

## Adding a Title to a Map

We can add a title to the image as a layer using the `rayimage::add_title()` function [[docs](https://www.rayimage.dev/reference/add_title.html)].

Currently, the title is overlaid on top of the image, so we would need to add a buffer to account for the area taken up by the label if we didn't want to occlude anything in the image by the title. *(Can we calculate how much vertical padding is required?)*

```{r demo-title}
demo_map %>%
  rayimage::add_title("Stage Map", title_size = 20, 
                      title_bar_color = "red",
                      title_bar_alpha=0.8,
                      title_color="white",
                      title_offset = c(120,12), #offset from top left
                      title_style='italic',
                      #title_position='south', # But doesn't relocate bar?
                      ) %>%
  plot_map()
```

Another way of using this feature might be to set the transparency level and show stage results, or example, overlaid on the stage map whilst also seeing the map below.

*It would be useful if we could set the width and location of the title and title_bar [[issue](https://github.com/tylermorganwall/rayimage/issues/3)].*

The title and title bar can also be added (with similar arguments as to `rayimage::add_title()`) via the `plot_map()` function:

```{r demo-title2}
demo_map %>%
  plot_map(title_text='Stage Map',
           title_size = 20,
           title_bar_color = "red",
           title_bar_alpha=0.8,
           title_color="white",
           title_offset = c(120,12), #offset from top left
           title_style='italic',
           #title_position='south', # But doesn't relocate bar?)
  )
```


## Adding Contours to `rayshader` Stage Maps

We have already seen how we can add contours to a raster image. A contour layer can also be created using the `rayshader::generate_contour_overlay()` function:

```{r}
contour_color = "#ffffff" #"#7d4911"

contours_layer = generate_contour_overlay(elmat, color = contour_color, 
                                       linewidth = 1, 
                                       levels=seq(min(elmat),
                                                  max(elmat),
                                                  by=20))
# Increasing the by argument separates out lines;
# This may be important for seeing steep inclines
```

We can then add the overlay in the normal way:

```{r demo-contours}
contoured_map = demo_map %>% 
                  add_overlay(contours_layer,
                              alphalayer = 0.9)

contoured_map %>%  
   plot_map()
```


## Overlaying Image Tiles

As well as creating out own shaded terrain over the raster, we can also overlay tiles retrieved from a 2D map tile server:

```{r demo-overlay, message=FALSE, warning=FALSE}
overlay_image_terrain <-
  geoviz::slippy_overlay(elev_img, 
                 image_source = "stamen",
                 image_type = "terrain",
                 png_opacity = 0.9)

demo_map %>% 
  add_overlay(overlay_image_terrain) %>%
  plot_map()
```


## Plotting Route Layers on `rayshader` Maps

As well as previewing the OSM retrieved roads within the bounding box area of a stage route and the stage routes themselves using simple a `ggplot2` view, we can also render roads and stage routes as layers on a `rayshader` map.

Let's start by creating a line overlay containing the roads in the rendered area:

```{r message=FALSE}
library(osmdata)

stage_osm  = opq(sf::st_bbox(geojson_sf[1,])) %>% 
  add_osm_feature("highway") %>% 
  osmdata_sf()

stage_lines = stage_osm$osm_lines

stage_roads = stage_lines[stage_lines$highway %in% c("unclassified", "secondary", "tertiary", "residential", "service"), ] 


roads_layer = generate_line_overlay(stage_roads,
                                    extent = extent(elev_img),
                                    color="yellow",
                                    heightmap = elmat)
```

We can also create a layer that identifies the stage route, colouring it and setting the line width as required to make it stand out in the rendered view.

In the following example, we create a red coloured stage route layer:

```{r}
red_route = generate_line_overlay(geojson_sf[1,],
                                    extent = extent(elev_img),
                                    heightmap = elmat,
                                    linewidth = 5, color="red")
```

We can now add the roads and stage overlays to our map:

```{r demo-route}
demo_map %>%
  add_overlay(roads_layer)  %>%
  add_overlay(red_route) %>%
  plot_map()
```

This may not look so interesting in a 2D view, but as you will seem it does provide a way of bringing the tile to life when we look at in as an interactive 3D view of 3D video view...

<!--chapter:end:annotating-rayshader-maps.Rmd-->

```{r cache=T, echo = F, message=F}
library(knitr)
opts_chunk$set(fig.path = "images/pennyred-")
```
# An Aside - The Penny Red {-}

Although our main focus in using `rayshader`'s 3D plotting capabilities will be to render 3D interactive maps, it's worth bearing in mind that `rayshader` can be used as a general purpose 3D visualisation tool.

So before we start rendering 3D maps, and before we are tempted to think that maps are the only thing we can plot with `rayshader`, let's visualise something completely different: the colour of a Penny Red stamp...

We can obtain an appropriate image file from Wikipedia and save a local copy of it:

```{r}
image.url = 'https://upload.wikimedia.org/wikipedia/commons/a/a4/PennyRed.jpeg'
pennyred_file = 'PennyRed.jpeg'

# Download the file from a specified web location to a specifically named file
download.file(image.url, pennyred_file)
```


## 3D Rendering of Colour Images Using `rayshader` {-}

To use `rayshader` to render the image file, we need to obtain some "elevation" levels that will project some attribute of the image into the vertical *z* dimension.

One obvious candidate is the RGB colour value (we might alternatively render just the red, green or blue components) mapped to a single elevation value by regarding it as a base 256 encoded value:


```{r}
library(raster)

pennyred_image =  jpeg::readJPEG(pennyred_file)
# Also:  png::readPNG(png_file)

# Create a raster file from the image
pennyred = raster(pennyred_file)

# Isolate the reg, green and blue components
pennyred_red = pennyred_image[,,1]
pennyred_green = pennyred_image[,,2]
pennyred_blue = pennyred_image[,,3]

#https://www.maptiler.com/news/2019/03/rgb-encoded-elevation-data-in-maptiler-cloud/
# height = -10000 + ((R * 256 * 256 + G * 256 + B) * 0.1)

# Use the RGB values as a base 256 elevation encoding
# then reduce the height with a base value
# We should really calculate the base value rather than use a 
# value determined by observation...
# The values() function sets the value of the pennyred raster
values(pennyred) = -16700 + (((255-pennyred_red ) * 256 * 256 +
                              (255-pennyred_green ) * 256 +
                              (255-pennyred_blue)) * 0.001)

# The pennyred raster now has values that encode RGB-as-elevation
pennyred
```

To create an elevation matrix from the data, we might consider scaling from the raw RGB values:

```{r}
elev_matrix_pennyred <- matrix(
      raster::extract(pennyred, raster::extent(pennyred)), 
      nrow = ncol(pennyred), ncol = nrow(pennyred)
)
```

The `rayshader` package takes a simple elevation matrix and renders it in 2 or 3 dimensional relief.

For example, here's a simple 2D rendering:

```{r penny-red-desert}
library(rayshader)

elev_matrix_pennyred %>%
  sphere_shade(texture = "desert") %>%
  #add_overlay(pennyred_image) %>%
  plot_map()
  #plot_3d(elev_matrix_pennyred)
```

We can also add the original image back as an overlay. In this case, we lose the 3D effect:

```{r penny-red-overlay}
rayshaded_penny_red = elev_matrix_pennyred %>%
  sphere_shade(texture = "desert") %>%
  add_overlay(pennyred_image)

rayshaded_penny_red %>%
  plot_map()
```

However, if we view the elevated image in a 3D plot, we *can* see the elevation map far more clearly:

```{r penny-red-3d-widget, message=FALSE}
# Configuration settings to allow us to render the WebGL 
options(rgl.useNULL = TRUE,
        rgl.printRglwidget = TRUE)

rgl::clear3d()

rayshaded_penny_red %>%
  plot_3d(elev_matrix_pennyred)

rgl::rglwidget()

# knitr widget embed example via:
# https://github.com/Robinlovelace/geocompr/blob/master/08-mapping.Rmd
# maybe set options?
#knitr::opts_chunk$set(widgetframe_widgets_dir = 'widgets' )
# Save widget to a local file
# w_file = "penny_red_3d_widget.html"
# htmlwidgets::saveWidget(r, w_file)
# We then need to save the file to a URL to use:
# knitr::include_url(URL)
# Or just explicitly use an iframe to load the local file?
```

### Rendering the image directly from `ggplot2`

Whilst we can try to work out our own method for creating elevation models from an image, its much easier to use another tool that `rayshader` provides: the `plot_gg()` function.

This function can render a 3D plot directly from a `ggplot2` object using the `color` or `fill` aesthetic for the elevation values. All the mappings from color to elevation are handled automatically, as is the overlaying of the original image.

So how do we get an image into a `ggplot2` object?

The [`imager` R package](https://cran.r-project.org/web/packages/imager/vignettes/gettingstarted.html) contains some handy utilities for working with images further.

For example, it allows is to straightforwardly plot an image loaded in directly from a file:

```{r penny-red-loaded}
i_imager <- imager::load.image(pennyred_file)
plot(i_imager)
```

We can cast the image as a dataframe, where each row contains an `x` and a `y` co=ordinate, the colour channel, `cc` and the color `value`:

```{r}
i_df <- as.data.frame(i_imager)

head(i_df)
```

With the data in a data frame form, we can the plot from it using `ggplot()` in the normal way:

```{r penny-red-grey}
library(ggplot2)

df <- imager::grayscale(i_imager) %>% as.data.frame

gg_pr = ggplot(df,aes(x,y)) + geom_raster(aes(fill=value)) +
  scale_y_continuous(trans=scales::reverse_trans()) +
  scale_fill_gradient(low="black",high="white") +
  coord_fixed()

gg_pr
```

How about if we pass a full colour image to the `ggplot()`?

```{r gg-penny-red}
library(dplyr) # for mutate

df2 <- as.data.frame(i_imager, wide="c") %>% 
  mutate(rgb.val=rgb(c.1,c.2,c.3))

gg_pr2 = ggplot(df2, aes(x,y)) +
  geom_raster(aes(fill=rgb.val)) +
  scale_fill_identity() +
  coord_fixed() +
  scale_y_continuous(trans=scales::reverse_trans())

gg_pr2
```

## Rendering a Movie {-}

How can we best show off the 3d rendering of the elevated image? One way is to plot the `ggplot()` image as a 3D model using the `rayshader::plot_gg()` function and then render a movie from it using a custom shooting script to drive the camera:

```{r render-penny-red-video}
# Configuration settings to allow us to render the movie
options(rgl.useNULL = FALSE,
        rgl.printRglwidget = FALSE)

library(av)

rgl::rgl.open()
rgl::clear3d()

#Create the plot
plot_gg(gg_pr2, width=5, height=5, scale=250,
        raytrace = FALSE)

# Interesting camera orbit for previewing 3d plots from ggplot

# Script from https://joeystanley.com/blog/3d-vowel-plots-with-rayshader
# which seems to have pinched it form a tutorial somewhere?
#render_movie('demo_pennyred.mp4')

# Set up the camera position and angle
phivechalf = 30 + 60 * 1/(1 + exp(seq(-7, 20, length.out = 180)/2))
phivecfull = c(phivechalf, rev(phivechalf))
thetavec = 0 + 60 * sin(seq(0,359,length.out = 360) * pi/180)
zoomvec = 0.45 + 0.2 * 1/(1 + exp(seq(-5, 20, length.out = 180)))
zoomvecfull = c(zoomvec, rev(zoomvec))


# 3D movie
video_fn = 'demo_pennyred.mp4'

# Actually render the video.
#render_movie(filename = video_fn, type = "custom", 
#            frames = 360, zoom = zoomvecfull,
#            phi = phivecfull, theta = thetavec)

rgl::rgl.close()

embedr::embed_video(video_fn, width = "256", height = "256")
```

So with that taste of what `rayshader` can do, let's get back to our rally data...

<!--chapter:end:aside-penny-red.Rmd-->

```{r cache = T, echo = F, message=F}
# 5Allow knitr to continue to execute even in the presence of errors
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/rayshader-3d-")
```
# Introducing 3D `rayshader` Models

One of the most powerful features of the `rayshader` package is the support if provides for generating and working with 3D rendered models of map views, providing a far more powerful toolkit than offered by tools such as `rasterVis::plot3D()`. In this chapter, we'll demonstrate how to get started creating 3D rendered interactive `rayshader` models.

## Rendering the 3D Maps in *RStudio& and `knitr`able *Rmd* Documents

The 3D map views can be rendered in a couple of ways. To create the rendering, `rayshader` uses the `rgl` package.

According to the `rgl` 
[docs](https://cran.r-project.org/web/packages/rgl/vignettes/rgl.html#working-with-webgl-scenes):

> [t]here are two ways in which rgl scenes are normally displayed within R. The older one is in a dedicated window. In Unix-alikes this is an X11 window; it is a native window in Microsoft Windows. On MacOS, the XQuartz system (see https://www.xquartz.org) needs to be installed to support this.
> To suppress this display, set `options(rgl.useNULL = TRUE)` before opening a new rgl window.

This original approach requires access to an X11 style window. When using a headless environment, such as a Docker environment running RStudio via a web browser, or a MyBinder environment running Jupyter notebooks with an R kernel, the first route is unlikely to work without significant set up and configuration requirements.

The second approach, which we might consider to be the headless, web native approach, is to use WebGL:

> The newer way to display a scene is by using WebGL in a browser window or in the Viewer pane in RStudio. To select this, set `options(rgl.printRglwidget = TRUE)`. Each operation that would change the scene will return a value which triggers a new WebGL display when printed.
> In an R Markdown document in knitr, use the `rgl::`rglwidget` function. (You can also use chunk option `webgl=TRUE`; we recommend the explicit use of ``rglwidget`.) This approach also allows display of rgl scenes in RStudio.

```{r}
# Using the latest version of rgl is currently advised:
# remotes::install_github("dmurdoch/rgl")
#remotes::install_github("dmurdoch/rgl", type = 'source')

# The following is currently broken for me
# install.packages("rgl", repos = "http://R-Forge.R-project.org", type = "source")
# 
```

Settings for running in a headless / *RStudio* / `knitr` environment:

```{r}
# Originally via @fomightez MyBinder rayshader demo:
# https://github.com/fomightez/rayshader-binder
# Recommended settings use in demonstration Binderised repo

# Run this prior to loading library(rayshader)
# send output to RStudio Viewer rather than external X11 window
options(rgl.useNULL = TRUE,
        rgl.printRglwidget = TRUE)

# For using the X11 viewer
# options(rgl.useNULL = FALSE)
```


## Rendering a 3D View

Part of the power of the `rayshader` package comes from being able to take a two dimensional elevation matrix and render it either as a two dimensional image by calling the `rayshader::plot_map()` function, or as a three dimensional image by calling the `rayshader::plot_3d(elevation_matrix)` function. In each case, the same single base model can be created and then piped to either the 2d or 3d plotting function.

Let's create a really simple 3 by 3 matrix:

```{r message=FALSE}
library(rgl)
library(rayshader)

rgl::clear3d()

simple_matrix = matrix(c(0, 0, 0, 0, 0,
                         0, 0, 0, 0, 0,
                         0, 0, 5, 0, 0,
                         0, 0, 0, 0, 0,
                         0, 0, 0, 0, 0), 5)

simple_map = simple_matrix %>%
  sphere_shade(texture = "desert", progbar = FALSE)
```
We can render the matrix a 2d map using the `rayshader::plot_map()` function:
`
```{r rs3d-simple-2d-map}
simple_map %>%
  plot_map()
```

Note that the shading has given us a slight checkerboard pattern even though only one of the squares is elevated.

What happens if we render the same matrix as a three dimensional plot by calling `plot_3d(elevation_matrix)` function with the elevation matrix?


and render it using the `plot_3d()` method with the elevation matrix as an argument
```{r}
simple_map %>%
  plot_3d(simple_matrix, linewidth=0)

rgl::rglwidget()
```
The *zscale* parameter to `plot_3d()` (with default `zscale=1`)  allows us to scale the ratio of the x and y axis scales relative to the z axis. Reducing the *zscale* value has the effect of emphasising or magnifying the vertical *z*-dimension, whereas increasing the `zscale` value "flattens" the relief. For example, for x and y grid units of 1m, for a `zscale` of 2, 1m of elevation is rendered as `elevation / zscale = height`, to give *1 / 2 = 0.5m* high).

## The `rayshader` 3D Model Plinth

A solid base is applied to the model using the *solid* flag which has a default value of `TRUE`. The base thickness and colour are also controllable:

```{r}
rgl::clear3d()

simple_map %>%
  plot_3d(simple_matrix,
          
          # Render base
          solid = TRUE,
          soliddepth = -0.50, #"auto" (= lowest_depth-1)
          solidcolor = "red",
          solidlinecolor = "blue",

        )

rgl::rglwidget()
```

We can remove the base by setting the *solid* parameter to `plot_3d()` to `FALSE`:

```{r}
rgl::clear3d()

simple_map %>%
  plot_3d(simple_matrix,
          # Change the zscale
          zscale=2,
          # No base
          solid = FALSE
        )

r = rgl::rglwidget()
r
```

## Saving the Widget as an HTML File

To save the HTML describing the WebGL model to a file for use elsewhere, we can use the `htmlwidgets::saveWidget(widget, filename)` function.

```{r}
widget_fn = 'simple_3d_model.html'
htmlwidgets::saveWidget(r, widget_fn)
```

Embed the HTML back in an iframe:

```{r}
htmltools::includeHTML(widget_fn)
```

If we save the html to a web location, we can then embed back the widget back as an external file loaded into an HTML iframe using `knitr::include_url()`.

## Rendering the Model to an Image File

```{r}

#rgl::rgl.open()
#rgl::clear3d()
#mapped_route_yellow %>%
#  plot_3d(elmat, zscale = auto_zscale)

render_fn = "demo_model-1.png"

render_snapshot(render_fn)

#rgl::rgl.close()

knitr::include_graphics(render_fn)
```

## Rendering High Quality Models

We can generate high quality renderings of a model using the `rayshader::render_highquality()` function:

```
{r simple-hi-quality}

# TO DO  - currently broken for me - seg fault crashes R
library(rayrender)

# Open a connection to the renderer
#rgl::rgl.open()
rgl::clear3d()

simple_map %>%
  plot_3d(simple_matrix,
          # Change the zscale
          zscale=2,
          # No base
          solid = FALSE
        )

Sys.sleep(0.2)

hi_quality_fn = 'demo-hi-quality-matrix.png'

render_highquality(hi_quality_fn, samples=200,
                   scale_text_size = 24, clear=FALSE)

#Close connection
#rgl::rgl.close()

knitr::include_graphics(hi_quality_fn)
```

The high quality renderer provides a  wide range of controls for composing the shot we want to render. For example one or more light sources can introduced, each with its own *lightdirection*, *lightaltitude*, *lightsize*, *lightintensity* and *lightcolor* setting. A range of camera controls in addition to controls provided by `rgl` window are also available, including *camera_location* and *camera_lookat* (a custom point at which the camera is directed). Experimenting with those settings will have to wait for another day!

For more discussion around rendering high quality images, see the [*`rayshader`: render_highquality#examples*](https://www.rayshader.com/reference/render_highquality.html#examples) docs.


## Making a 3D Print File

As well as visualising the map using an interactive 3D view, we can also export the model as a 3D printer ready model in the in the `.stl` file format using the `rayshader::save_3dprint()` function:

```{r}
# Save the file to a 3d print stl file
#save_3dprint("stage_3d.stl", maxwidth = 10, unit = "in")
```

For another approach to generating 3D print model files from terrain data, see [`ChHarding/TouchTerrain_for_CAGEO`](https://github.com/ChHarding/TouchTerrain_for_CAGEO) /via \@WRCStan.

## Saving a Movie of a 3D Model

We can generate a movie file showing an animated view of the model using the `rayshader::render_movie()` function.

*When operating in headless mode, movies are rendered using the `webshot2` package. The launches a browser in the background which then renders the modelas a widget. This can be a slow process; rendering the following movie on my reasonably well-specced laptop took well over 10 minutes to render.*

By default, we create a simple "turning model" movie, but the camera position, as well as lighting effects, can be scripted to allow us create the sort of scene we require. Who needs drone footage?!

```{r render-simple-movie, message=FALSE, warning=FALSE}
# We need to load the av package to render the movie
library(av)

#options(rgl.useNULL = FALSE,
#        rgl.printRglwidget = FALSE)

# Open a connection to the renderer
rgl::rgl.open()

rgl::clear3d()
simple_map %>%
  plot_3d(simple_matrix)

# Render the movie to an MP4 file
video_fn = 'demo_3d_model.mp4'

#render_movie(video_fn)

rgl::rgl.close()

# Embed the movie
embedr::embed_video(video_fn, width = "256", height = "256")
```

The camera view used to generate the move can be configured according to several predefined paths using the `rayshader::render_movie()` *path* paramter and include the default *orbit* path, an *oscillate* path that covers a 90 degrees field of view and a *custom* path setting with which you can channel your inner principle photographer. Other parameters include the frame rate (*fps*) and the number of *frames* to render. A title bar can also be rendered.

<!--chapter:end:rayshader-3d.Rmd-->

```{r cache = T, echo = F, message=F}
# 18Allow knitr to continue to execute even in the presence of errors
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/rayshader-3d-maps-")
```

# Rendering 3D `rayshader` Stage Route Maps

Having introduced interactive 3d `rayshader` models in the previous chapter, let's now explore how we can generate interactive three dimensional models of our stage maps.

## Load in Base Data 

As ever, let's load in our stage data:

```{r}
library(tidyr)

geojson_filename = 'montecarlo_2021.geojson'
geojson_sf = sf::st_read(geojson_filename)
stage_bbox = sf::st_bbox(geojson_sf)
```

We have already seen how we can overlay an elevation model raster on a leaflet map, as well as rendering two dimensional topographic models using the `raytracer` package. Generating 3D, rather than 2D, maps follows exactly the same steps as the 2D view apart from the final rendering step.

Recall that the `raytracer` package itself works with a matrix of raster values. Having saved the download raster to a tif file, we can load the data back in from and convert it to a matrix using the `rayshader::raster_to_matrix()` function:

```{r message=FALSE, warning=FALSE}
library(rayshader)
library(raster)

# Previously downloaded buffered TIF digital elevation model (DEM) file
stage_tif = "buffered_stage_elevation.tif"

# Load in the previously saved image raster
elev_img = raster(stage_tif)

# Get the natural zscale
auto_zscale = geoviz::raster_zscale(elev_img)

# Note we can pass in a file name or a raster object
elmat = raster_to_matrix(stage_tif) 
```

Just as a reminder, here's a quick review of what the 2D maps look like:

```{r demo-2d}
# Use the raster extent for the plots
stage_extent = extent(elev_img)

yellow_route = generate_line_overlay(geojson_sf[1,],
                                    extent = stage_extent,
                                    heightmap = elmat,
                                    linewidth = 5, color="yellow")

mapped_route_yellow = elmat %>%
  sphere_shade(sunangle = -45, texture = "bw") %>%
  #add_water(watermap, color = "bw") %>%
  add_overlay(yellow_route)

mapped_route_yellow %>%
  plot_map()
```

The 2D plots can be quite pretty, but we can also bring them even more alive as 3D rendered plots.


## Setting Up 3D Embedded Plots

Recall that to embed WebGL interactive models using `rgl::rglwidget()`, we need to fettle some settings first:

```{r}
options(rgl.useNULL = TRUE,
        rgl.printRglwidget = TRUE)
```


## Rendering a Simple Stage Route Model

We can render our 2D route model simply by passing it to the `rayshader::plot_3d()` function, along with the elevation model.

If we set the `zscale` parameter to the *auto_zscale* determined previously as `auto_zscale = geoviz::raster_zscale(elev_img)`, the relief is rendered using the "real" scaling that keeps the height of elevated areas in equal proportion to the scale used by the x and y scale values:

```{r}
rgl::clear3d()

mapped_route_yellow %>%
  plot_3d(elmat, zscale=auto_zscale)

rgl::rglwidget()
```

We can also disable the display of the base to give a view similar to the sort of view we might render using `plot3d()`.

There are several approaches we can use to grabbing a flat image capture of a model. One is to the use an `rgl::rglwidget(snapshot=TRUE)` call which in headless mode uses `webshot2` to launch a browser in the background, render the model inside a widget in that browser, and then grab a screenshot...

```{r rendered-map-yellow-route, message=FALSE}
rgl::rgl.open()
rgl::clear3d()

mapped_route_yellow %>%
  plot_3d(elmat,
        zscale = auto_zscale,
        # Disable the solidbase display
        solid = FALSE,
        # But reserve the shadow
        shadow = TRUE,
        shadowcolor = 'lightblue'
       )

r = rgl::rglwidget(webgl=FALSE, snapshot=TRUE)

render_fn = 'example_render.png'
file.rename(r[1], render_fn)

rgl::rgl.close()

knitr::include_graphics(render_fn)
```

The `rayshader::render_snapshot()` and `rayshader::render_highquality()`` functions provide alternative ways of rendering the current scene:

```{r rendered-snapshot-yellow-route}
rgl::rgl.open()
rgl::clear3d()
mapped_route_yellow %>%
  plot_3d(elmat, zscale = auto_zscale)

render_fn2 = "demo_stage_3D_map_overlay.png"

render_snapshot(render_fn2)

rgl::rgl.close()

knitr::include_graphics(render_fn2)
```

### Decorating 3D Views With Map Tile Overlays

As with the 2D views, we can drape map tile imagery over the 3D view and it will be shaped to fit the 3D elevation model. Let's create a terrain layer using some tile imagery:

```{r message=FALSE, warning=FALSE}
library(geoviz) # For slippy_overlay

overlay_image_terrain <- slippy_overlay(elev_img, 
                                        image_source = "stamen",
                                        image_type = "terrain",
                                        png_opacity = 0.9)
```

Add the terrain to a model and render it in 2D:

```{r mapped-yellow-terrain}
mapped_terrain_yellow = mapped_route_yellow %>%
                          add_overlay(overlay_image_terrain) %>%
                          add_overlay(yellow_route)

mapped_terrain_yellow %>% plot_map()
```

And now, how about the 3D version?

```{r mapped-yellow-terrain-widget}
rgl::clear3d()

mapped_terrain_yellow %>%
  plot_3d(elmat, zscale=auto_zscale)

rgl::rglwidget()
```

As before, we should be able to a video from the model. However, for current package versions, trying to render the movie just leads to an error after a *long* time spent trying to render the movie: 

```{}
library(av)

options(rgl.useNULL = FALSE,
        rgl.printRglwidget = FALSE)

# Open a connection to the renderer
rgl::rgl.open()

rgl::clear3d()

mapped_terrain_yellow %>%
  plot_3d(elmat, zscale=auto_zscale)

# Render the movie to an MP4 file
video_fn = 'demo_3d_stage_tile_overlay.mp4'

render_movie(video_fn)

rgl::rgl.close()

# Embed the movie
embedr::embed_video(video_fn, width = "256", height = "256")

```

### Adding Labels to 3D `rayshader` Maps

To highlight points of interest on a 3D model, we can we add a labels to the 3D view. A line can be used to connect a label to the point on the surface map that the label relates to.

*TO DO - this has stopped working now too...; neither OpenGL nor FreeType seem to be supported in the rgl version I'm using and if I try to roll back, the previous version doesn't want to work at all. One to return to in the fullness of time perhaps... It's not an efficient use of time to get stuck in finding workarounds for what may just be dev in progress.*

```{r}
rgl::clear3d()
mapped_terrain_yellow %>% 
      plot_3d(elmat, zscale=auto_zscale)

render_label(elmat, lat = 44.7808, long = 5.909417,
        extent = stage_extent, 
        #zscale = auto_zscale, 
        offset=0, # Height above surface to start the line
        altitude=1036 + 500 , #32000,
        text = "Split 1", textsize = 2, linewidth = 3)

rgl::rglwidget()
```



<!--chapter:end:rayshader-3d-maps.Rmd-->

```{r cache = T, echo = F, message=F}
# 22Allow knitr to continue to execute even in the presence of errors
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/rayshader-3d-cropviews-")
```

# Creating Cropped 3d `rayshader` Models

As well as viewing the "full" scene using a 3D `rayshader` model, the `rayshader` package provides us with a *baseshape* parameter to the `rayshader::`plot_3d()` function that allows us to crop the view to a particular shape.

We can also use a manual cropping technique to crop the extent of the model we wish to render.

## Load in Base Data 

As ever, let's load in our stage data:

```{r}
library(tidyr)

geojson_filename = 'montecarlo_2021.geojson'
geojson_sf = sf::st_read(geojson_filename)
stage_bbox = sf::st_bbox(geojson_sf)
```

We have already seen how we can overlay an elevation model raster on a leaflet map, as well as rendering two dimensional topographic models using the `raytracer` package.

The `raytracer` package itself works with a matrix of raster values. Having saved the download raster to a tif file, we can load the data back in from and convert it to a matrix using the `rayshader::raster_to_matrix()` function:

```{r message=FALSE, warning=FALSE}
library(rayshader)
library(raster)

# Previously downloaded TIF digital elevation model (DEM) file
stage_tif = "buffered_stage_elevation.tif"

# Load in the previously saved image raster
elev_img = raster(stage_tif)

# Get the natural zscale
auto_zscale = geoviz::raster_zscale(elev_img)

# Note we can pass in a file name or a raster object
elmat = raster_to_matrix(stage_tif) 
```


```{r}
options(rgl.useNULL = TRUE,
        rgl.printRglwidget = TRUE)
```

Let's create a demo map that we can use as as test piece:

```{r}
demo_map = elmat %>%
              sphere_shade(texture = "desert") %>%
              add_water(detect_water(elmat, progbar = FALSE),
                        color = "desert")
```

## Cropping the Rendered 3D View

We can crop the rendered 3D view according to three predefined shapes: *circle*, *hex*, or the *rectangle* default.

```{r}
# Additional baseshape parameter can be: circle, hex, or rectangle
library(rgl)

options(rgl.useNULL = FALSE,
        rgl.printRglwidget = FALSE)
#rgl::rgl.open()
rgl::clear3d()
demo_map %>%
      plot_3d(elmat, zscale = 10,
              baseshape="circle")

#rgl::rgl.close()
rgl::rglwidget()
```

However, when cropping we may lose some of the area of interest. In such cases, we would need to add a buffer margin to the image so that when we crop it, we still retain all the detail we require in the cropped view.

## Cropping 3D Models to a Buffered Region

The `rayshder::plot3d()` function provides us with a means of cropping the rendered model to a circular or hexagonal base shape, as well as the default rectangular base. But we can also crop the base image manually in order to render an arbitrary shape of our choosing.

For example, we have already seen how we can create a polygon that takes the shape of a buffered region around our route. As well as plotting that shape as a 2D `ggplot2` image, we can also use it as a mask for cropping our map before we render it as a 3D model.

We can use the `raster::crop()` and `raster::mask()` functions applied to a spatial object to cut out the area of interest from the original image:

For example, the following recipe lets use create a buffered area with a size specified in meters, around our stage route:

```{r message=FALSE}
library(sf)

lonlat2UTM_hemisphere <- function(lonlat) {
    ifelse(lonlat[1] > 0, "north", "south")
}

lonlat2UTMzone = function(lonlat) {
  utm = (floor((lonlat[1] + 180) / 6) %% 60) + 1
  if(lonlat[2] > 0) {
    utm + 32600
  } else{
    utm + 32700
  }
}

# Grab a copy of the original projection
original_crs = st_crs(geojson_sf[1,])

# Find the UTM zone for a sample a point on the route
crs_zone = lonlat2UTMzone(c(st_coordinates(geojson_sf[1,])[1,1],
                            st_coordinates(geojson_sf[1,])[1,2]))

# Create the projection string
utm_pro4_string = st_crs(crs_zone)$proj4string
#"+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs"
# units in meters e.g. https://epsg.io/32632

# Transform the route projection
utm_route = st_transform(geojson_sf[1,],
                         crs = st_crs(utm_pro4_string))


# Generate buffered routes in UTM and longlat projections
buffer_margin_1km = units::set_units(1000, m)

buffered_route_utm <- st_buffer(utm_route, buffer_margin_1km)
buffered_route <- st_transform(buffered_route_utm, original_crs)
```

We can now use the buffered route to crop our 3D model along the route:

```{r}
# For more explanation of the following, see e.g.:
# https://geocompr.robinlovelace.net/geometric-operations.html#raster-cropping

buffered_route_sp = as(buffered_route, 'Spatial')
rgl::clear3d()
elmat2 <- crop(raster(stage_tif), extent(buffered_route_sp))
elmat3 <- mask(elmat2, buffered_route_sp)
elmat4 = raster_to_matrix(elmat3) 

yellow_route_buffer = generate_line_overlay(geojson_sf[1,],
                                    extent = extent(elmat2),
                                    heightmap = elmat4,
                                    linewidth = 5, color="red")
elmat4 %>%
  sphere_shade(sunangle = -45, texture = "bw") %>%
  add_overlay( yellow_route_buffer ) %>%
  plot_3d(elmat4, solid=TRUE,
          zscale=auto_zscale)

rgl::rglwidget()
#render_movie('demo_stage_buffer.mp4')
```

*There seem to be some artefacts arising from the solid base, although I'm not sure if that's an issue with the raster or the renderer?*


<!--chapter:end:rayshader-3d-cropviews.Rmd-->

```{r cache = T, echo = F, message=F}
# 6Allow knitr to continue to execute even in the presence of errors
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/shadows-time-of-day-")
options(rgl.useNULL = TRUE,
        rgl.printRglwidget = TRUE)
```

# Obtaining Shadows for a Particular Date and Time

In many rally events, several stages are run twice at different times of the day. The `rayshader` package allows a sun angle to be defined that acts as the basis for raytracing and shadow casting. This means that we can render 3D models with the light source positioned appropriately for the different times of day a stage is scheduled to run.

Rally itineraries typically identify the start time of the first car into the stage. Based on the gap between each start and the number of cars, as well as the length of the stage, we can get an idea of the times within which the stage is likely to be being competed.

If we know what time of day a stage is to be run, we can light the model appropriately to show the anticipated direction and extent of shade.

## Load in Base Data 

As ever, let's load in our stage data and the elevation raster and create a demo map:

```{r message=FALSE, warning=FALSE}
geojson_filename = 'montecarlo_2021.geojson'
geojson_sf = sf::st_read(geojson_filename)

library(raster)
library(rayshader)

# Previously downloaded TIF digital elevation model (DEM) file
stage_tif = "stage_elevation.tif"

# Load in the previously saved image raster
elev_img = raster(stage_tif)

# Get the natural zscale
auto_zscale = geoviz::raster_zscale(elev_img)

# Note we can pass in a file name or a raster object
elmat = raster_to_matrix(stage_tif)

demo_map = elmat %>%
              sphere_shade(texture = "desert",
                           progbar = FALSE)
```

Let's also reuse a previously created function for creating shadows and shadow rasters:

```{r}
# Left-right matrix flip
fliplr = function(x) {
  if(length(dim(x)) == 2) {
    x[,ncol(x):1]
  } else {
    x[,ncol(x):1,]
  }
}

rasterify_rayshade = function(rayshade, original_raster){
  # Transpose and flip the shade matrix
  reorient_rayshade = fliplr(t( rayshade ))
  # Generate the raster
  rayshade_raster  = raster( reorient_rayshade )
  # Set the extent
  extent(rayshade_raster) = extent(original_raster)
  # Set the CRS
  crs(rayshade_raster) = crs(original_raster)
  
  rayshade_raster
}

# Example usage:
#ray_shade_array = ray_shade(heightmap, progbar=FALSE)
#ray_shade_raster = rasterify_rayshade(ray_shade_array, elev_img)
```

## Sunlight Times Vocabulary

According to its documentation, the `suncalc::getSunlightTimes()` function takes a date, time, latitude, and longitude to obtain the times for sunrise and sunset. The documentation also describes the complete range of returned values as follows:

- *sunrise*: sunrise (top edge of the sun appears on the horizon);
- *sunriseEnd* : sunrise ends (bottom edge of the sun touches the horizon)
- *goldenHourEnd*: morning golden hour (soft light, best time for photography) ends;
- *solarNoon*: solar noon (sun is in the highest position);
- *goldenHour*: evening golden hour starts;
- *sunsetStart*: sunset starts (bottom edge of the sun touches the horizon);
- *sunset*: sunset (sun disappears below the horizon, evening civil twilight starts);
- *dusk*: dusk (evening nautical twilight starts);
- *nauticalDusk* : nautical dusk (evening astronomical twilight starts);
- *night*: night starts (dark enough for astronomical observations);
- *nadir*: nadir (darkest moment of the night, sun is in the lowest position);
- *nightEnd*: night ends (morning astronomical twilight starts);
- *nauticalDawn*: nautical dawn (morning nautical twilight starts);
- *dawn*: dawn (morning nautical twilight ends, morning civil twilight starts).


## Finding Sunrise and Sunset Times

To begin with, let's use the `suncalc` passage to find sunrise and sunset times.

We can grab the approximate centroid location of the stage to use as the basis for our sun position calculations:

```{r}
#https://www.rdocumentation.org/packages/sp/versions/1.3-2/topics/SpatialPoints-class
location_ish = attr(rgeos::gCentroid(as(geojson_sf[1,],'Spatial')),
                    'coords')
location_ish
#5.90937 44.78685
```

```{r}
#https://github.com/tylermorganwall/MusaMasterclass

library(suncalc)

getSunlightTimes(as.Date("2021-01-22"),
                 lat = location_ish[2], lon = -location_ish[1],
                 tz = "GMT")

# Can we get the timezone from WRC json event metadata?
# Also first on stage times from itinerary
```

From the itinerary and the stage location data, as well as the number of cars on the startlist, we should be able to estimate the likely sunlight conditions expected for the first and last cars into the stage (weather may also have an effect, of course!).

```{r}
#Start and hour after sunrise and end an hour before sunset
time_example = lubridate::ymd_hms("2021-01-22 05:30:00", tz = "UTC")
time_example
```

The  `suncalc::getSunlightPosition()` takes a similar range of input arguments and returns information describing the positioning of the sun in the sky. Once again, the documentation describes the returned values: 

- *altitude*: sun altitude above the horizon in radians, e.g. 0 at the horizon and PI/2 at the zenith (straight over your head)
- *azimuth*: sun azimuth in radians (direction along the horizon, measured from south to west), e.g. 0 is south and Math.PI * 3/4 is northwest

Let's see how the shading looks at different times of the day for the same stage...

First, create a base map to work with:

```{r}
base_map = elmat %>%
  sphere_shade(texture = "desert", progbar = FALSE) %>%
  add_water(detect_water(elmat, progbar = FALSE),
            color = "desert")
```

Now let's create a function for determining the sun altitude and sun angle:

```{r}
sun_alt_angle = function(date_time, lat, lon){
  sun_pos = suncalc::getSunlightPosition(date=date_time,
                                       lat = lat,
                                       lon = lon)
  # recalculation into degrees and correct (north) orientation of azimuth

  # Convert to degrees
  sunaltitude = sun_pos$altitude * (180/pi)
  sunangle = 180 + sun_pos$azimuth * (180/pi) # From North
  list(altitude= sunaltitude,
       angle = sunangle)
}

date_time = "2021-01-22 07:30:00 UTC"

sun_pos = sun_alt_angle(date=date_time,
                        lat = location_ish[2],
                        lon = -location_ish[1])


sun_pos$altitude
sun_pos$angle
```

We can also create a function to plot the map:

```{r map-morning, message=FALSE, warning=FALSE}
#rgl::clear3d()
shadow_mapper = function(sunpos){
  
  elmat %>%
    sphere_shade(texture = "desert", progbar = FALSE) %>%
    add_water(detect_water(elmat, progbar = FALSE),
              color = "desert") %>%
    add_shadow(ray_shade(elmat, zscale = auto_zscale,
                       sunangle = sunpos$altitude,
                       sunaltitude = sunpos$altitude,
                       lambert = FALSE,
                       #Suppress the progress bar display
                       progbar = FALSE), 0.3) %>%
    plot_map()
  #plot_3d(elmat, zscale=11)
}
  
#rgl::rglwidget()
```

So let's see if we can render an early morning view:

```{r shadow_mapper-test}
# Create a date time string
date_time = "2021-01-22 07:30:00 UTC"

sun_pos = sun_alt_angle(date=date_time,
                        lat = location_ish[2],
                        lon = -location_ish[1])

shadow_mapper(sun_pos)
```

A mid-morning view:

```{r map-midday, message=FALSE, warning=FALSE}
date_time = "2021-01-22 11:30:00 UTC"

sun_pos = sun_alt_angle(date=date_time,
                        lat = location_ish[2],
                        lon = -location_ish[1])

shadow_mapper(sun_pos)

#rgl::rglwidget()
```

A mid-afternoon view:

```{r map-afternoon, message=FALSE, warning=FALSE}
date_time = "2021-01-22 15:30:00 UTC"
sun_pos = sun_alt_angle(date=date_time,
                        lat = location_ish[2],
                        lon = -location_ish[1])

shadow_mapper(sun_pos)

#rgl::rglwidget()
```

And how about an early evening view?!

Note that if we push the time past sunset, the sun angle goes below the horizon and presumably tries to illuminate the model from below... so it's probably best to try to trap for times that are too far after sundown or before sunrise, perhaps?

```{r map-night, message=FALSE, warning=FALSE}
date_time = "2021-01-22 19:30:00 UTC"

sun_pos = sun_alt_angle(date=date_time,
                        lat = location_ish[2],
                        lon = -location_ish[1])

shadow_mapper(sun_pos)

#rgl::rglwidget()
```

One view that might be interesting to generate is a movie that animates shadow cover over the course of a day.

Other parameters to consider: *hillshade*, *shadow*, *shadowdepth*.

## Animating Shade

If we create a raster stack of shadow rasters at different times of day, we can animate them using the `raster::animate()` function.

Let's create a raster stack of shadows at different times of day. To create the stack, we need a list of rasters:

```{r}
raster_shadow = function(heightmap, sunpos) {
  ray_shade_array = ray_shade(heightmap, 
                              sunangle = sunpos$altitude,
                              sunaltitude = sunpos$altitude,
                              progbar=FALSE)
  rasterify_rayshade(ray_shade_array, elev_img)
}

shadow_rasters = c()

for (i in 8:16) {
  date_time = sprintf("2021-01-22 %02d:30:00 UTC", i)
  
  sun_pos = sun_alt_angle(date=date_time,
                          lat = location_ish[2],
                          lon = -location_ish[1])
  shadow_rasters = c(shadow_rasters,
                     raster_shadow(elmat, sun_pos))
}

raster_stack <- stack(shadow_rasters) 
nlayers(raster_stack)
```

Let's preview one of the frames:

```{r animated-shade-frame}
plot(shadow_rasters[[3]],
     col = grey.colors(10, start=0, end=1))
```

We can animate the raster stack as an animated gif using the `animation::saveGIF()` function:

```{r animated-shade}
shadow_gif = "shadowmovie.gif"

animation::saveGIF({
  for (i in 1:nlayers(raster_stack)){
    plot(shadow_rasters[[i]],
         col = grey.colors(10, start=0, end=1),
         legend=FALSE,
         main = paste("Hour", 7+i))
    }
  }, movie.name = shadow_gif, autobrowse=FALSE)

knitr::include_graphics(shadow_gif)
```

## Getting Moon Information

As well as getting information about sunrise and sunset, we can also get information regarding the state of the moon for a specified datetime and location.

```{r}
getMoonTimes(as.Date("2021-01-22"),
             lat = location_ish[2], lon = -location_ish[1],
             tz = "GMT")
```

We can get the phase of the moon as well:

```{r}
getMoonIllumination(as.Date("2021-01-22"))
```

The phase value is interpreted as follows:

- 0 : New Moon
- : Waxing Crescent
- 0.25 : First Quarter
- : Waxing Gibbous
- 0.5: Full Moon
- : Waning Gibbous
- 0.75: Last Quarter
- : Waning Crescent

We can use a `cut()`  to map the value onto a human readable term:

```{r}
moon_phase = function(dt){
  phase = getMoonIllumination(as.Date(dt))$phase
  
  mp = cut(phase,
           c(0, 0.1, 0.2, 0.3, 0.4, 0.6, 0.7, 0.9, 1),
           labels = c('New Moon', 'Waxing Crescent',
                      'First Quarter', 'Waxing Gibbous',
                      'Full Moon', 'Waning Gibbous',
                      'Last Quarter', 'Waning Crescent'),
          include.lowest=TRUE)
  as.character(mp)
}

moon_phase(as.Date("2021-02-27"))
```

```{r}
moon_alt_angle = function(date_time, lat, lon){
  moon_pos = suncalc::getMoonPosition(date=date_time,
                                      lat = lat,
                                      lon = lon)
  # recalculation into degrees and correct (north) orientation of azimuth

  # Convert to degrees
  moonaltitude = moon_pos$altitude * (180/pi)
  moonangle = 180 + moon_pos$azimuth * (180/pi) # From North
  list(altitude= moonaltitude,
       angle = moonangle)
}

moon_alt_angle(date=date_time,
               lat = location_ish[2],
               lon = -location_ish[1])
```

<!--chapter:end:shadows-time-of-day.Rmd-->

```{r cache = T, echo = F, message=F}
# 12Allow knitr to continue to execute even in the presence of errors
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/rayshader-3d-landscapes-")
```

# Composing `rayshader` Stills and Movies

If we have access to a desktop rgl renderer, we can easily generate snapshots and movies of our rendered scenes. Without the desktop rendering, things are slower.

*Such is the way of things, I left the arty 3D rendering sections to do till last, and in the three weeks since I started playing with rayshader, then parked it as I moved on to other chapters, many things rendering now seem differently broken to me. I updated something and can't find any version combinations of packages that get me back to where I was. Should'a baked it into a Docker container... :-( So this is something I'll have to return to at some point to see if things have started working again. Ho hum...*

## Load in Base Data 

As ever, let's load in our stage data:

```{r}
geojson_filename = 'montecarlo_2021.geojson'
geojson_sf = sf::st_read(geojson_filename)
```

And also load in the elevation data raster:

```{r message=FALSE, warning=FALSE}
library(raster)
library(rayshader)

# Previously downloaded TIF digital elevation model (DEM) file
stage_tif = "buffered_stage_elevation.tif"

# Load in the previously saved image raster
elev_img = raster(stage_tif)
auto_zscale = geoviz::raster_zscale(elev_img)

# Note we can pass in a file name or a raster object
elmat = raster_to_matrix(stage_tif)
```

Let's create a demo map that we can use as as test piece:

```{r}
demo_map = elmat %>%
              sphere_shade(texture = "desert") %>%
              add_water(detect_water(elmat, progbar = FALSE),
                        color = "desert")
```

We need to ensure we are rendering into a desktop rgl canvas, rather than a WebGL widget:

*But that's all broken for me atm, making this a TO DO item. OpenGL not compiled in to the package I'm using and I can't find an old version that works the way it used to for me...*

```{r}
options(rgl.useNULL = FALSE,
        rgl.printRglwidget = FALSE)
```

####  Creating Titles and Overlays

The `rayshader::plot_map()` functions allow us to add a title to a view. The title text sits on top a coloured title bar, with configurable colour and transparency.

The title text can be repositioned using the *title_position* attribute but the title bar doesn't seem to be transported with it...

```{r title-demo}
demo_map %>%
      plot_map(title_text='Stage Map',
               title_size = 20,
               title_bar_color = "red",
               title_bar_alpha=0.8,
               title_color="white",
               title_offset = c(120,12), #offset from top left
               title_style='italic',
               #title_position='south', # But doesn't relocate bar?)
               )
```

We can also add titles to rendered 3D views with the  `rayshader::render_snapshot()` function:

```{r}
rgl::clear3d()

demo_map %>%
      plot_3d(elmat, zscale = auto_zscale)

title_fn = "demo_stage_3D_title_overlay.png"

render_snapshot(title_fn,
                title_text='Stage Map',
                title_size = 20,
                title_bar_color = "red",
                title_bar_alpha=0.8,
                title_color="white",
                title_offset = c(120,12), #offset from top left
                title_style='italic',
                #title_position='south', # But doesn't relocate bar?)
                )

knitr::include_graphics(title_fn)
```

We can also add an image overlay with the *image_overlay* attribute set to the path of a png image file (with transparency) or a 4-layer RGBA array. The image will be resized to the dimension of the image if the dimensions don't match and overlaid on the original.

It might be useful to create a function that can take a smaller image, such as a stage results table, and buffer it with a transparent margin to match the raster size?

### Adding Complications...

We can add watchmaker style complications to the chart in the form of a scalebar and a compass to show the direction:

```{r}
rgl::clear3d()

demo_map %>% 
  plot_3d(elmat, zscale=auto_zscale)

render_scalebar(limits=c(0, 5, 10),label_unit = "km",
                position = "S", y=50,
                scale_length = c(0.33, 1))

render_compass(position = "E")

complications_fn = "demo_stage_3D_map_complications.png"

render_snapshot(complications_fn)

knitr::include_graphics(complications_fn)
```

## Setting Up the Camera Shots in `rayshader`

*This is just to slow TO DO when we have to work with `webshot2`. Revisit another day, hopefully...:-(*

A wide variety of controls and functions are available that allow us to use `rayshader` as a virtual studio for capturing views of the landscape from arbitrary positions and with a wide variety of camera and lighting settings.


### Depth of Field

The `rayshader::render_depth()` function gives us control over the depth of field and provides all sort of parameters that folk who like twiddling things on their camera might enjoy. From the docs, the following controls are available:

- virtual camera settings:
  - *focus*:  depth in which to blur (0..1)
  - *focallength*
  - *fstop*
- bokeh settings:
  - *bokehshape*: *circle* or *hex*
  - *rotation*: number of degrees to rotate the hexagon bokeh shape
  - *bokehintensity*: intensity of the bokeh when the pixel intensity is greater than 'bokehlimit'
  - *bokehlimit*: limit after which the bokeh intensity is increased by 'bokehintensity'
- image manipulation:
  - *gamma_correction*: control gamma correction when adding colors
  - *aberration*: add chromatic aberration to the image. 

A *preview_focus* flag is also provided that can be used to display a red line across the image showing where the camera will be focused.

Let's generate a gallery of some possible settings:

```{}

rgl::clear3d()

demo_map %>% plot_3d(elmat, zscale=auto_zscale)

render_depth(focus = 0.81, focallength = 200,
             title_bar_color = "black",
             vignette = TRUE,
             title_text = "SS1, Rallye Monte Carlo, 2021", 
             title_color = "white", title_size = 50)

test_fn = 'test8.png'
render_snapshot(test_fn)

knitr::include_graphics(test_fn)
```

TO DO - maybe generate an animated gif showing various settings?

## Camera Positioning

As well as generating "quick" rendered snapshots of a scene using the `rayshader::render_snapshot()` function, we can also set up a scene and render it using the `rayshader:render_highquality()` function.

The `rayshader::render_highquality()` function combines the ability to render a scene with camera positioning, title adding and other scene management controls.

For example, we can use the `rayshader::render_camera()` function to position the camera and set various camera properties:

- *theta*: rotation of the model in the xy-plane
- *phi*: azimuth angle, height above the horizon
- *fov*: field of view in degrees (maximum 180)
- *zoom*: magnification of the camera zoom (>0)

A [masterclass](https://github.com/tylermorganwall/MusaMasterclass) by `rayshader` creator Tyler Morgan-Wall uses the following video to demonstrate the between the theta and phi settings, the camera position and the camera view:

```{r}
video_url = "https://www.tylermw.com/data/all.mp4"
embedr::embed_video(video_url, type='mp4')
```

In an RMarkdown document, we can set the camera location *after* generating the 3D plot, but *before* rendering it via the widget. We could equally render the plot to an image from that position rather then rendering the widget to view the model interactively.

*TO DO - this should equally position the camera in the OpenGL window and then let us take a really quick snapshot...*

```{r message=FALSE}
rgl::clear3d()

demo_map %>% plot_3d(elmat, zscale=auto_zscale)

render_camera(theta = 40, phi = 70, zoom = 1.5, fov = 90)

rgl::rglwidget()
```

Rather than rendering the widget, we could equally just render the scene to an image file.

Let's set up some example shots...

```{}
rgl::rgl.open()
demo_map %>% plot_3d(elmat)

render_camera(theta = 140, phi = 70, zoom = 0.9)

test_fn = 'test8.png'
render_snapshot(test_fn)

knitr::include_graphics(test_fn)
```

Once we are happy with out shot, we might render it to a high quality image:

```{}

demo_map %>% plot_3d(elmat)

render_camera(theta = 40, phi = 70, zoom = 1.5, fov = 90)

hiq_fn = 'test2.png'

render_highquality(hiq_fn)

knitr::include_graphics(hiq_fn)
```


### Lighting Effects

The `rayshader:render_highquality()` function also provides a wide range of controls for composing the shot we want to render. For example one or more light sources can introduced, each with its own *lightdirection*, *lightaltitude*, *lightsize*, *lightintensity* and *lightcolor* setting. A range of camera controls in addition to controls provided by `rgl` window are also available, including *camera_location* and *camera_lookat* (a custom point at which the camera is directed). Experimenting with those settings will have to wait for another day!

For more discussion around rendering high quality images, see the [*`rayshader`: render_highquality#examples*](https://www.rayshader.com/reference/render_highquality.html#examples) docs.


## Making 3D Video Tracking Shots

As well as allowing us to control the camera view for setting up static 3D camera shots, the `rayshader` package also provides us with a way of generating animated 3D movies.

We can render a movie of a rotating model using the `rayshader`render_movie()` function and its default *type="orbit"* setting or we can create out own tracking path:

```{}
library(av)

rgl::clear3d()
rgl::rgl.open()

demo_map %>%
  add_overlay(yellow_route) %>%
      plot_3d(elmat, webgl=FALSE, snapshot=TRUE, zscale =7)

render_movie('demo_stageX.mp4')
rgl::rgl.close()
```
```{r}
demo_fn = 'demo_stage.mp4'
embedr::embed_video(demo_fn, width = "256", height = "256")
```





<!--chapter:end:rayshader-3d-landscapes.Rmd-->

```{r cache = T, echo = F, message=F}
# 9Allow 1 knitr to continue to execute even in the presence of errors
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/route-metrics-")
```

# (PART) Stage Route Metrics {-}

# Stage Route Analysis

This chapter introduces several ideas relating to *stage route analysis* and the generation of "stage route profiles" that describe various features of the the route, such as its twistiness. 

To a certain extent, stage route analysis could be considered as a static analysis complement to the pace notes created for a stage:

```{r}
library("vembedr")
# Hayden Paddon describes pace notes
embed_url("https://www.youtube.com/watch?v=9q7EYVJL9XU")

# See also this Team O'Neil tutorial:
# "Rally Stage Notes and Pace Notes Explained" https://www.youtube.com/watch?v=earjqfXGYzw
```

Stage route analysis also includes a consideration of elevation along the route. Analysis and review of route elevation is explored in more detail in a separate chapter.

## Load in Base Data 

As ever, let's load in our stage data and the elevation raster and create a demo map:

```{r message=FALSE}
library(sf)
library(raster)
library(rayshader)

geojson_filename = 'montecarlo_2021.geojson'
geojson_sf = sf::st_read(geojson_filename)

stage_route_gj = geojsonio::geojson_json(geojson_sf[1,]$geometry)

# Previously downloaded TIF digital elevation model (DEM) file
stage_tif = "stage_elevation.tif"

# Load in the previously saved image raster
elev_img = raster(stage_tif)

# Note we can pass in a file name or a raster object
elmat = raster_to_matrix(stage_tif)

demo_map = elmat %>%
              sphere_shade(texture = "desert",
                           progbar = FALSE)
```

Let's also get a UTM projection of the stage routes:

```{r message=FALSE, warning=FALSE}
# Detect the UTM zone as an EPSG code
lonlat2UTMzone = function(lonlat) {
  utm = (floor((lonlat[1] + 180) / 6) %% 60) + 1
  if(lonlat[2] > 0) {
    utm + 32600
  } else{
    utm + 32700
  }
}

get_utm_projection = function(routes){
  # Keep track of the original proj4 string
  old_crs = st_crs(geojson_sf[1,])$proj4string

  sample_location_x = st_coordinates(st_centroid(routes[1,]))[1]
  sample_location_y = st_coordinates(st_centroid(routes[1,]))[2]
  
  # Generate a new projection in the appropriate UTM zone
  crs_zone = lonlat2UTMzone(c(sample_location_x,
                              sample_location_y))

  new_proj4_string = st_crs(crs_zone)$proj4string

  # Transform the route to the UTM projection
  utm_routes = st_transform(geojson_sf, crs=new_proj4_string)
  
  utm_routes
  # Or should we returned a named list
  # e.g. including the original projection?
  #list(utm_routes = utm_routes, orig_crs=old_crs)
}

utm_routes = get_utm_projection(geojson_sf)
```

In some cases, we may want to discretise a route to smaller segment lengths. We can use the `sf::st_segmentize()` function cut a route described by a linestring into shorter connected segments. For example, we can discretise the route into segments lengths of just 1m long:

```{r}
segmented_route_utm = st_segmentize(utm_routes[1,], units::set_units(1, m))
segmented_route_utm_coords = st_coordinates(segmented_route_utm)
```

Note that if we plot a discretised path, we may end up cutting corners that are described in the original route. Another side effect of discretisation is that the length of the discretised route may change.

## Generating Stage Route Profiles

Although there are no `R` packages (yet!) that are specifically focused on representing and analysing rally stage data, there are several packages designed to support the representation and analysis of animal tracks and route trajectories. These packages are capable of loading and analysing route co-ordinate data specified in a variety of ways and have no difficulty in working with our stage route data.

As to the question of "why bother?", several possibilities come to mind.

In the first case, for the rally fan or rally journalist, learning a bit more about the make up of a stage may add colour when watching or reporting on a stage, or help make sense of why time appears capable of being made up, or lost, on particular stages or particular parts of a stage.

In the second case, an understanding of the detail of a particular stage may help understand strategy, or tyre selection.

In the third case, understanding stage routes may help in setting strategy, or even in planning a stage or hill climb route. With the potential for electric vehicles being used in stage rallies and for hill climbs, energy management and budgeting becomes a key issue. Ensuring that an electric vehicle has enough stored energy to allow it to complete even a single stage, let alone multiple stages with road sections in between, requires an understanding of the likely energy consumption requirements. Knowing the distances involved is one component, but elevation changes may also feed into to energy question, particularly on a a hill climb where the only way is up, and opportunities for regenerative breaking are reduced. Knowing how tortuous a stage is, and the relative mix of fast straights flat corners and slower corners may also help produce simple kinetic energy requirement models for a stage.

### An Aside - Twists and Turns of Rally Stages

Whilst an understanding of the state of the road surface and the current weather conditions may be the key factors in determining tyre choice, how "twisty and turny" a stage route may also influence tyre selection and driving style. 

The tread pattern of rally tyres are designed to support acceleration even when turning, so if tyres are wearing thin and the last stage of day has far more aggressive right corners than turns to a left, knowing the stage profile may help save a second or two.

```{r tyre-video, message=FALSE}
embed_url("https://www.youtube.com/watch?v=-I74uopkcro")
```

## Finding Stage Route Lengths

To begin with, let's start with a very simple metric, *stage route length*.

We can find the length of each stage route in meters using the `sf::st_length()` function:

```{r}
st_length(geojson_sf)
```

Or for a single stage:

```{r}
st_length(geojson_sf[1,])
# 21069.62
```

The `rgeos::gLength()` function will generate the length of a *Spatial* object using its natural units. Which is to say, we'd need to project into something like UTM co-ordinates first if we wanted to use it to calculate the distance in meters.

We can also find the route length directly from a geojson string that encodes latitude and longitude locations using the *turf.js* like `geoops::geo_line_distance()` function:

```{r}
route_as_geojson = geojsonio::geojson_json(geojson_sf[1,]$geometry)

geoops::geo_line_distance(route_as_geojson)
# 21.05409
```


The `geosphere::distGeo()` function provides a way of calculating distances for each step of the route represented using the lonlat projection:

```{r}
# Get the coordinates for each step
lonlat_coords = st_coordinates(geojson_sf[1,])[,1:2]

# Omit the final NA value
route_step_lengths = head(geosphere::distGeo(lonlat_coords), -1)

# Calculate the accumulated distance at each step
# and return the final (maximum) value:
max(cumsum(route_step_lengths))
# 21069.62
```

One thing we notice is that some of these distances are: a) different to each other; b) different to the officially stated stage distance of 20.58 km.

The projection and parameters used in a projection to calculate the distance all contribute to the actual calculated value. In addition, our distance calculations are base on summing the lengths of the multiple straight line segments described by the route data rather than the tighter (shorter) racing line. It's also not clear from the route data where the extent of the route is the extent of the competitive portion of the stage, or whether the start and end points refer to the time control locations rather than competitive timing lines.

On the other hand, the  actual route is likely to be longer than what we might term the "ground distance" as you can tell from an elevation chart that shows elevation of the route against distance into the route. If we elevation and distance axes on the same scale, the elevation line is unlikely to be a straight line: the elevation may go up or down. If we straighten out the elevation line to a flat line and place on the x-axis, it will be longer than the original "on the flat" route distance.


## Using Ecological Movement Analysis Tools to Analyse Stage Routes

Ecologists researching animal movements have produced a wide range of tools for categorising and classifying the trajectories of routes followed by one or more animals. Trajectories are typically recorded as sequences of locations recorded at particular times.

The [`adehabitatLT` *R* package](https://cran.r-project.org/web/packages/adehabitatLT/index.html)  usefully categorises animal trajectories in the following ways:

- *type I*: location data is available but a sample timestamp is not precisely known or not available for each step;
- *type II*: as well as location data, a timestamp for each step is also available; this type is then further subdivided into:
  - *regular trajectories*, where there is a constant delay or period between each step sample;
– *irregular trajectories*, where there is a variable delay between each step sample.

As far as rally data goes, stage route data may be trivially classed as either *type 1*. However, if we use distance into route as a time proxy, we can also create  *type II irregular* traces; telemetry data should ideally be *type II regular*.

One intuition behind using animal movement analysis tools to categorise rally stage routes is that we can analyse the route as if it were a *type 1* style animal track. Another intuition is that we can use distance into route as a dummy time variable (e.g. use a dummy equivalence mapping of 1m into route as 1s, although we could also attempt to use proxy times, such as setting *time = distance_into_stage x nominal_speed*, or even use a speed model that may depend on route properties at each step of the stage).

## Using `trajr` for Stage Route Profiling

The [`trajr` *R* package](https://cran.r-project.org/web/packages/trajr/vignettes/trajr-vignette.html) was developed to help characterise and analyse the trajectories or paths followed by a moving animal given various location coordinates along its route.

Trajectories are created using Cartesian co-ordinates, so it makes sense to use data that has been cast into UTM coordinate system as the basis for the trajectory. A two dimensional spatial `trajr` trajectory can be created by default from a two column (x/y coordinates) or three column (x/t/time) dataframe using the `trajr::TrajFromCoords()` function, r from an arbitrary dataframe by specifying column names using the *xCol*, *yCol* and *timeCol* parameters. Spatial and temporal units can also be specified using the *spatialUnits* and *timeUnits* parameters.

```{r}
library(trajr)

trj <- TrajFromCoords(as.data.frame(st_coordinates(utm_routes[1,])))
```

To cast all the routes to trajectories, we could do something like the following:

```{r}
get_trj = function(route){
  TrajFromCoords(as.data.frame(st_coordinates(route$geometry)))
}

trjs = apply(utm_routes, 1, get_trj)
```

We can retrieve the stage length using the `trajr::TrajLength` function:

```{r}
TrajLength(trjs[[1]])
```

We can create also create a simple plot of the trajectory, and overplot it with the location points used to construct the route:

```{r trajr-plot}
# Create a simple plot the route
plot(trj)

# Overlay points onto the plot
points(trj, draw.start.pt = FALSE,
       #pch = 16,  # symbol
       col = "black", 
       cex = 0.4 # scale
       )
```

For each fragment of the line we can calculate the distance from its displacement, or directly using `trajr::TrajStepLengths` function, and then cumulatively sum them to get the overall route distance so far:

```{r}
# displacement is a complex number, so we can get the actual distance:
trj$distance = Mod(trj$displacement)

# Find the distance of the just completed step
trj$distance2 = c(0, TrajStepLengths(trj))

# Find the distance of the upcoming step
trj$predist = c(TrajStepLengths(trj), 0)

# Find the accumulated distance at each step
trj$cum_dist = cumsum(trj$distance)

head(trj[,c('distance', 'distance2', 'predist', 'cum_dist')])
```


### Smoothing a Trajectory

Sometimes a stage route may appear rather "ragged" as an artefact of using multiple straight line segments to construct the route.

We can smooth a route with a Savitzky-Golay smoothing filter called from `signal::sgolayfilt` using the `trajr::TrajSmoothSGorder(order, filter_length_odd)` function.

Using a third order filter applied to a window size of 5 steps retains quite a smooth fitting line whilst removing some of the sharp edges caused by concatenating straight line segments

```{r trajr-plot-smoothed}
smoothed <- TrajSmoothSG(trj, p=3, n=5)
#p polynomial order
#n filter length (window size); must be an odd integer
plot(trj)
plot(smoothed, col = "red", add = TRUE)
```

The [`smoothr` *R* package](https://cran.r-project.org/web/packages/smoothr/vignettes/smoothr.html) also provides several useful smoothing utilities.

So that we can more clearly see what's going on, let's grab just a fragment of our stage route:

```{r}
get_route_segment = function(i, steps){
  cc = as.data.frame(st_coordinates(geojson_sf[i,]))[steps,]

  st_linestring(cbind(x=cc[,1], y=cc[,2]))
}

route_segment = get_route_segment(1, 1:10)
```

For example, the `smoothr::smooth` function allows us to apply various smoothing approaches. Let's see how well its *ksmooth* kernel smoothing approach works, that applies a Gaussian kernel regression to the x and y coordinates independently:

```{r smoothr_ksmooth}
smoothr_route_segment = smoothr::smooth(route_segment,
                                        method = "ksmooth")

plot(st_geometry(route_segment), col = 'grey', lwd = 3)
plot(st_geometry(smoothr_route_segment),
     col = "red", add = TRUE)
```

Alternatively, we could use the `smoothr` *spline* method, which calculates a spline interpolation over the x and y coordinates independently:

```{r smoothr_spline}
plot(st_geometry(geojson_sf[1,]), col = 'grey', lwd = 3)
plot(st_geometry(smoothr::smooth(geojson_sf[1,], method = "spline")),
     col = "red", add = TRUE)

smoothr_route_segment2 = smoothr::smooth(route_segment, method = "spline")

plot(st_geometry(route_segment), col = 'grey', lwd = 3)
plot(st_geometry(smoothr_route_segment),
     col = "red", add = TRUE)
```

For a more detailed look at smoothing trajectories and finding racing lines, albeit in circuit racing, see  *Heilmeier, A., Wischnewski, A., Hermansdorfer, L., Betz, J., Lienkamp, M. and Lohmann, B., 2019. Minimum curvature trajectory planning and control for an autonomous race car. Vehicle System Dynamics. DOI: 10.1080/00423114.2019.1631455* and the related Python laptime simulation package, [`TUMFTM/laptime-simulation`](https://github.com/TUMFTM/laptime-simulation).

### Resampling Locations

We can use the `trajr::TrajRediscretize` function to resample locations from the line that are a fixed distance apart as the crow flies. s well as finding sample points, a new trajectory is also calculated that connects those points.

For example, if we discretise the route to points 500m apart as the crow flies, we note that the newly discretised route now has straight line segments between each of the sample points. This is perhaps not so good for stage route analysis, but it does provide one way of obtaining sample point locations from telemetry data. Ideally, though, sample points would be a fixed distance apart *along the route*:

```{r trajr-rediscretized}
# Resample to step length 500m
resampled <- TrajRediscretize(trj, 500)
plot(trj)

# Plot rediscretized trajectory in red
lines(resampled, col = "#FF0000A0", lwd = 2)
points(resampled, type = 'p', col = "#FF0000A0", pch = 16)
legend("topright", c("Original", "Rediscretized"),
       col = c("black", "red"), 
       lwd = 2, inset = c(0.01, 0.02))
```

Can we see how many splits there are?

```{r}
nrow(resampled)
```

### Resampling Against Distance

The `trajr` package doesn't seem to support resampling by distance along the line but it does allow resampling by time. So if we set the time to the accumulated basis, we can use time as a proxy for distance...

```{r}
# Backup the original (dummy) timestamps
trj$displacementTime_ = trj$time

# Use the accumulated distance as a time proxy
trj$time = trj$cum_dist
```

Let's see what happens if we resample based on this use of time as a proxy for distance sampling the route every 2km:

```{r trackr-resampled}
# The time units for the route are in seconds: TrajGetTimeUnits(trj)
resampled_t = TrajResampleTime(trj, 2000 )
plot(trj)

#lines(resampled_t, col = "#FF0000A0", lwd = 2)
points(resampled_t, type = 'p', col = "#FF0000A0", pch = 16)
legend("topright", c("Original", "Resampled"),
       col = c("black", "red"), 
       lwd = 2, inset = c(0.01, 0.02))
```

### Splitting a Trajectory

We can split a trajectory using the `trajr::TrajSplit()` function. This takes a trajectory and an index of split points along the path and returns a list of trajectories containing the segment starting from each of the index values to the next supplied value.

If we try to use this function to split the route by split points applied generated by discretising or sampling the route, the resolution of the original line is lost: we are not cutting the *original() line at the sample points, we are cutting the *new* line created from the sample points:

```{r split-resampled}
plot(TrajSplit(resampled_t, c(1, 2, 4))[[3]])
```

However, we *can* cut the original lines using the `stplanr::route_split()` function:

```{r split-route-colours}
#https://www.rdocumentation.org/packages/stplanr/versions/0.6.2/topics/route_split
library(stplanr)

# Get the second resampled point
pt = st_sfc(st_point(c(resampled_t[2,'x'],resampled_t[2,'y'])),
             crs=st_crs(utm_routes[1,])$proj4string)

# Get the third resampled point
pt2 = st_sfc(st_point(c(resampled_t[3,'x'],resampled_t[3,'y'])),
             crs=st_crs(utm_routes[1,])$proj4string)

# Plot the original route in grep
plot(utm_routes[1,]$geometry, lwd = 9, col = "grey")

# Split the route about the second point
split_route = route_split(utm_routes[1,], pt)

# And plot the two parts
plot(split_route$geometry, col = c("red", "blue"), add = TRUE)
```

We can view each line segment separately:

```{r segmented-stage-parts}
# Use two columns to display plots side by side
par(mfrow=c(1,2))

plot(split_route[1,]$geometry)
plot(split_route[2,]$geometry)
```

We can automate the extraction of segmented lines using the following approach, which takes a route, splits it by the first point, splits the second half of the segment by the second point, and so on. Note that this requires us to order the points we want to split the line along in the order they appear along the route:

```{r}
split_line = function(route_, pts_) {
  segments = c()
  for(i in 1:length(pts_)) { 
    split_ = route_split(route_, pts_[i])
    segments = c(segments, split_[1])
    route_ = split_[2]
  }
  route_
}

# Points we wish to segment on
pts = c(pt, pt2)

split_route2 = split_line(utm_routes[1,], pts)

split_route2
```

Now we can plot out three segment line (two split points):

```{r three-segment-line}
plot(utm_routes[1,]$geometry, lwd = 9, col = "grey")
plot(split_route2$geometry, col = c("red", "blue", "green"), add = TRUE)
```

### Rotating the Stage Trajectory

To visualise routes in a similar profile, we can use the `trajr::trajr-rotate()` function to align the start and finish points. An *angle* parameter gives the angle in radians between the first and last points.

For example, for a horizontal, left to right right stage view:

```{r trajr-rotate-horiz}
plot(TrajRotate(trj, angle = 0, relative = TRUE))
```

Or for a view where we read the stage up from the bottom:

```{r trajr-rotate-vert}
plot(TrajRotate(trj, angle = pi/2, relative = TRUE))
#Arguments
#trj The trajectory to be rotated.
#angle The angle in radians between the first and last points in th
```
It might be handy to rebase the coordinates of the start to (0,0).

### Straightness and Sinuosity

Several simple measures exist that try to provide a single number measure describing something about the straightness or sinuosity of a trajectory.

For example, the `trajr::TrajStraightness()` function determines *straightness* from the start to the end of a route as the ratio *D/L*, where *D* is the distance from the start to the end of the trajectory, and *L* is the length of the trajectory:

```{r}
TrajStraightness(trj)
```

We can get the straightness for each stage as follows:

```{r}
utm_routes['straightness'] = unlist(lapply(trjs, TrajStraightness))
utm_routes[,c('Name', 'straightness')]
```

This suggests that SS 5 is perhaps the most least straight, and SS13/15 is most straight.

If reading data from tables is not your thing, here's a chart...

```{r straight_bar, message=FALSE}
library(ggplot2)

g1 = ggplot(utm_routes) +
        geom_col(aes(x=as.numeric(row.names(utm_routes)),
                     y=straightness)) +
  scale_x_discrete(limits=utm_routes$Name) + xlab('Stage')

g1
#ggpubr::ggarrange(c(g1, g2))
```

Let's render them both, with a simple indicator to show where the *start* of each stage is.

```{r straightness-stages, warning=FALSE, message=FALSE}
start_location = function(i) {
  as.data.frame(st_coordinates(utm_routes[i, ]$geometry))[1,]
}

plot_stage = function(i, label){
   ggplot(data=utm_routes[i,]) + 
          geom_sf() + 
          geom_point(aes(x=X, y=Y), size=2,
                     col='red', alpha = 0.5,
             data=start_location(i)) +
          ggtitle(label) + coord_sf()
}

g_SS5 = plot_stage(5, 'SS5 - least straight' )

g_SS13 = plot_stage(9, 'SS13/15 - most straight')

ggpubr::ggarrange(g_SS5, g_SS13)
```

Note that where we have multiple split point tines and locations for a stage available, we could slice the stage into split segments and analyse the straightness of each one separately.

Another single value measure is the *sinuosity*, "a function of the mean cosine of the turning angle", calculated in a corrected form that does not require constant step size by the [`traj::TrajSinuosity2()` function](https://rdrr.io/github/JimMcL/trajr/man/TrajSinuosity2.html) (based on equation 8 of *Benhamou, S. (2004). [How to reliably estimate the tortuosity of an animal's pat](http://www.seaturtle.org/library/BenhamouS_2004_JTheorBiol.pdf), Journal of Theoretical Biology, 229(2), 209-220. doi:10.1016/j.jtbi.2004.03.016*):

Let's see how the sinuosity compares with straightness on each stage:

```{r}
utm_routes['sinuosity'] = unlist(lapply(trjs, TrajSinuosity2))
utm_routes[, c('Name', 'straightness', 'sinuosity')]
```

Again, if reading data from tables is not your thing, we can visualise how straightness and sinuosity relate on each stage using a scatterplot:

```{r str_sin_scatter}
g2 = ggplot(utm_routes, aes(x=straightness,
                            y=sinuosity,
                            label = Name)) + 
        geom_point(size=1)  +
        # hjust: left justification (0), right justification (1)
        geom_text(size=3, hjust = 1, nudge_y = -0.001)
g2
```

Under this measure we see that the most sinuous state is actually SS 13/15 and SS5 also has high sinuosity, whereas SS 2 is the least sinuous stage:

```{r trajr_sinuosity}
g_SS2 = plot_stage(2, 'SS2 - least sinuous')

g_SS13b = g_SS13 + ggtitle('SS13 - most sinuous')

ggpubr::ggarrange(g_SS2, g_SS13b) 
```

### Directional Change

Another possible measure of how twisty a route is the *directional change*. As this measure is defined for each pair of steps, the directional change measure applied to a route is given as the mean (DC) and standard deviation (SDDC) calculated over all directional changes. Directional change itself is defined as the angular change (in degrees) between any two points in the trajectory, divided by the time difference between the two points. According to the [`trajr` vignette](https://cran.r-project.org/web/packages/trajr/vignettes/trajr-vignette.html), *DC may be used as an index of nonlinearity, and SDDC as a measure of irregularity*.

The time basis of this measure means we have to use some sort of poetic license when using this measure for route analysis: do steps go up one time unit per step, or do we use the accumulated distance for time stamps?

```{r}
calc_dc = function(route){
  mean(TrajDirectionalChange(route))
}

calc_sd = function(route){
  sd(TrajDirectionalChange(route))
}

utm_routes['DC'] = unlist(lapply(trjs, calc_dc))
utm_routes['SDDC'] = unlist(lapply(trjs, calc_sd))
utm_routes[, c('Name', 'DC', 'SDDC')]
```

Exploring these measures with different time bases is left for another day...

### Tracking Turning Angles
One final single value, albeit, a complex value, metric we can get is the mean vector of the turning angle, given via the `trajr::TrajMeanVectorOfTurningAngle()` function.

This function takes a *compass.direction* (default `NULL`) which indicates whether the angle should be calculated relative to the angle (in radians) or, if `NULL`, relative to the previous step.

```{r}
utm_routes['meanTurn'] = unlist(lapply(trjs,
                                       TrajMeanVectorOfTurningAngles))

utm_routes[, c('Name', 'meanTurn')]
```

For example, SS2 and SS13 appear to rotate in different directions?

```{r trajr-mean-turn}
ggpubr::ggarrange(g_SS2, g_SS13) 
```

Hmm... maybe!

We can also take the mean vector and turn it into polar coordinates. The angle is then the mean angle of turn (`Arg(meanTurn)`), although the magnitude (`Mod(meanTurn)`) for the relative angle summary is perhaps less useful.

Parsing the angle in terms of the general direction of travel over the course of the route provides a potential signal regarding the general compass direction of travel. This may be relevant when trying to identify whether a driver might be driving into the sun, for example (recall that we can look up sun angle and elevation by date and time easily enough using the `suncalc` *R* package.

The simplest calculation is probably just to calculate the bearing between the start and the end point of the route, for example using the `geosphere::bearing()` function.

Alternatively we might consider a summary statistic of the amount of turn at each step along the route.

For example, we can calculate the angle of each step on a route relative to a specific compass angle, which I think(?!) has the compass angle of 0 radians for due North:

```{r}
compass_relative_turn = function(route, angle=0) {
  TrajMeanVectorOfTurningAngles(route, angle)
}

utm_routes['meanCompass'] = unlist(lapply(trjs,
                                          compass_relative_turn))

utm_routes[, c('Name', 'meanCompass')]
```

In this case the angle will give the average compass direction of travel and the modulus may give us an indication of the straightness of travel in that direction?

So... do SS2 and SS6 appear to go in different directions?

```{r trajr-mean-compass-different}
g_SS2 = plot_stage(2, 'SS2 - one way..')

g_SS5 = plot_stage(5, 'SS5 - and another?')

ggpubr::ggarrange(g_SS2, g_SS5) 
```

And do SS9 and SS11 appear to go in roughly the same direction?

```{r trajr-mean-compass-same}
g_SS9 = plot_stage(6, 'SS9 - and the same?')

ggpubr::ggarrange(g_SS2, g_SS9) 
```

### Visualising Trajectory Direction Changes

As well as providing single number metrics, we can also get information back at the level of each step of the trajectory. We have already seen how the complex *displacement* is given for each step, from which we can calculate the distance of each step.

We can also get access to the angle of each step in a route using the `trajr::TrajAngles()` function. This function also takes a *compass.direction*, again indicating whether the angle should be calculated relative to the angle (in radians) or, if `NULL`, relative to the previous step.

```{r}
# Step angle in radians relative to previous
trj$stepangle = c(0, TrajAngles(trj, compass.direction = NULL) * 180 / pi, NA) 

trj$cumstepangle = cumsum(c(0, TrajAngles(trj, compass.direction = NULL) * 180 / pi, NA))
trj$stepheading = c(TrajAngles(trj, compass.direction = 0)* 180 / pi, NA) 


head(trj[,c('stepangle', 'cumstepangle', 'stepheading')], 5)
```

We can plot the route using colour to give the general heading, by quadrant:

```{r trajr-route-headings, warning=FALSE}
# Cut styling via https://stackoverflow.com/a/29966785/454773

ggplot(data=tidyr::drop_na(trj, stepheading ),
       aes(x=x, y=y, color=col)) + 
  geom_point(aes(colour = cut(stepheading,
                              c(-180, -90, 0, 90, 180))),
             size = 1) +
  coord_sf() + 
  geom_point(aes(x=X, y=Y), size=1, col='black',
             data=start_location(1))
```

Can we identify tight turns? The following chart plots each step location, using a distinct marker to highlight turns with a large *stepangle*:

```{r trajr-tight-turns, warning=FALSE}
ggplot(data=trj,
       aes(x=x, y=y), size=0.5) + geom_path(color='grey')+
  geom_point( pch=0, color='blue',
             data=trj[abs(trj$stepangle)>45,]) +
    geom_point(data=trj[abs(trj$stepangle)<=45,],
                pch=1, color='red', size=0.1) +
  coord_sf() + 
  geom_point(aes(x=X, y=Y), size=1, col='black',
             data=start_location(1))
```

The instantaneous angle is okay for trying to identify particularly tight turns, but to identify whether a corner increase the angle in the same step direction, which is to say, whether the corner *tightens*, for example, we need process the data a bit further.

One way of doing this is to determine the gradient of the accumulated angle using the [`pracma::gradient` function](https://www.rdocumentation.org/packages/pracma/versions/1.9.9/topics/gradient). 

```{r}
trj$step_gradient = pracma::gradient(trj$cumstepangle, trj$cum_dist)
```

The sign of the gradient then identifies the turn direction but the magnitude of the gradient is harder to parse because the step sizes are not constant. 

A plot using colour to depict gradient sign may help identify whether a route involves turn predominantly to the left or to the right. We could use a related approach to display a table of locations labeled as tight right or left corners, for example:

```{r trajr-gradient-lr, warning=FALSE}
ggplot(data=trj,
       aes(x=x, y=y)) + geom_path(color='grey')+
  geom_point( size=0.2, color='blue',
             data=trj[trj$step_gradient>0.2,]) +
    geom_point(size=0.2,
               data=trj[trj$step_gradient<=-0.2,],
               color='red') +
  coord_sf() + 
  geom_point(aes(x=X, y=Y), size=1, col='black',
             data=start_location(1))

```

If nothing else, however, this approach also gives us an immediate way of detecting stationary points in the gradient. As a consequence, we can identify directional changes from left to right, or *vice versa*.

```{r trajr-gradient, warning=FALSE}
ggplot(trj,aes(x=cum_dist)) + 
    geom_hline(yintercept=0, color='grey' ) +
    geom_hline(yintercept=-500, color='grey' ) +
    geom_line(aes( y=cumstepangle)) +
    geom_line(aes( y=-500+50 * step_gradient),
              color='red')
```

By creating simple rules, we might be able to identify features like *tightens* (for example, if we have three angles in the same direction with increasing magnitude and the final angle exceeding some threshold limit). We might similarly be able to create rules around elevation data, for example to identify *crests* (for example, a maximum in elevation, found by finding stationary points of elevation / first derivative).

Finally, it's worth briefly mentioning a couple more `trajr` functions that may be useful when it comes to analysing telemetry data: `trajr::TrajVelocity` and `trajr:TrajAcceleration`, which estimate velocity and acceleration as vectors at each point along a trajectory. But that's for another book...

## Using `amt` for Stage Route Profiling

The [`amt` (animal movement tools) *R* package](https://cran.r-project.org/web/packages/amt/index.html) was designed to support the management and analysis of animal movement data. Routes are represented as *tracks* in the form of tibbles with at least an *x_* and *y_* column and, if required, a `t_` (time) column. Consecutive rows, which might be assumed to be collected with fixed period, identify straightline *steps*. A `track_xy`track type only has coordinates, and a
`track_xyt` track type has a timestamp associated to each coordinate pair.

An additional *burst* column, `burst_`, provides us with a potential grouping parameter that lets us perform analyses on sections of the track. This could be used to identify segments of the route between split points, for example, if we can apply appropriate burst labels to each part of the track.

For our purposes here, it is clear to see how we might imagine a mapping the X and Y co-ordinates from a route linestring in a UTM/meters based projection directly into a a track tibble. The `amt::make_track()` function provides a straightforward way of doing this:

```{r}
library(amt)

amt_track = make_track(st_coordinates(utm_routes[1,]), X, Y)
amt_track
```

### Creating Tracks

The `make_track` function has a further optional argument (`crs`), which allows the user to set a coordinate reference system (CRS) of the track. The CRS needs to be provided as valid proj4string, see the documentation of sp::CRS for further details; see also [*proj4* projections](https://proj.org/usage/projections.html).

We can segment the track into a series of straightline steps from one point to the next, also returning the step distance (`sl`) and angle (`direction_p` radians):

```{r}
# Create a "steps" object from each sample
amt_steps = steps(amt_track)
head(amt_steps)
```

### Converting to Other Track Formats

The `amt` package provides a range of tools that allow us to *coerce* `amt` tracks to other movement analysis packages.

For example, we can cast a `track_xy` object to a *Spatial* object:

```{r}
as_sp(amt_track)
```

Conversions to other movement data structures is possible from `track_xyt` objects.

## Using `amt` for Stage Route Analysis
We can also obtain step lengths directly from the track via the `amt::step_lengths()` function:

```{r}
# Obtain the step lengths and omit / drop the final NA value
amt_step_lengths = head(step_lengths(amt_track), -1)
```

Directions can be determined absolutely, e.g. with reference to a North, South, East or West basis, using `amt::direction_abs()` or relatively to the previous step using ``amt::direction_rel()`:

```{r}
absolute_step_directions = direction_abs(amt_track)
relative_step_directions = direction_rel(amt_track)
```

In terms of route complexity measures, the `amt` package provides functions for calculating single number metrics of *sinuosity* (`amt::sinuosity()`), 
*straightness* (`amt::straightness()`), *accumulated track distance* (`amt::cum_dist()`) and *total straightline distance* (`amt::tot_dist()`). The *intensity use* metric is calculated by dividing the total movement distance (`tot_dist`) by the square of the area of movement:

```{r}
amt::sinuosity(amt_track)
amt::straightness(amt_track)
amt::cum_dist(amt_track)
amt::tot_dist(amt_track)
amt::intensity_use(amt_track)
```

Let's generate a list of tracks, one for each stage:

```{r warning=FALSE, message=FALSE}
to_amt_track = function(route){
  make_track(st_coordinates(route$geometry), X, Y)
}

amt_tracks = apply(utm_routes, 1, to_amt_track)
```

Now we can generate reports for all the stages:

```{r}
utm_routes['amt_sin'] = unlist(lapply(amt_tracks, amt::sinuosity))
utm_routes['amt_str'] = unlist(lapply(amt_tracks, amt::straightness))
utm_routes['amt_cumd'] = unlist(lapply(amt_tracks, amt::cum_dist))
utm_routes['amt_totd'] = unlist(lapply(amt_tracks, amt::tot_dist))
utm_routes['amt_int'] = unlist(lapply(amt_tracks, amt::intensity_use))

utm_routes[, c('amt_sin','amt_str','amt_cumd','amt_totd','amt_int')]
```

We can resample locations from the track using `amt::track_resample()`. Once again, if we use distance as a proxy for time, this allows us to sample by distance along the line.

## Using `rLFT` for Stage Route Profiling

The [`rLFT` (Linear Feature Tools) *R* package](https://cran.r-project.org/web//packages/rLFT/vignettes/rLFT_Introduction.html) was developed in order to support the processing of simple linear features.

The boundary convexity tool function, `rLFT::bct()` generates a convexity measure for a sliding window of points along a route; the route must be provided in a projected (*not* geographic) coordinate system. The sign of the convexity measure identifies whether the curve is concave (negative value, left turn) or convex (positive value, right turn), the increasing values identifying tightness of the curve.  A normalised convexity index and a sinuosity measure  are also created.

The `bct()` function takes two important arguments:

- the *step*, which describes the distance between measurements along the route (i.e. the distance between ample points), and
- the *window*, which describes the size of the window (the distance along the route) used to measure the convexity value.

```{r rlft-route}
library(rLFT)

route_convexity <- bct(utm_routes[1,],
                   # distance between measurements 
                   step = 10,
                   window = 20, ridName = "Name")

head(route_convexity)
```

We can get the output table as a *simple features* object where the midpoint co-ordinates are cast to a point geometry type using the `sf:st_as_sf()` function:

```{r}
outSF <- st_as_sf(route_convexity,
                 coords = c("Midpoint_X", "Midpoint_Y"), 
                 stringsAsFactors = FALSE)
```

We note that by sampling the actual route at 10m intervals when calculating curvature *and then recreating a route from those 10m sample points*, we may actual crop the end of tight corners as represented by the original route path. Reducing the step size would provide a more faithful route (recall, the *window* size is actual used in performing the convexity calculation). Arguably, it might make sense to use generate a smoothed route from the original route and then use a small step size over the smoothed route as the basis for all route based metrics.

The convexity measures are defined in [*Measuring boundary convexity at multiple spatial scales using a linear 'moving window' analysis: an application to coastal river otter habitat selection*](https://www.d.umn.edu/biology/documents/Nibbelink2_000.pdf), Albeke, S.E. et al., Landscape Ecology 25 (2010): 1575-1587.


### Convexity Profile of a Stage Route

We can profile the convexity of a stage route in the terms of the convexity against the distance along the route in terms of a simple line chart. Recall that the sign of the convexity value denotes the direction of a corner (negative left, positive right).

We can add a grey bar with low alpha transparency to slightly mask the less sever corners:

```{r curvature-profile-bar}
ggplot(route_convexity) +
  geom_bar(aes(x=MidMeas, y=ConvexityIndex, col=(ConvexityIndex>0)),
           stat='identity', show.legend = FALSE) +
  geom_rect(ymin = -0.1, ymax = 0.1, 
            xmin = -Inf, xmax = Inf,
            fill = 'lightgrey', alpha=0.05)
```

### Previewing Significant Corners

By filtering the table to rows with with a large absolute *ConvexityIndex* we can identify and label tight corners. The `ggrepel::geom_text_repel()` function attempts to minimise the extent to which labels overlap, using arrows to identify points referenced by the label where the label location is dodged away from the point:

```{r rLFT-route, message=FALSE, warning=FALSE}
tight_corners = route_convexity[abs(route_convexity$ConvexityIndex)>0.45,]

ggplot() +
  geom_sf(data=utm_routes[1,]) +
  ggrepel::geom_text_repel(data=tight_corners,
                           aes(label = ConvexityIndex,
                               x=Midpoint_X, y=Midpoint_Y,
                               color= (ConvexityIndex>0) ),
                           size=2,
                           nudge_x = 2000, nudge_y = 500) +
  geom_point(data=tight_corners,
             aes(x=Midpoint_X, y=Midpoint_Y,
                 color= (ConvexityIndex>0) ), size=1) +
  theme_classic()
```

### Convexity as a 3D Plot

To try to get a feel for how the convexity changes along a route, we can render a 3D plot of the of the convexity using the `rayhader::ggplot()` function.

As a first step, we need to create a base *ggplot2* plot:

```{r convexity_gg}
convexity_gg = ggplot() + geom_sf(data=utm_routes[1,]) +
  geom_point(data=route_convexity,  show.legend = FALSE,
             size=1,
            aes(x=Midpoint_X, y=Midpoint_Y,
                color=abs(ConvexityIndex)))

convexity_gg
```

Then we can render it in three dimensions:

```{r}
library(rayshader)
library(rgl)

rgl::clear3d()
plot_gg(convexity_gg, scale=1000, raytrace = FALSE)

rgl::rglwidget()
```

Looking at these metrics over a complete route can be a little hard to decipher. However, if we segment the route into smaller sections, as we shall see in the next chapter, we will see how can start to use these metrics to describe the route in some useful detail.

## Finding Curvature of a Route

The `pracma::circlefit()` function will attempt to calculate the center and radius of a curvature from an arc defined by a path segment described by three or more consecutive locations provided as *x* and *y* coordinate lists. We can use the radius of curvature to determine corner severity numbers that are typically used in rally pace notes.

For example, we can build on the the `rLFT` segmented route to add the radius of curvature of turns starting at each midpoint:


```{r results=FALSE}
# The curvature function takes an arc defined over
# x and y coordinate lists
curvature = function(x,y){
  #729181.8, 729186.1, 729190.4
  #4957667 , 4957676, 4957685
  tryCatch({
      # circlefit gives an error if we pass a straight line
      # Also hide the print statement in circlefit
      # circlefit() returns the x and y coords of the circle center
      # as well as the radius of curvature
      # We could then also calculate the angle and arc length
      pracma::circlefit(x,y)[3]
    },
    error = function(err) { 
      # For a straight, return the first co-ord and Inf diameter
      # Alternatively, pass zero diameter?
      c(x[1], y[1], Inf)[3]})
}

curvature2 = function(x1, x2, x3, y1, y2, y3){
  curvature(c(x1, x2, x3), c(y1, y2, y3))
}

# The base::Vectorize function provides a lazy way of 
# vectorising a non-vectorised function
curvatures = Vectorize(curvature2)

# Tests
#curvature(c(729181.8,729186.1,729195.4),c(4957667,4957676,4957685))
#curvature(c(729194.6,729198.8,729199.6),c(4957694,4957703,4957713))
```

Let's find the radius of curvature for each 10m sampled point we obtained when finding convexity values along the route:

```{r message=FALSE, warning=FALSE, results=FALSE}
library(dplyr)
library(pracma)
  
route_convexity$radius = curvatures(lag(route_convexity$Midpoint_X), 
                                    route_convexity$Midpoint_X,
                                    lead(route_convexity$Midpoint_X),
                                    lag(route_convexity$Midpoint_Y),
                                    route_convexity$Midpoint_Y,
                                    lead(route_convexity$Midpoint_Y)
                                    )
```

Rally pace note systems tend to use a simpler numbering system to represent curvature which may be modeled by mapping the radius of curvature values to a discrete set of binned corner numbers. The [`base::cut()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/cut) *R* function allows us to perform this mapping using custom bin widths and ordered bin labels.

In the following example, we use the 10 point *turn severity* scale and associated radius of curvature values suggested in [*To see the invisible ( (Volume 1)*](http://therallydriver.com/index.php/en/to-see-the-invisible); low values represent smaller radius of curvature values and hence tighter corners.  Note that we further are labeling straights as category 11 curves.

```{r}
invisible_bins = c(0, 10, 15, 20, 27.5, 35,
                    45, 60, 77.5, 100, 175, Inf)

route_convexity$invisible_ts = cut(route_convexity$radius,
                                   breaks = invisible_bins,
                                   labels = 1:(length(invisible_bins)-1),
                                   ordered_result=TRUE)
```

Let's preview the values:

```{r}
head(route_convexity[,c('ConvexityIndex',
                        'radius', 'invisible_ts')])
```

We can visualise the turn severity values at each 10m sample point along the route:

```{r radius-example}
radius_filter = route_convexity$radius>0 & route_convexity$radius<100

ggplot() + geom_sf(data=utm_routes[1,], color='grey') +
  geom_point(data=route_convexity[radius_filter,],
             
            aes(x=Midpoint_X, y=Midpoint_Y,
                color=invisible_ts), size=0.5)
```

### Percentage in Turn

A really crude metric of how severe the amount of turning is over the duration of a stage might be indicated by the root mean square of the curvature:

```{r}
rms = function(x) sqrt(mean(x^2))

rms(route_convexity$ConvexityIndex)
```

Another possible measure would be the percentage of time in turn, relative to a minimum amount of curvature (or maximum radius of curvature).

For example, we can count the number of segments for which the convexity index is above a particular threshold:

```{r}
pc_in_turn_convexity = function(route, min_convexity=0.1) {
   sum(route$ConvexityIndex > min_convexity) / nrow(route)
}

pc_in_turn_convexity(route_convexity)
```

Alternatively, we might calculate the percentage of segments for which the radius of curvature is less than some maximum value:

```{r}
pc_in_turn_curvature = function(route, max_curvature=80) {
   sum(route$radius < max_curvature) / nrow(route)
}

pc_in_turn_curvature(route_convexity)
```

Another more segmented profile could give the percentage time per turn severity:

```{r}
turn_severity = route_convexity %>%
                  group_by(invisible_ts) %>% 
                  summarise(n = n())

turn_severity$n  = turn_severity$n / nrow(route_convexity)
```

For the non-straight sections, we can plot their distribution:

```{r pc_in_turn_severity_bar}
ggplot(turn_severity[turn_severity$invisible_ts < 11,]) +
  geom_bar(aes(x=invisible_ts, y=n),
           stat='identity')
```

We can also compare the percentage of segments spent on the straight against the percentage involved in some sort of turn: 

```{r pc_in_turn}
pc_in_turn = route_convexity %>%
                  # Create a logical group
                  group_by(in_turn = invisible_ts<11) %>% 
                  summarise(n = n())

pc_in_turn$n  = pc_in_turn$n / nrow(route_convexity)

ggplot(pc_in_turn) +
  geom_bar(aes(x=in_turn, y=n),
           stat='identity')
```


## Estimating Speeds

As well as providing an estimate of turn severity and identifying straights, we can also use the radius of curvature, or the turn severity index, as a crude estimate of maximum speed along that segment. Once again volume 1 of the *To see the invisible* pacenotes tutorial provides some example speeds for each turn intensity value, noting that speeds are likely different on sealed tarmac surfaces or unsealed gravel surfaces:

```{r}
# Speeds in km/h
invisible_speeds = c(10, 40, 50, 60, 70, 80,
                     95, 110, 120, 130, 145)
```

We can use these speeds to model (very crudely!) expected travel times along different parts of the route, or at least provide a crude baseline estimate, as well as a crude estimate over the overall average route speed, which is often regulated under rally competition regulations.

```{r}
route_convexity$invisible_sp = cut(route_convexity$radius,
                                   breaks = invisible_bins,
                                   labels = invisible_speeds,
                                   ordered_result=TRUE)

# Cast speed as factor, via character, to integer
route_convexity$invisible_sp = as.integer(as.character(route_convexity$invisible_sp))

head(route_convexity[,c('ConvexityIndex', 'radius',
                        'invisible_ts', 'invisible_sp')])
```

From the speed estimates, can we then perform a crude time estimate for the stage time, assuming infinite acceleration and deceleration? (This may turn out to be not very realistic at all, of course!)

For each segment, identify the segment transit time as the length of the segment divide by the speed:

```{r}
route_convexity$invisible_time = 10/ (route_convexity$invisible_sp * 1000 /3600)

duration = sum(route_convexity$invisible_time) 
paste0(duration %/% 60, 'm', round(mod(duration, 60),1), 's' )
#11m5s
# Actual stage time: 12:05.7	
# via https://www.ewrc-results.com/results/41079-rallye-automobile-de-monte-carlo-2021/?s=293051
# Difference: (11*60+5) / (12 * 60 + 5)  = 0.917 so ~9% error?
```

A better approach would be to try to model acceleration and evolve the speed across each segment.

A crude acceleration model might look to accelerate up into a faster segment, and decelerate down into a slower one:

```{r}
sp = route_convexity$invisible_sp
sp[1] = 30 # nominal starting speed

# Crude acceleration / brake weights
acc = 1
dec = 1
for (i in 2:(length(sp)-1)) {
  # Accelerate up
  if (sp[i-1]<=sp[i]) sp[i] = (sp[i-1] + acc * sp[i]) / (1+acc)
                                  
  # Decelerate down
  if (sp[i]>sp[i+1]) sp[i] = (dec * sp[i] + sp[i+1]) / (1+dec)
}

route_convexity$acc_sp = sp
route_convexity$acc_sp[length(sp)] = route_convexity$invisible_sp[length(sp)]

head(route_convexity[,c('invisible_sp','acc_sp')])
```

And the new time model?

```{r}
route_convexity$invisible_time2 = 10/ (route_convexity$acc_sp * 1000 /3600)

duration2 = sum(route_convexity$invisible_time2) 
paste0(duration2 %/% 60, 'm', round(mod(duration2, 60),1), 's' )
# 12m9.1s
# Difference: (12*60+9) / (12 * 60 + 5)  = 1.006 so minimal % error?
```

<!--chapter:end:route-metrics.Rmd-->

```{r cache = T, echo = F, message=F}
# 6Allow knitr to continue to execute even in the presence of errors
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/revisiting-elevation-")
```
# Elevation Data Revisited

Having access to elevation data is essential for rendering 3D terrain maps. But we can also plot elevation data along a single dimension: the *distance along route*.

For winter mountain rallies, such as Monte Carlo, elevation data may be important when estimating temperature drops along a stage caused by elevation changes, and hence the likelihood, or otherwise, of snow. (Shadow models and the time of day a stage is running, as well as the weather conditions, may also play into that).

When planning hill climbs, or rally stages that perhaps involve electric vehicle competitors, a good understanding of elevation changes, and potential energy requirements resulting from climbs, may also be important,

[*Rally Maps*](https://www.rally-maps.com/Rallye-Monte-Carlo-2021/Saint-Disdier-Corps) routes come with elevation profiles of this sort, and stage reports for major cycling races such as *le Tour de France* are rarely complete with a stage elevation maps show the *cols* to be encountered along the route. The [`cyclingcols.com`](https://www.cyclingcols.com/col/HolmeMoss) website demonstrates several interesting ways of analysing cycling *cols*.

So can we produce our own elevation profiles from the stage route and elevation data? We surely can...

*Elevation along route profiles are extracted from an elevation raster. Note that we can also extract shadow along route information from a shade raster generated for a particular data and time of day.*

## Load in Base Data 

As ever, let's load in our stage data and the elevation raster and create a demo map:

```{r message=FALSE}
library(sf)
library(raster)
library(rayshader)

geojson_filename = 'montecarlo_2021.geojson'
geojson_sf = sf::st_read(geojson_filename)
stage_route_gj = geojsonio::geojson_json(geojson_sf[1,]$geometry)

# Previously downloaded buffered TIF digital elevation model (DEM) file
stage_tif = "buffered_stage_elevation.tif"

# Load in the previously saved image raster
elev_img = raster(stage_tif)

# Note we can pass in a file name or a raster object
elmat = raster_to_matrix(stage_tif)

demo_map = elmat %>%
              sphere_shade(texture = "desert", progbar = FALSE)

```

## Generating Elevation Maps

With the geo data provided for the stage route, we only have access to the latitude and longitude of each point along the route, *not* the elevation.

We have already seen how we can create a route layer that we can overlay on the 3D model, with the elevation then inferred so that the route is plotted correctly on the 3D rendered model. But can we access the actual elevation values along the route somehow?

### Accessing Elevation Values Along a Route from an Elevation Raster

The elevation raster provides an elevation value for each pixel in the raster image. We can transect the raster with a route to get the elevation value for each point along the route.

To get a routepoints list, we can extract the coordinates from a linestring geometry, casting the result to a dataframe and then selecting just the X (longitude) and Y (latitude) values:

```{r}
routepoints = subset(as.data.frame(st_coordinates(geojson_sf[1,])),
                     select = c('X', 'Y'))
head(routepoints)
```

We can add a Z (elevation) column to the dataframe by extracting the elevation at each point (that is, for each row of the dataframe) from the elevation raster image:

```{r}
routepoints$elevation = raster::extract(elev_img, routepoints)
head(routepoints)
```

Finding the minimum and and maximum altitude along the route is trivial:

```{r}
c(max(routepoints$elevation, na.rm=T), min(routepoints$elevation, na.rm=T))
```

### Using `geosphere::distGeo` to Find Distance Along a Route

We can use the `geosphere::distGeo()` function to calculate distance in meters between each point under the WGS84 projection without having to first convert to a projection with units of meters.

The function returns the distance between consecutive locations, with a null value returned for the final step. If we want to back refer distances — how far since the last point, rather than how far to the next point — we can drop the last `NA` distance and prepend a distance of `0` to the start of the list of distances:

```{r}
stage_coords = st_coordinates(geojson_sf[1,])[,c('X','Y')]
stage_step_distances = geosphere::distGeo(stage_coords)

# The last step distance is NA, so drop it
# Also prepend the distances with 0 for the first step
routepoints$gs_dist = c(0, head(stage_step_distances,-1))
routepoints$gs_cum_dist = cumsum(routepoints$gs_dist)

head(routepoints)
```

We can now preview the elevation against the distance along the route:

```{r gg-routepoints, message=FALSE}
library(ggplot2)

ggplot(routepoints, aes(x=gs_cum_dist, y=elevation)) + geom_line()
```

### Using `sp::spDists` to Find Distance Along a Route

The `sp::spDists` function also allows us to find the distance between *Spatial* point WPS84 / longlat projected points in meters without first having to convert the points to a projection with units of meters. The function returns the "step" distance as well as the accumulated distance:

```{r}
# Find the distance between points in two lists of coordinates
distances = sp::spDists(rbind(stage_coords[1,], stage_coords),
                        stage_coords,
                        longlat = TRUE)

# Extract the step and accumulated distances in km
# and convert to meters
routepoints['sp_cum_dist'] = distances[1,] * 1000
routepoints['sp_dist'] = distances[2,] * 1000

head(routepoints)
```

Note that the actual distances calculated vary slightly depending on the internals and settings used in the function used to calculate them. The numbers are close enough for storytelling!

## Generating a 3D Ribbon Plot of the Stage Route

A `ggplot2::geom_ribbon()` plot provides a familiar way of rendering the elevation plot in the form a line chart with a fill that extends down to the x-axis:

```{r gg-elevation}
library(ggplot2)

# Find a nice minimum elevation
min_elevation = max(0, 100*round(((min(routepoints$elevation)/100)-1.6)))
max_elevation = max(routepoints$elevation)

g = ggplot(routepoints, aes(x = gs_cum_dist)) +
      geom_ribbon(aes(ymin = min_elevation,
                      ymax = elevation),
                  fill = "#1B9E77") + 
      labs(x = "kilometers", y = "Elevation") +
      scale_y_continuous(limits = c(min_elevation, max_elevation))

g
```

We can get a 3D plot from the ribbon chart via the `rayshader::plot_gg()` function:

```{r 3d-ribbon-widget}
options(rgl.useNULL = TRUE,
        rgl.printRglwidget = TRUE)

rgl::clear3d()
plot_gg(g, height=5, width=6, scale=500, raytrace=FALSE)

rgl::rglwidget()
```


## Identifying Road Type

The OSM highways data often includes information about road class. We can use this information to add an aesthetic to the line that distinguishes the road class along the route, either by color or by width.

```{r}
#Precautionary measure to clean the data
routepoints = routepoints %>% tidyr::drop_na('elevation')

# Create a min colour value 10% of the max-min range below the min value
min_val = min(routepoints$elevation) - 0.1 * (max(routepoints$elevation) -  min(routepoints$elevation))
```

We can use the `ggplot2::coord_sf(crs=st_crs(geojson_sf))` function to allow us to a non-spatial dataframe containing latitude and longitude coordinates in a spatial way:

```{r gg-path}
# We need to use the geom_path to render the route
# geom_line will plot against ordered, not consecutive, x and y
g2 = ggplot(routepoints, aes(x=X, y=Y, color=elevation))+
  geom_point(size=3) +
  geom_path(size=3.5) +
  
  # Set the coordinate system to the original projection
  coord_sf(crs=st_crs(geojson_sf)) +
  
  lims(color=c(min_val, max(routepoints$elevation)))

g2
```

It might also be interesting to explore a line width setting to reflect the likely width of the road. For example, we might image A roads to nominally have a width of 8m, enough for two cars to pass one another, B class roads to have a width of 6m (a close squeeze) and C roads or other tracks to have a width of 4m (single track road).
 
## Displaying Route Twistiness and Elevation

The 3D rendered ribbon chart is amusing, but not necessarily very informative. What would be far more compelling would be if we could render elevation and also the twists and turns take by the route.

So let's do that in the form of a plot of elevation against latitude and longitude:

```{r message=FALSE}
rgl::clear3d()

gg = plot_gg(g2, height=5, width=6, scale=500,
             raytrace=FALSE)

r = rgl::rglwidget()

widget_fn = 'elev_model.html'
htmlwidgets::saveWidget(r, widget_fn)
```

Embed the HTML back in an iframe:

```{r}
htmltools::includeHTML(widget_fn)
```

### Making a 3D Print File of the Model

As well as making movies of the stage route it is also worth reminding ourselves that we can also export the model as a 3D printer ready model. The `rayshader::save_3dprint()` function will export an `.stl` format model file directly from our model:

```{r}
# We can also save the file to a 3d print stl file
model_fn = "stage_3d.stl"
save_3dprint(model_fn, maxwidth = 10, unit = "in")
```

With model file in hand,it can then be uploaded to 3D print on demand service such as [*3dpeople*](https://www.3dpeople.uk/), [*3d print UK*](https://www.3dprint-uk.co.uk/), [*MakeitQuick Manufacturing*](https://makeitquick.co.uk/orders/) or [*Champion 3D*](https://champion3d.com/) to provide us with a physical model of a stage.

### Rendering a 3D movie of the Model

Render a 3D movie to provide a rotating view of the 3D rendered line char showing the route path and elevation:

```{r elevation-movie, message=FALSE, warning=FALSE}
library(av)

options(rgl.useNULL = FALSE,
        rgl.printRglwidget = FALSE)

rgl::rgl.open()
rgl::clear3d()

g = plot_gg(g2 + theme(legend.position = "none"),
            height=5, width=6, scale=500,
            raytrace=FALSE)

# 3D movie
video_fn = 'demo_stage_line.mp4'

#render_movie(video_fn, progbar=FALSE)
rgl::rgl.close()

embedr::embed_video(video_fn, type ="mp4",
                    width = "256", height = "256")
```


## Using the `slopes` Package to Analyse Stage Elevation Data

Having got the elevation profile as elevation by distance into stage, we can borrow some ideas from the chapter on route profiling to try to identify certain features in the route, for example in terms of gradient or even "elevation-twistiness" of a climb / descent.

The [`slopes` *R* package](https://github.com/ITSLeeds/slopes) simplifies obtaining elevation data considerably, and provides an easy way to visualise slopes and steepness as well as packaging various functions relate to the ones we developed in the previous sections.

For example, the `slopes::slope_3d()` function takes a route linestring and a raster and adds the elevation as the Z coordinate to the linestring:

```{r}
library(slopes)

route_slope_elevation = slope_3d(geojson_sf[1,], elev_img)
```

There is also automated support for finding elevation data from a route by omitting the raster data when calling the `slopes::slope_3d()` function with just the linestring.

The `slopes::plot_slope()` function visualises the gradient at each step along the 3D linestring route using base graphics:

```{r slopes_plot_slope}
plot_slope(route_slope_elevation)
```

Within the `slopes` package are several utility function for extracting step distance, elevation and gradient along the route:

```{r}
route_coords = sf::st_coordinates(geojson_sf[1,])
# lonlat: is the order lonlat?
d = sequential_dist(route_coords, lonlat = TRUE)
```

We can get the elevation for each line segment in the linestring using the `slopes::elevation_extract()` function:

```{r}
e = elevation_extract(route_coords, elev_img)
```

Simple plot:

```{r slopes_df_plot_elev}
slopes_df = data.frame(d=c(0,d), e=e)

# Find the accumulated distanced over route steps
slopes_df$cum_d = cumsum(slopes_df$d)

ggplot(slopes_df)+geom_line(aes(x=cum_d, y=e))
```

We can get slope associated with each line segment using the `slopes::slope_distance()` function, or from the 3D linestring using the `slopes::slope_matrix()` function. (The *lonlat* parameter flags the order of longitude and latitude values.)

```{r}
step_gradients = slope_distance(d, e) # d is 1 item shorter than e
step_gradients2 = slope_matrix(st_coordinates(route_slope_elevation),
                               lonlat = TRUE)
```

## Analysing Route Elevation from First Principles

The simplest thing to calculate is probably gradient, which tells us how steep an incline / descent is at any part of the stage, as well as as where the turning points (in gradient terms) are: crests and plateaus, for example.

```{r simple-elevation-gradient}
ggplot(routepoints, aes(x=gs_cum_dist)) + geom_line(aes( y=elevation)) +
  geom_line(aes( y=1000*pracma::gradient(elevation, gs_cum_dist)), color='red')
```

Areas where the gradient is greater than show the route is climbing; where the gradient is less than one shows a descent. A gradient near zero is on the flat.

We might get a slightly cleaner trace if we smooth the elevation profile and then find its gradient.

```{r smoothed-elevation-gradient}
trj <- TrajFromCoords(routepoints[,c('gs_cum_dist', 'elevation')])
smoothed <- trajr::TrajSmoothSG(trj, p=3, n=9)

smoothed['y_gradient'] = 1000*pracma::gradient(smoothed$y,smoothed$x)
ggplot()+geom_line(data=routepoints,aes(x=gs_cum_dist, y=elevation)) +geom_line(data=smoothed, aes(x=x, y=y), color='red') +
  geom_line(data=smoothed, aes(x=x, y=y_gradient), color='blue')
```

Another technique we might use to display the data is to create coloured bands, as per a ribbon plot, coloured according to the whether the gradient is positive or negative, using the magnitude of the gradient to set the colour intensity as per a heat map.

```{r smoothed-elevation-gradient-filled}
smoothed$col[smoothed$y_gradient >= 0] <- "climbing"
smoothed$col[smoothed$y_gradient < 0] <- "descending"

# Doing something wrong with the fills here?
ggplot(smoothed, aes(x=x, y=y_gradient)) +
  geom_area(aes(fill=col)) +
  geom_line() +
  geom_hline(yintercept=0)

# geom_ribbon has the same issue
```

<!--chapter:end:revisiting-elevation.Rmd-->

```{r cache = T, echo = F, message=F}
# 17Allow knitr to continue to execute even in the presence of errors
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/adding-osm-data-")
```
# Adding *OpenStreetMap* Data

As well as providing online interactive maps and acting as a source for open map tiles, *OpenStreetMap* also makes available a wide range of datasets, including labeled shapefiles for roads as well as buildings.

The [`ropensci/osmdata` *R* package](https://github.com/ropensci/osmdata) provides a convenient way of download OpenStreetMap data into an R simple features object.

*For downloading large datasets that time out when making `osmdata` calls, use the [`ropensci/osmextract` R package](https://github.com/ropensci/osmextract).*


## Load in Base Data 

As ever, let's load in our stage data:

```{r message=FALSE}
library(sf)
geojson_filename = 'montecarlo_2021.geojson'
geojson_sf = sf::st_read(geojson_filename)

# Get stage bounding box
stage_bbox = st_bbox(geojson_sf[1,])

#Simplify geometry access
stages_kml = geojson_sf$geometry
```

And also load in the elevation data raster:

```{r message=FALSE, warning=FALSE}
library(raster)
library(rayshader)

# Previously downloaded TIF digital elevation model (DEM) file
stage_tif = "stage_elevation.tif"

# Load in the previously saved image raster
elev_img = raster(stage_tif)
auto_zscale = geoviz::raster_zscale(elev_img)

# Note we can pass in a file name or a raster object
elmat = raster_to_matrix(stage_tif)
```

Create a base `rayshader` 2D map:

```{r}
# Add water
watermap <- detect_water(elmat, progbar = FALSE, zscale = 8)

# Add shadows
shadow_layer = height_shade(elmat) %>% 
  add_overlay(sphere_shade(elmat, texture = "desert",
                           progbar = FALSE,
                           zscale=auto_zscale, colorintensity = 5), alphalayer=0.5) %>%
  add_shadow(lamb_shade(elmat,zscale = auto_zscale),0) %>%
  add_shadow(texture_shade(elmat,detail=8/10,contrast=9,brightness = 11), 0.1)

demo_map = elmat %>%
              add_overlay(shadow_layer)  %>% 
              add_water(watermap, color = "desert")
```

## Adding Detail and Features from OpenStreetMap

We can download data from the *OpenStreetMap* [Overpass API](https://wiki.openstreetmap.org/wiki/Overpass_API) using another of the `rspatial` Github organisation packages: the `osmdata` package [[docs](https://docs.ropensci.org/osmdata/)].

Requests can be made using the `osmdata::opq()` ("Overpass query") function for tiles covering an area specified by a bottom-left/top-right bounding box with coordinates specified in latitude/longitude degrees.

Requests take the form:

- `opq(BOUNDING_BOX) + add_osm_feature(REQUESTED_DATA) + osmdata_sf()` to return data as a simple features (`sf`) object;
- `opq(BOUNDING_BOX) + add_osm_feature(REQUESTED_DATA) + osmdata_sp()` to return data in as a `spatial features`Spatial` (`sp`) object.

We *could* manually obtain the bounding box co-ordinates by applying the `raster::extent()` function to a bounding box `bbox` object obtained from a spatial object using `sf::st_bbox()`:

```{r}
stage_extent = extent(stage_bbox)

#long_min, lat_min, long_max, lat_max
osm_stage_bbox = c(attr(stage_extent, 'xmin'), attr(stage_extent, 'ymin'),
                   attr(stage_extent, 'xmax'), attr(stage_extent, 'ymax'))

```

To pass the bounding box coordinates into the `opq()` function explicitly, they should be presented in the order: `min_long, min_lat, max_long, max_lat`. However, it's far more convenient to just pass a `bbox` object to the `opq()` function directly: `opq(stage_bbox)`.

As for the data we want to retrieve from the Overpass API, let's grab the "highway" data, which returns routes for a wide range roads and paths in the specified area:

```{r simple-stage-osm}
library(osmdata)

# Recall that: stage_bbox = sf::st_bbox(geojson_sf[1,])
stage_osm  = opq(stage_bbox) %>% 
  add_osm_feature("highway") %>% 
  osmdata_sf()

stage_osm
```

The routes themselves can be indexed via the `$osm_lines` dataframe in the returned object.

```{r}
stage_lines = stage_osm$osm_lines

class(stage_lines)
```
 
Let's review the data frame column names:

```{r}
names(stage_lines)
```

The line data is contained in the *geometry* and the *highway* describes the road type. Let's see what sorts of road data we have retrieved by listing the unique items contained in the *highway* column:

```{r}
unique(stage_lines$highway)
```

From the column names, we also notice several other columns that look as if they might be able to provide us with information that might help us classify what the actual stage route is like: *smoothness*, *surface*, *width*, *maxspeed*, *incline*. On inspection, the data suggests a lot of empty fields: the most useful fields are probably just the 'highway' and perhaps the 'surface' columns:

```{r}
# Cast the simple features object to a dataframe, select the
# columns of interest and then use a list apply to apply the unique 
# function to each of the selected columns
lapply(as.data.frame(stage_lines)[c('highway', 'surface')], unique)
```

### Plotting OSM Highways

To get an idea of the extent of the "highways" in the bounding box area, we can plot the spatially represented lines using an appropriate projection. The lines might informatively be colored by *surface* type, or as in the following case, *highway* type:

```{r gg-highways}
library(ggplot2)

ggplot(stage_lines, aes(color=highway)) + 
  geom_sf() +
  theme(legend.position = "none") +
  labs(title = "Open Street Map `highway attribute in stage extent")
```

We can remove paths, footways and other pedestrian routes and narrow down the display to road types that would appear to offer vehicular access:

```{r gg-roads}
stage_roads = stage_lines[stage_lines$highway %in% c("unclassified", "secondary", "tertiary", "residential", "service"), ] 

# Alternative way of filtering road types using a pipe operator
#stage_roads = stage_lines %>% 
#  filter(highway %in% c("unclassified", "secondary", "tertiary", "residential", "service"))

ggplot(stage_roads, aes(color=highway)) + 
  geom_sf() +
  theme(legend.position = "none") +
  labs(title = "Open Street Map `roads`")
```

## Viewing Roads in the Vicinity of a Route

There is certainly plenty of highways information returned from the Overpass query, but what if we just want to view roads close to our route?

To do this, we can create a buffered region around the route and then find the intersection of the that region and the highways lines.

The `sf::st_buffer()` will create a buffered area around a simple features object to a specified distance in the units of the projection. 

Suppose that we want to create a buffered region 200m wide around our stage route. We can define that distance, along with its units, using the  `units::set_units() function:

```{r}
buffer_margin_200m = units::set_units(200, m)
buffer_margin_200m
```

To create the buffered region (a polygon) around the stage route (a line), we need to project the latlong values, whose unit of distance is measured in *degrees* to a rectangular projection with a distance unit of *meters*.

The coordinates used in the route data are WGS84 latitude and longitude degrees. As we have done previously, we can convert the CRS to one based on units of meters, such as the UTM projection.

```{r}
lonlat2UTM_hemisphere <- function(lonlat) {
    ifelse(lonlat[1] > 0, "north", "south")
}

lonlat2UTMzone = function(lonlat) {
  utm = (floor((lonlat[1] + 180) / 6) %% 60) + 1
  if(lonlat[2] > 0) {
    utm + 32600
  } else{
    utm + 32700
  }
}

# Grab a copy of the original projection
original_crs = st_crs(geojson_sf[1,])

# Find the UTM zone for a sample a point on the route
crs_zone = lonlat2UTMzone(c(st_coordinates(geojson_sf[1,])[1,1],
                            st_coordinates(geojson_sf[1,])[1,2]))

# Create the projection string
utm_pro4_string = st_crs(crs_zone)$proj4string
#"+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs"
# units in meters e.g. https://epsg.io/32632

# Transform the route projection
utm_route = st_transform(geojson_sf[1,], crs = st_crs(utm_pro4_string))
```

### Using `sf::st_buffer` to Create Buffered Areas

We can now create the buffered area around the route using the `sf::st_buffer` function:

```{r gg-buffered-route}
buffered_route_utm <- st_buffer(utm_route, buffer_margin_200m)

buffered_route <- st_transform(buffered_route_utm, original_crs)

ggplot(buffered_route) + 
  geom_sf()                
```

Let's also save that as a shapefile:

```{r}
# st_write will try to automatically determine the file driver
# from the filename suffix
st_write(buffered_route, "buffered_route.shp")
```

We can view the roads that appear within the buffered area around a stage route by finding the intersection of the road lines and the buffered area:

```{r gg-stage-buffer-route}
roads_by_stage <- st_intersection(stage_roads, buffered_route)

ggplot() + 
  geom_sf(data=buffered_route) +
  geom_sf(data=roads_by_stage, color='red') 
```
Note that we actually get a warning: *although coordinates are longitude/latitude, st_intersection assumes that they are planar*. So we really should have projected the roads into UTM and done the intersection using that CRS:

```{r gg-stage-buffer-route2}
stage_roads_utm = st_transform(stage_roads,
                               crs = st_crs(utm_pro4_string))

roads_by_stage_utm <- st_intersection(stage_roads_utm, buffered_route_utm)
#although coordinates are longitude/latitude, st_intersection assumes that they are planar, so we really should project into something else

ggplot() + 
  geom_sf(data=buffered_route_utm) +
  geom_sf(data=roads_by_stage_utm, color='red') 
```

### Using `rgeos::gBuffer` to Create Buffered Areas
 
Alternatively, we can create a buffered area using the `rgeos::gBuffer()` function, this time applied to a projected *Spatial* object with units of meters.

For example, we can buffer our stage roads in their UTM (units of meters) projection:

```{r gg-roads-buffer}
buffered_roads = rgeos::gBuffer(as(stage_roads_utm, 'Spatial'),
                                 width=200)

# ggplot expects a simple features, rather than Spatial, object
ggplot(st_as_sf(buffered_roads)) + 
  geom_sf() +
  # Tweak the presentation angle of the x-tick labels
  theme(axis.text.x = element_text(angle = 45))
```

## Adding Additional Data From OSM

As well as highways data, *OpenStreetMap* also provides data on a wide range of other features.
  
For example, we can identify *waterways*:

```{r}
stage_water_lines = opq(osm_stage_bbox) %>% 
  add_osm_feature("waterway") %>% 
  osmdata_sf() 

stage_waterways = stage_water_lines$osm_lines
```

Let's preview those to see how they extends in our bounded box area:

```{r gg-waterways}
ggplot(stage_waterways) + 
  geom_sf(color='blue') +
  geom_sf(data=stages_kml[1], color='red') +
  theme(legend.position = "none") +
  labs(title = "Open Street Map `waterways`")
```
*One thing to note about this plot is that data has been returned for an area that exceeds the extent of our request.*

We can create a `rayshader` layer for the waterways that we can then add as another overlay to a rendered map:

```{r}
waterways_layer = generate_line_overlay(stage_waterways,
                                        extent = stage_extent,
                                        heightmap = elmat,
                                        color="skyblue2",
                                        linewidth = 2)
```

Let's also create a new route layer, this time in red:

```{r}
# Generate a route layer in red
red_route = generate_line_overlay(geojson_sf[1,],
                                    extent = stage_extent,
                                    heightmap = elmat,
                                    linewidth = 5, color="red")
```

Create a roads layer:

```{r}
roads_layer = generate_line_overlay(stage_roads, extent = stage_extent,
                                    color="yellow",
                                    heightmap = elmat)
```

Adding the waterway layer to the map potentially allows us to read additional detail into it. For example, a waterway under a highway presumable means a bridge (or a ford), and may also mean "narrows" or "care"...

```{r map-roads}
demo_map %>%
  add_overlay(waterways_layer)  %>%
  add_overlay(roads_layer)  %>%
  add_overlay(red_route) %>%
  plot_map()
```

The waterway plotted over the water map area looks a bit odd, but we could address that by changing the layer order: layers are placed on top of each other in the order we present them, so all we need to do is overplot
the waterways by the watermap, rather than the plotting the waterways over the watermap:

```{r map-rich}
rich_map =  elmat %>%
              add_overlay(shadow_layer) %>%
              add_overlay(waterways_layer) %>%
              add_overlay(roads_layer) %>%
              add_overlay(red_route) %>%
              add_water(watermap, color = "desert")

rich_map %>%
  plot_map()
```

### Adding Building Layers from *OpenStreetMap*

Another class of feature that we seen on certain map tiles, and that may be useful to add directly to map layers, are building outlines. In a rally stage, buildings may add to the hazard or otherwise help us get an feel for what a particular part of a stage is like.

We can download building outlines from the OSM Overpass API by requesting feature objects of type *building*.

The objects of interest to us are the building outline polygons:

```{r}
stage_buildings_polygons = opq(osm_stage_bbox) %>% 
  add_osm_feature("building") %>% 
  osmdata_sf() 

stage_buildings = stage_buildings_polygons$osm_polygons
```

Let's quickly plot those to see how they look:

```{r gg-buildings}
ggplot() + 
  geom_sf(data=stage_buildings,) +
  geom_sf(data=stages_kml[1], color='darkgrey') +
  theme(legend.position = "none") +
  labs(title = "Open Street Map `buildings`")
```

As before, we can create a layer from the OSM polygons data that we can add to a `rayshader` rendered view:

```{r}
buildings_layer = generate_polygon_overlay(stage_buildings, 
                                           extent = stage_extent,
                                           heightmap = elmat,
                                           palette='darkred')
```

Now add the buildings layer to the map:

```{r map-buildings}
rich_map %>%
  add_overlay(buildings_layer) %>%
  plot_map()
```

### The Wide Variety of OSM Features

Another feature that might be useful to stage planners is locating any car parks in the area using the `add_osm_feature("parking")` feature. The `add_osm_feature("tourism")` feature also identifies a range of "touristy" features, such as *picnic_site*, *camp_site*, *information* and *viewpoints* elements, returning a combination of polygons and points.

```{r}
tourism = opq(osm_stage_bbox) %>% 
  add_osm_feature("tourism") %>% 
  osmdata_sf()

unique(tourism$osm_points$tourism)
```

We can filter on selected tourist feature types:

```{r}
tourist_points = tourism$osm_points %>% 
  dplyr::filter(tourism %in% c("picnic_site", "camp_site", "viewpoint"))

head(tourist_points)
```
And then plot them relative to our stage route:

```{r gg-tourism}
ggplot() + 
  geom_sf(data=tourist_points, aes(color=tourism)) +
  geom_sf(data=stages_kml[1]) +
  #theme(legend.position = "none") +
  labs(title = "Open Street Map tourism")
```

*See the `rayshader` tutorial on [*Tutorial: *Adding Open Street Map Data to Rayshader Maps in R*](https://www.tylermw.com/adding-open-street-map-data-to-rayshader-maps-in-r/) for more examples.*

<!--chapter:end:adding-osm-data.Rmd-->

```{r cache = T, echo = F, message=F}
# 29Allow 2 knitr to continue to execute even in the presence of errors
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/stage-description-")
```
# Automatically Generating Stage Descriptions

Having annotated each line segment that makes up a rally stage route, can we use that information to help us create visual or even written, descriptions of a stage?

In terms of categorising turns in a way that's meaningful in a rally context, let's have a recap on what sorts of thing a rally navigator or co-driver is likely to be saying:

```{r rally-notes-codriver}
embed_url("https://www.youtube.com/watch?v=KFjRj25uclQ")
```

And let's review what we actually mean by a corner...

```{r chain-bear-corner-video}
embed_url("https://www.youtube.com/watch?v=YXOYckDATWE")
```

In terms of actual corners, the convexity interesting may be one of the more interesting properties. Finding a good way of representing variable radius turns (you did watch the "corners" video, didn't you?!) will also be important if we want to be able to identify "tightens" or "lessens" (that is, "opens") corner features. Any elevation changes in the vicinity of a corner are likely to be important if we are trying to characterise braking zone requirements...

## Jemba Inertia Notes System

In a section entitled *Using data to assess the suitability of a special stage*, the [*FIA Rally Safety Guidelines 2020*](https://www.fia.com/sites/default/files/2printable_rally_safety_guidelines_1.pdf) suggest that as well as using historic information, the "Jemba System" for recording terrain data, including "the inclines, the dips, the bends and crests". By also taking the road terrain (for example, gravel or asphalt) into account, and likely car classes, average speeds over the stage as well as highest speed  and heaviest braking areas can also be determined. THe system [can also report](https://jemba.se/inertia.htm) the *margin for critical braking dist before stop* ("how far you may carry on at competitive speed until you have to start braking to be able to stop at the stop control") and the Jemba Safety Index (J/kg), the average kinetic energy of a car going through the corners.

The FIA Safety Guidelines illustrate how speeds might be visualised over a Google Earth map using a three colour scale (purple:over 150kph; red: over 90kph; yellow – 7590kph). The report also suggests that the Jemba system can predict the maximum cornering speed for any particular bend.

A Wikipedia page describing the [*Jemba Inertia Notes System*](https://en.wikipedia.org/wiki/Jemba_Inertia_Notes_System) gives examples of the descriptive and numerical labels that the Jemba system can generate as it converts odometry and accelerometer data into something rather more human understandable. A [visual grading](http://www.jemba.se/GradeUSA.jpg) shows how descriptive labels correspond to turn angle.

## Generating Stage Descriptions

Being able to display route profiles on a map as colour highlighted routes is very useful and could be made more so adding the data to a *leaflet.js* extension such as [`Leaflet.Heightgraph`](https://github.com/GIScience/Leaflet.Heightgraph), which displays arbitrary traces (to integrate this in the current workflow properly would require the development of an extension to the *R* `leaflet` package).

Another possibility would be to try to automate the creation of text based route descriptions ("robot journalism"), which I've crudely explored in other contexts elsewhere. The [*It Gets Faster Now*](https://itgetsfasternow.com/2021/01/19/route-preview-rallye-monte-carlo-2021/) blog publishes stage descriptions for WRC stage routes, so this could be a good place to learn tropes from.

## Load in Base Data 

As ever, let's load in our stage data and the elevation raster and create a demo map:

```{r message=FALSE}
library(sf)
library(raster)
library(rayshader)

geojson_filename = 'montecarlo_2021.geojson'
geojson_sf = sf::st_read(geojson_filename)

stage_route_gj = geojsonio::geojson_json(geojson_sf[1,]$geometry)

# Previously downloaded TIF digital elevation model (DEM) file
stage_tif = "stage_elevation.tif"

# Load in the previously saved image raster
elev_img = raster(stage_tif)

# Note we can pass in a file name or a raster object
elmat = raster_to_matrix(stage_tif)

demo_map = elmat %>%
              sphere_shade(texture = "desert",
                           progbar = FALSE)
```

Let's also get a UTM projection of the stage routes:

```{r message=FALSE, warning=FALSE}
# Detect the UTM zone as an EPSG code
lonlat2UTMzone = function(lonlat) {
  utm = (floor((lonlat[1] + 180) / 6) %% 60) + 1
  if(lonlat[2] > 0) {
    utm + 32600
  } else{
    utm + 32700
  }
}

get_utm_projection = function(routes){
  # Keep track of the original proj4 string
  old_crs = st_crs(geojson_sf[1,])$proj4string

  sample_location_x = st_coordinates(st_centroid(routes[1,]))[1]
  sample_location_y = st_coordinates(st_centroid(routes[1,]))[2]
  
  # Generate a new projection in the appropriate UTM zone
  crs_zone = lonlat2UTMzone(c(sample_location_x,
                              sample_location_y))

  new_proj4_string = st_crs(crs_zone)$proj4string

  # Transform the route to the UTM projection
  utm_routes = st_transform(geojson_sf, crs=new_proj4_string)
  
  utm_routes
  # Or should we returned a named list
  # e.g. including the original projection?
  #list(utm_routes = utm_routes, orig_crs=old_crs)
}

utm_routes = get_utm_projection(geojson_sf)
```

## Identifying Corners Based on `trajr` Step Gradients

Let's start by trying to identify straight sections. Trivially, given that the stage route is given by a linestring made of straight line segments arranged at different angles relative to each other, every line segment is a straight. So what we really mean by a straight is a sequence of connected lines segments where each line segment is at an angle less than +/- 5 degrees to the to segment before it, for example, where the start of the straight has a preceding segment more than +/- 5 degrees to it (for example) and the end of the straight has a following line segment at more than +/- five degrees to it.

Let's use the `trajr` *stepangle* to try to categorise straights:

```{r}
library(trajr)

trj <- TrajFromCoords(as.data.frame(st_coordinates(utm_routes[1,])))

# Remove duplicate x,y rows - assume non-crossing route]
# Should probably flag this removal via a warning
trj =  trj[!duplicated(trj[,c('x','y')]),]

# displacement is a complex number, so we can get the actual distance:
trj$distance = Mod(trj$displacement)

# Find the accumulated distance at each step
trj$cum_dist = cumsum(trj$distance)

# Step angle in radians relative to previous
trj$stepangle = c(0, TrajAngles(trj, compass.direction = NULL) * 180 / pi, NA) 

trj$cumstepangle = cumsum(c(0, TrajAngles(trj, compass.direction = NULL) * 180 / pi, NA))

trj$stepheading = c(TrajAngles(trj, compass.direction = 0)* 180 / pi, NA) 

# Find the gradient of the accumulated angle
trj$step_gradient = pracma::gradient(trj$cumstepangle, trj$cum_dist)
```

We can view the gradients:

```{r sd-preview, warning=FALSE}
g = ggplot(data=trj,
       aes(x=x, y=y)) + geom_path(color='grey') + coord_sf()

g + geom_point( size=0.2, color='blue',
             data=trj[trj$step_gradient>0.2,]) +
    geom_point(size=0.2,
               data=trj[trj$step_gradient<=-0.2,],
               color='red')
```

If we have several consecutive points with a gradient of the *same* sign, then we might consider them to be part of the same corner, albeit one that maybe tightens or opens. If the gradients of consecutive segments have a *different* sign, then we have a change of direction from e.g. left to right or right to left.

We can create a flag that identifies when the sign changes across consecutive rows of the *step_gradient* column. We can check this by lagging the contents of the *step_gradient* column by one step using the `dplyr::lag()` function and comparing its sign to the sign of the unlagged value. If we then *dplyr::lead()* the result, we can see if a change in direction happens at the end of a step:

```{r}
trj = trj %>%
  mutate(dirChange = lead(sign(step_gradient) != sign(lag(step_gradient))))

head(trj[,c('step_gradient', 'dirChange')])
```
Let's plot points on the route where we seem to have a direction change:

```{r sd-dirchange, warning=FALSE}
g +
  geom_point( size=0.2, color='blue',
             data=trj[trj$dirChange,]) +
  theme(axis.text.x = element_text(angle = 45))
```
Let's zoom in a bit:

```{r sd-dirchange-zoom}
# Zoom in on part of the route
zoom1 = trj$y>4964000 & trj$y<4965000 

g1 = ggplot(data=trj[zoom1, ],
       aes(x=x, y=y)) + geom_path(color='grey') + coord_sf()

g1 +  geom_point( size=0.2, color='blue',
             data=trj[zoom1 & trj$dirChange,]) +
      theme(axis.text.x = element_text(angle = 45))
```
We notice that we seem to be missing some corners that are perhaps not direction changes, but significant angle changes in the same direction. And we also notice a direction change flagged in what appears to be the middle of a straight.

Let's look at the apparent turn in the middle of the straight first. If we have opposing angles from one segment to the next, then we currently class the first point as a corner because the direction has changed. But we aren't really interested in slight direction changes or even slight direction changes in the same direction. 

```{r sd-straightish}
slight_gradient = 0.35
large_angle = 20

trj = trj %>% 
        mutate(straightish =  (abs(step_gradient) < slight_gradient) &
                               (stepangle < large_angle))

ggplot(data=trj[zoom1, ],
       aes(x=x, y=y)) + geom_path(color='grey') + coord_sf() +
  geom_point( size=1, aes(color = straightish)) +
  theme(axis.text.x = element_text(angle = 45))
```

We now want to identify the first node in a close sequence of nodes that identify a turn that doesn't change direction.

Which is to say we want a not straightish node whose next node is nearby and not straightish and in the same direction, or not nearby:

```{r sd-firstish}
# Close distance threshold
closeby = 25

trj = trj %>%
  mutate(nearby = (distance < closeby) ) %>%
  mutate(firstish = !straightish & 
                    ((nearby & !lag(straightish) & lag(dirChange)) |
                     (!nearby) ) )

ggplot(data=trj[zoom1, ],
       aes(x=x, y=y)) + geom_path(color='grey') + coord_sf() +
  geom_point( size=1, aes(color = firstish)) +
  theme(axis.text.x = element_text(angle = 45))
```

That's identifying some of the corners, but what's going on top left?

```{r sd-firstish-zoom}
zoom2 = zoom1 & trj$x<730100

ggplot(data=trj[zoom2,],
       aes(x=x, y=y)) + geom_path(color='grey') + coord_sf() +
  geom_point( size=1, aes(color = firstish)) +
  theme(axis.text.x = element_text(angle = 45))
```
Ah, ok, maybe we could categorise those as turns, but perhaps gentle ones. We maybe need to flag these as "flowing" if they aren't too tight and have a long run in and out:

```{r sd-flowing}
tight_gradient = 0.5

trj = trj %>%
  mutate(significant = abs(step_gradient) > tight_gradient ) %>%
  mutate(flowing = !nearby & !lead(nearby) & 
                   !straightish & !significant )

ggplot(data=trj[zoom2,],
       aes(x=x, y=y)) + geom_path(color='grey') + coord_sf() +
  geom_point( size=3, aes(color = flowing,
                          shape = dirChange)) +
  theme(axis.text.x = element_text(angle = 45))
```

We can also tweak firstish to recognise significance:

```{r}
trj = trj %>%
        mutate(firstish = (significant & !lag(significant)) |
                            (!straightish & 
                            ((nearby & !lag(straightish) & lag(dirChange)) |
                            (!nearby) ) )) %>%
        # Desensitise firstish
        mutate(firstish = firstish & !(lag(firstish)))
```

And how about over a wider part of the stage?

```{r sd-flowing2}
ggplot(data=trj[zoom1, ],
       aes(x=x, y=y)) + geom_path(color='grey') + coord_sf() +
  geom_point( size=2, aes(color = firstish,
                          shape = flowing)) +
  theme(axis.text.x = element_text(angle = 45))
```

We could also then create a *!flowing & firstish* flag to provide better indexing of the starts of corners.

We'd need to test the approach on further stages to see whether it gives false positives or false negatives on identifying various corners, and we'd maybe also want to try to identify tightens and opens.

Let's have a go at tightens. At a first approximation, a corner *tightens* if a node isn't firstish, is above a certain gradient, is close to the previous step and the magnitude of the gradient has increased and is the same sign as the previous step:

```{r sd-tightens}
trj = trj %>% 
        mutate(tightens = !firstish & significant & lead(nearby) &
                            ((sign(lead(step_gradient))==sign(step_gradient)) & (abs(lead(stepangle)) > abs(step_gradient))))


ggplot(data=trj[zoom1, ],
       aes(x=x, y=y)) + geom_path(color='grey') + coord_sf() +
  geom_point( size=2, aes(color = tightens,
                          shape = firstish)) +
  theme(axis.text.x = element_text(angle = 45))
```
The corner *opens* ("lessens") if a node isn't firstish, is above a certain gradient, is close to the previous step and the gradient is in the same direction and has decreased:

```{r sd-opens}
trj = trj %>% 
        mutate(opens = !firstish & significant & lead(nearby) &
                            ((sign(lead(step_gradient))==sign(step_gradient)) & (abs(lead(stepangle)) < abs(step_gradient))))


ggplot(data=trj[zoom1, ],
       aes(x=x, y=y)) + geom_path(color='grey') + coord_sf() +
  geom_point( size=2, aes(color = opens,
                          shape = firstish)) +
  theme(axis.text.x = element_text(angle = 45))
```

We might also try for "continues" if the angle is about the same gradient but not tightening.

## Identifying Straights

One of the important considerations when assessing a stage is identifying the fast areas of the stage represented by significant straights. So how can we identify a straight?

One way might be to define a simple rule that identifies a straight as a sequence of `straightish` segments that appear between segments that are not `straightish`.

We can create such groupings by flagging the presence of the *start* of a potential run of straightish segments. We can then number each start and propagate this run number down the following segments until the next straight segment is reached. We can then number all non-straighish elements with a "not straight" count number (e.g. *-1*). 

```{r}
trj = trj %>% mutate(startStraight = lag(!straightish, default=TRUE) & straightish) %>%
              mutate(strcount = cumsum(startStraight))

trj$strcount[!trj$straightish] = -1

head(trj[, c('straightish', 'startStraight', 'strcount', 'distance')],
     n=10)
```

Having identified straights, we realise that what we are actually interested in are *long* straights. The length of each straight can be found by grouping segments by straight number and summing the distances of segments within each group:

```{r}
straight_lengths = trj %>% 
                        # We only want straightish segments...
                        dplyr::filter(strcount>=0) %>%
                        # Group by straight number
                        group_by(strcount)  %>%
                        # Find the length of each straight
                        summarize(strdistance = sum(distance))

straight_lengths
```

Let's now filter our long straights, eg straights at least 200m long

```{r}
longstraights = straight_lengths %>%
                        dplyr::filter(strdistance>=200)

head(longstraights, n=3)
```

Let's see how those look:

```{r long_straights, warning=FALSE, message=FALSE}
ggplot(data=trj,
       aes(x=x, y=y)) + geom_path(color='grey') + coord_sf() +
       geom_point(data=trj[(trj$startStraight) & 
                           (trj$strcount %in% longstraights$strcount),],
                  aes(x=x, y=y), color='black', size=1) +
       geom_point(data=trj[(!trj$startStraight) & 
                           (trj$strcount %in% longstraights$strcount),],
                  aes(x=x, y=y), color='darkgrey', size=0.5) +
       geom_point(data=trj[(trj$firstish),],
                  aes(x=x, y=y), color='pink', size=0.5) +
       theme_classic() +
       theme(axis.text.x = element_text(angle = 45)) 
```

## Plotting Trajectory Segments

It will be convenient to be able ot plot segments of a trajectory for particular stretches of a route, so let's create a function that helps us do that:

```{r}
trj_segment_plot = function(trj, start, end,
                            x='x', y='y',
                            title='', fix_coords=TRUE,
                            rotate=NULL,
                            gradients=0, gradient_size=2) {
  
  # Create the route distance filter limits
  segment_filter = trj$cum_dist >= start &
                    trj$cum_dist <= end
 
  # Filter the route
  route_segment = trj[segment_filter,]
  
  if (!is.null(rotate))
    route_segment = TrajRotate(route_segment,
                               angle = rotate,
                               relative = TRUE)
  
  # Generate the stylised route plot
  g = ggplot(route_segment) +
             geom_path(aes_string(x=x, y=y)) +
             # Add a marker to show the start of the segment
             geom_point(data=head(route_segment,n=1),
                        aes_string(x=x, y=y)) +
             theme_void()

  # Add a title
  title=as.character(title)
  if (startsWith(title,'auto::')) {
    title = stringr::str_split(title,'::')[[1]][2]
    title_ = paste0(start/1000, '-', end/1000, 'km')
    if (title!='')
      title = paste(title, title_)
    else
      title = title_
  }
  
  if (title!='')
    g = g + ggtitle(title)
    
  if (fix_coords)
    g = g + coord_fixed()

  if (gradients)
    g = g+ geom_point(aes_string(x=x, y=y),
                      size=gradient_size, color='blue',
             data=route_segment[route_segment$step_gradient>gradients,]) +
    geom_point(aes_string(x=x, y=y), size=gradient_size,
               data=route_segment[route_segment$step_gradient<=-gradients,],
               color='red')
  g
}
```

We can then plot a trajectory as follows, optionally rotatint the segment to a horizontal left-right orientation:

```{r trj_segment_plot}
# Show a specified segment
trj_segment_plot(trj, 9000, 12500, title='auto::SS1', rotate=TRUE)

```

### Segmenting the Route

We can automate the production of a single chart that will display the route a section at a time. This requires segmenting the route, then for each segment, generating the plot, which we add to a list of plots.

```{r}
# The final section goes to the end of the route
trj_segment_multiplot = function(trj, i, title='',
                                 x='x', y='y',
                                 final=FALSE,
                                 segment_length = 1000,
                                 prefix_dist = 20,
                                 gradients=0, gradient_size=1,
                                 fix_coords=FALSE, rotate=NULL){
  
  # Preface the start of the stage with a 20m lead
  start_prefix = prefix_dist
  start = segment_length*(i-1)-start_prefix
  if (final) 
    end = Inf
  else
    end = (segment_length*i)
  
  trj_segment_plot(trj, start, end,  x=x, y=y,
                   title=title,
                   fix_coords=fix_coords,
                   rotate=rotate,
                   gradients=gradients, gradient_size=gradient_size)
}

# Create a list to hold each plot as a separate item
trj_segment_plots = list()

# How many kilometers does the route extend over?
length_1km = 1000
kms = floor(max(trj$cum_dist)/length_1km)

# Iterate through each kilometer
for (i in 1:kms){
  # Add each plot to the plot list
  trj_segment_plots[[length(trj_segment_plots) + 1]] <-
      trj_segment_multiplot(trj, i,
                            title=i, final=(i==kms),
                            fix_coords=TRUE, rotate=0,
                            gradients=0.2, gradient_size=1)
}
```

We can use the `ggpubr::ggarrange()` function to plot the list of individual plots as a single image:

```{r trj_1km_arrangement, warning=FALSE}
library(ggpubr)

gg = ggarrange(plotlist=trj_segment_plots,
          ncol=5, nrow=ceiling(kms/4))

annotate_figure(gg,
               top = text_grob(utm_routes[1,]$Name, color = "black",
                               face = "bold", size = 14))

```


### Numbering Corners

To make it easier to refer to corners, can we use the *firstish* flag as a way of counting corners?

```{r sd-numbered-corners, warning=FALSE}

trj_corners = trj[trj$firstish,]
trj_corners$corner_num = cumsum(trj_corners$firstish)

zoom1_corners = trj_corners[trj_corners$y>4964000 & trj_corners$y<4965000,]

ggplot(data=trj[zoom1, ],
       aes(x=x, y=y)) + geom_path(color='grey') + coord_sf() +
       geom_text(data= zoom1_corners,
              aes(x=x, y=y, label=corner_num),
              size=3) +
  theme(axis.text.x = element_text(angle = 45))
```

## Categorising Corners Using `rLFT` Convexity

The previous approach works to a certain extent with the limited dataset we tested it against but it feels rather contrived. Generally, just by *looking* at a curve we get a feel for how tight it is, rather than having to apply all sorts of decision-making rules and logical reasoning. Is there a simple metric we can use?

One approach might be to consider using *convexity* measure, such as the one provided by the `rLFT` package. Let's see how that might work using the `rLFT::bct()` (*bounded convexity tool*) function. This function finds the curvature at regular points along a track, in the following example, every 10 meters:

```{r}
library(rLFT)

stepdist = 10
window = 20
route_convexity <- bct(utm_routes[1,],
                      # distance between measurements 
                      step = stepdist,
                      window = window, ridName = "Name")

head(route_convexity)
```

Recalling the previous chapter:

```{r sd-convexity-route}
corner_conv = 0.1

tight_corners = route_convexity[abs(route_convexity$ConvexityIndex)>corner_conv,]
tight_corners_zoom1 = tight_corners$Midpoint_Y>4964000 & tight_corners$Midpoint_Y<4965000

ggplot(data=trj[zoom1, ],
       aes(x=x, y=y)) + geom_path(color='grey') + coord_sf() +
  geom_text(data=tight_corners[tight_corners_zoom1,],
                           aes(label = ConvexityIndex,
                               x=Midpoint_X, y=Midpoint_Y),
                           size=2) +
  geom_point(data=tight_corners[tight_corners_zoom1,],
             aes(x=Midpoint_X, y=Midpoint_Y,
                 color= (ConvexityIndex>0) ), size=1) +
  theme_classic()+
  theme(axis.text.x = element_text(angle = 45))
```

So the absolute convexity index can help us find corners but we still need to do some work to find find the start of a corner.

How does that top right area look?

```{r sd-convexity-zoom}
tight_corners_zoom2 = tight_corners_zoom1 & tight_corners$Midpoint_X<730100

ggplot(data=trj[zoom2,],
       aes(x=x, y=y)) + geom_path(color='grey') + coord_sf() +
  ggrepel::geom_text_repel(data=tight_corners[tight_corners_zoom2,],
                           aes(label = ConvexityIndex,
                               x=Midpoint_X, y=Midpoint_Y),
                           size=3) +
  geom_point(data=tight_corners[tight_corners_zoom2,],
             aes(x=Midpoint_X, y=Midpoint_Y,
                 color= (ConvexityIndex>0) ), size=1) +
  theme_classic()+
  theme(axis.text.x = element_text(angle = 45))
```

So we can probably apply a similar logic to previously to group these and identify the corner entry node, although we need to tweak the rules slightly so that we are identifying a corner entry node that is far from a previous tight corner node:

```{r}
cornerer = function (df, slight_conv=0.01, closeby=25){
  df %>%
    mutate(dirChange = sign(ConvexityIndex) != sign(lag(ConvexityIndex))) %>%
    mutate(straightish =  (abs(ConvexityIndex) < slight_conv)) %>%
    mutate(dist =  (lead(MidMeas)-MidMeas)) %>%
    mutate(nearby =  dist < closeby) %>%
    mutate(firstish = !straightish &
                        ((nearby & !lag(straightish) & lag(dirChange)) |
                        # We don't want the previous node nearby
                        (!lag(nearby)) ) & !lag(nearby) )
}

tight_corners = cornerer(tight_corners)
```

Let's see how it looks. We can also label nodes showing how far away the next node is:

```{r rlft-corners, warning=FALSE}
ggplot(data=trj[zoom1,],
       aes(x=x, y=y)) + geom_path(color='grey') + coord_sf() +
  ggrepel::geom_text_repel(data=tight_corners[tight_corners_zoom1,],
                           aes(label = dist,
                               x=Midpoint_X, y=Midpoint_Y),
                           size=3) +
  geom_point(data=tight_corners[tight_corners_zoom1,],
             aes(x=Midpoint_X, y=Midpoint_Y,
                 color= (firstish) ), size=1) +
  theme_classic()+
  theme(axis.text.x = element_text(angle = 45))
```

## Stage Segmenting

One of the handy things about the `rLFT::bct()` is that it can chunk the route into very short segments. This provides us with an easy way to index into the route to generate a view over a particular section.

For example, we can view the route over specific sections given a start and finish distance into the route. Note that the route will be discretised to step lengths used by the `rLFT::bct()` function and a stylised route will be approximated along step midmeasure points:

```{r example-route-section}
segment_plot = function(start, end, title='', fix_coords=TRUE) {
  
  # Create the route distance filter limits
  segment_filter = route_convexity$MidMeas >= start &
                    route_convexity$MidMeas <= end
  
  # Filter the route
  route_segment = route_convexity[segment_filter,]
  
  # Generate the stylised route plot
  g= ggplot(route_segment) +
            geom_path(aes(x=Midpoint_X, y=Midpoint_Y)) +
          geom_point(data=head(route_convexity[segment_filter,],n=1),
                     aes(x=Midpoint_X, y=Midpoint_Y)) +
            theme_void() 
  
  if (title!='')
    g = g+ggtitle(title)
  
  if (fix_coords)
    g=g+coord_fixed()
  
  g
}

# Show the first 1000m
segment_plot(0, 1000)
```

We can automate the creation of route sections every kilometer and create a list of plots, one per kilometer section:

```{r}
segment_length = 1000
step_length=10

kms = floor(max(route_convexity$MidMeas)/segment_length)

# The final section goes to the end of the route
segment_multiplot = function(i, final=FALSE){
  # Preface the start of the stage with a 20m lead
  start_prefix = 2*step_length
  start = segment_length*(i-1)-start_prefix
  if (final) 
    end = Inf
  else
    end = (segment_length*i)
  
  segment_plot(start, end, i, fix_coords=TRUE)
}

# Create a list to hold each plot as a separate item
segment_plots = list()

# Iterate through each kilometer
for (i in 1:kms){
  # Add each plot to the plot list
  segment_plots[[length(segment_plots) + 1]] <-
      segment_multiplot(i, final=(i==kms))
}
```

We can now use the `ggpubr::ggarrange()` function to display all the stage route sections in a single plot:

```{r route-by-1km-section}
ncol = 5
ggarrange(plotlist=segment_plots,
          ncol=ncol, nrow=ceiling(kms/ncol))
```

We can use a similar approach to create a more general function that will allow us to plot either the route, or generate a plot for each segment showing the convexity against distance into the segment:

```{r}
# Simple function to get a route segment
get_route_segment = function (route, start, end){
    segment_filter = route$MidMeas >= start &
                      route$MidMeas <= end
    
    route[segment_filter,]
}


segment_plot2 = function(route, start, end, title='',
                         typ='route', themevoid=TRUE){

  # Get route segment
  route_segment = get_route_segment(route, start, end)
  
  # Create plot base
  g = ggplot(route_segment)
  
  if (typ=='convexity') {
    g = g + geom_bar(aes(x=MidMeas,
                         y=-ConvexityIndex,
                         col=(ConvexityIndex>0)),
                     stat='identity', show.legend = FALSE)
  
  } else {
   # plot route
   g = g + geom_path(aes(x=Midpoint_X, y=Midpoint_Y)) +
           geom_point(data=head(route_segment, n=1),
                      aes(x=Midpoint_X, y=Midpoint_Y)) 
  }
  
  if (title!='')
    g = g + ggtitle(title)
  
  if (themevoid)
    g = g + theme_void()
  
  g
}
```

Let's see what a convexity report for the first kilometer looks like:

```{r convexity-first-km}
segment_plot2(route_convexity, 0, 1000, typ='convexity')
```

So we start off with a left (*port-red-left*!), a slight right, a straight, a right that tightens, a left, a straight, a nudge left and then end the kilometer with a tight right.

Let's remind ourselves to see if that looks about right:

```{r convexity-first-km-route-check}
segment_plot2(route_convexity, 0, 1000, typ='route')
```

We can use a similar approach before to automate the collection of multiple plots for each stretch of the stage:

```{r}
segment_multiplot2 = function(route, i, final=FALSE, typ='route'){
  start = segment_length*(i-1)-step_length
  if (final) 
    end = Inf
  else
    end = (segment_length*i)
  
  segment_plot2(route, start, end, i, typ )
}
```

We can now generate a plot of either the route sections, or the convexity based on distance into the route section:

```{r segment-convexity-bar}
segment_plots2 = list()

# Iterate through each kilometer
for (i in 1:(kms-1)){
  segment_plots2[[length(segment_plots2) + 1]] <-
    segment_multiplot2(route_convexity, i,  final= (i==kms),
                       typ = 'convexity')
}

ggpubr::ggarrange(plotlist=segment_plots2,
                  ncol=5, nrow=ceiling(kms/4))
```

At a glance, we can now start to identify segments of the route that contain particular sorts of feature.

For example, we can readily see that kilometers 12, 15 and 16 include significant straight stretches.

## Corner Severity Numbering

Although they may differ in the specifics, all rally pace note systems find some way to categorise the corner severity (also referred to as the turn intensity). Many systems use a convention that numbers corner severity with a value from 1 to 6, where 1 is the most severe and 6 is the least severe; alternatively,  [*therallydriver.com* pacenotes system](http://therallydriver.com/index.php/en/to-see-the-invisible), (which has the added benefit of being well documented in the *To See the Invisible* tutorial series published by the system's creator, David Nafría), uses a range from 1 to 10.

Variations on the following diagram are often used to illustrate how the numbers scheme applies to different severity corners.

```{r therallydriver-corner-numbers}
library(ggforce)
# ggforce::geom_arc

rallynotes = data.frame(n=1:10,
                        r=c(10, 15, 20, 27.5, 35,
                            45, 60, 77.5, 100, 175))

rallynotes_arcs <- data.frame(
  start =  -pi/2,
  end = mapply(min, 50/rallynotes$r, pi/2), 
  r = rallynotes$r,
  n = rallynotes$n
)

# Plot a representation of corner severity along the route
ggplot(rallynotes_arcs) +
  geom_arc_bar(aes(x0 = -15+r-6*n, y0 = 0, r0 = r,
                   r = r+2, start = start,
                   end = end,fill = factor(n),
                   color = factor(n)), show.legend=FALSE) +
  geom_text(aes(label=n, x=-15-6*n , y=-10),
            size=3, hjust='right') +
  coord_fixed()+
  theme_void() 
```

Note that with increasing number, the radius of curvature (that is, the radius of the circle describing the corner) also increases. This gives us one way of mapping from a measurement we can apply to a corner (such as its radius of curvature) to the turn severity number.

Two other properties of a corner that we might attempt to describe are the *length* of the corner either as a linear distance (20m, for example) or as an *angular* distance (45 degrees, for example). The "distance" might also map on to a descriptive term, such as "long", as in "long right". Descriptive terms are more ambiguous because they are normative: they assume a "standard" length corner in comparison with which a "long" corner is longer. 

```{r}
curvature = function(x,y){
  #729181.8, 729186.1, 729190.4
  #4957667 , 4957676, 4957685
  tryCatch({
    # circlefit gives an error if we pass a straight line
    # Also hide the print statement in circlefit
    pracma::circlefit(x,y)[3]
    },
    error = function(err) { 
      # For a straight, return the first co-ord and Inf diameter
      # Alternatively, pass zero diameter?
      c(x[1], y[1], Inf)[3]})
}

curvature2 = function(x1, x2, x3, y1, y2, y3){
  curvature(c(x1, x2, x3), c(y1, y2, y3))
}

curvatures = Vectorize(curvature2)

curvatures2 = function(route,
                       x='Midpoint_X', y='Midpoint_Y') {
  
                    curvatures(lag(route[[x]]),
                               route[[x]],
                               lead(route[[x]]),
                               lag(route[[y]]),
                               route[[y]],
                               lead(route[[y]]) )
                }
```

```{r results=FALSE}
route_convexity$turn_curvature = curvatures2(route_convexity)
```

Preview the result:

```{r}
route_convexity[1:10, c('ConvexityIndex', 'turn_curvature' )]
```

```{r}
ggplot(route_convexity[1:10,], aes(x=Midpoint_X, y=Midpoint_Y)) +
         geom_path() + geom_point(aes(color=turn_curvature))
  
```
```{r}
route_convexity[1:10,]
```




<!--chapter:end:creating-stage-descriptions.Rmd-->

```{r cache = T, echo = F, message=F}
# 15Allow knitr to continue to execute even in the presence of errors
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/creating-road-book-")
knitr::opts_chunk$set(engine.path = list(python = '/usr/local/bin/python3'))
options(rgl.useNULL = TRUE,
        rgl.printRglwidget = TRUE)
```
# Creating A Road Book

A rally road book describes the route to be taken in a rally. Road books describe the route in terms of road sections, lengths of road between road junctions encountered along the route ([example](https://www.therallyco-driver.com/road-book/); see also [Everything you ever wanted to know about: rally notes](https://rallynotes.com/2008/01/everything-you-ever-wanted-to-know-about-rally-notes/)). At each junction, the route to be taken is clearly identified.

One exciting possibility is that we can recover route information from OpenStreetMap and cast it as a graph (network) using the `sfnetworks` package and then identify all the road junctions along a route.

If we then zoom in on a particular junction node, we should be able to see the junction. If we can access the orientation of the road, we should be able to generate a tulip...

So the question is: *can we find junctions on a route snapped to a road network?"*

*Under my current understanding, I haven't found a way to do this yet...*

A secondary question might be: *can we transform a graph layout so that a spatially curved route is depicted as a straight line with junction turns off the route: a) depicted; b) depicted at their angle to the route?*

*Again, I haven't currently found a way to do this.*

It might also be worth referring to the [*FIA Rally Safety Guidelines 2020*](https://www.fia.com/sites/default/files/2printable_rally_safety_guidelines_1.pdf) [h/t `WRCStan`] and the Motorsport UK regulations to see what constraints they place on stage design and the evaluation of rally stage routes, we well as considering what measures, if any, they take into account when assessing stage routes. It's also worth noting how the FIA regulations recommend that stage summaries provided by the Jemba system, or similar,  should be used when evaluating stage routes.


## Motorsport UK Specific Regulations for Rallying

Motorsport UK regulates motorsport in the UK. A set of specific regulations for rallying describe certain constraints on stage routes:

> 26.1.2. A control or check shall be considered to extend for 50m around the actual point at which Officials are making their records, unless clearly visible signs are displayed to define a different area.
>
> 26.2. It is not Permitted to define the route of a special stage by grid references or any other method requiring Competitors to choose their own route.
>
> 26.2.1. Any Flying Finish should be located at a point where cars can be expected to be travelling slowly as a result of a preceding bend or hazard.
>
> 26.2.2. The Flying Finish line must be at least 200m before the stop line which should be at least 100m before any public highway. Bad weather, slippery conditions and the potential speed of cars crossing the Flying Finish line may require these distances to be extended.
>
> 26.2.3. The area between the Flying Finish and the stop line should be free from bends, sharp or deceptive corners, or hazards such as gates, etc. This area is prohibited to spectators.
>
> 26.4.1. Organisers should allow at least 100m separation from the start of the stage before Competitors join other cars already on the stage.
>
> 26.6.2. Authorisation for stages not covered above must be obtained in writing from Motorsport UK and will only be considered when the following information has been submitted:
>
> (a) The individual stage name, number and location.
>
> (b) The length of the stage.
>
> (c) The type of surface (forest, tarmac, etc).
>
> (d) The average width of the road.
>
> (e) Diagram(s) of the venue showing stage routes and safety provisions.
>
> (f) The number of times Competitors are attempting the stage.
>
> (g) If the Competitors are attempting the stage more than once, the time interval between their first and second run, and the possibility of catching previous Competitors.
>
> (h) Whether Competitors attempting their second run will be interposed with those still attempting their first.
>
> (i) Whether the stage has a split route, and if so how far this is into the stage. On unsealed surfaces the stage must not consist of more than 21⁄2 miles of common route.
>
> (j) Whether extreme weather (eg heavy rain, dust, etc) will adversely affect a fair Competition.
>
> (k) Competitors have been seeded by performance in accordance with 24.1.4, without dispensation.
>
>(l) Suitable timing arrangements have been made at the Finish Line.
> 
> 28.1.1. Special Stages must be over a distance of not less than half a mile and no stage may exceed 20 miles in length without written permission from Motorsport UK.
>
> 28.2.1. If the stage is wholly on a sealed surface, no Competitor should be able to achieve an average speed of more than 75mph.
>
> 28.2.2. If the stage is run partly or wholly on unsealed surfaces, no Competitor should be able to achieve an average speed of more than 70mph.
>
> 28.3. Special Stages should not use any sections of a venue in opposite directions at the same time, unless there is at least a 15m separation between the two routes with a continuous barrier to prevent a car crossing.
>
> 29.1.6. Along with the arrows and signs displayed on the Special Stage, each Competitor must be issued with a Tulip diagram of each stage showing location or hazard numbers or letters, and indicating the intermediate mileages between junctions, danger spots or hazards and the direction to be
taken.

## Load in Base Data 

As ever, let's load in our stage data:

```{r message=FALSE}
# Original route data  (KML file):
# https://webapps.wrc.com/2020/web/obc/kml/montecarlo_2021.xml
library(sf)
geojson_filename = 'montecarlo_2021.geojson'
geojson_sf = sf::st_read(geojson_filename)

# Grab the first stage route
route = geojson_sf[1,]

# Get stage bounding box
stage_bbox = st_bbox(route)
```

Get the coordinates into a UTM form, and also generate a buffered area around the route:

```{r utm-preview}
lonlat2UTM_hemisphere <- function(lonlat) {
    ifelse(lonlat[1] > 0, "north", "south")
}

lonlat2UTMzone = function(lonlat) {
  utm = (floor((lonlat[1] + 180) / 6) %% 60) + 1
  if(lonlat[2] > 0) {
    utm + 32600
  } else{
    utm + 32700
  }
}

# Grab a copy of the original projection
original_crs = st_crs(geojson_sf[1,])

# Find the UTM zone for a sample a point on the route
crs_zone = lonlat2UTMzone(c(st_coordinates(route)[1,1],
                            st_coordinates(route)[1,2]))

# Create the projection string
utm_pro4_string = st_crs(crs_zone)$proj4string
#"+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs"
# units in meters e.g. https://epsg.io/32632

# Transform the route projection
route_utm = st_transform(geojson_sf[1,], crs = st_crs(utm_pro4_string))

# Create a buffer distance
buffer_margin_200m = units::set_units(200, m)

buffered_route_utm <- st_buffer(route_utm, buffer_margin_200m)

buffered_route <- st_transform(buffered_route_utm, original_crs)

plot(st_geometry(buffered_route_utm))
plot(st_geometry(route_utm), col='red', add=TRUE)
```

Also retrieve some highways data from OpenStreetMap:

```{r}
library(osmdata)

stage_bbox = sf::st_bbox(buffered_route)
stage_osm  = opq(stage_bbox) %>% 
  add_osm_feature("highway") %>% 
  osmdata_sf()

stage_osm
```


## Using `sfnetworks` to Represent Routes and Road Networks

We can cast the stage route as a directed network using the `sfnetworks::as_sfnetwork()` applied to the linestring geometry of the route:

```{r}
library(sfnetworks)

route_dg = as_sfnetwork(st_geometry(route_utm), directed = TRUE)
route_dg
```

We can plot the route and the distinguished start and end nodes:

```{r route_dg}
plot(st_geometry(route_dg, "edges"),
     col = 'grey', lwd = 4)

plot(st_geometry(route_dg, "nodes"),
     col=c('green', 'red'), pch = 20, cex = 2, add = TRUE)
```

This also suggests to us that we can add additional nodes and colour those. We could also then segment the edges between the nodes.

```{r}
# Get line segment coords
edges = st_coordinates(st_geometry(route_dg, "edges"))

# Find the mid point by segment rather than distance
mid_edge = edges[floor(nrow(edges)/2),]

mid_edge_pt = st_sfc(st_point(c(mid_edge['X'],
                                 mid_edge['Y'])),
                     crs=st_crs(route_dg)$proj4string)

mid_edge_pt
```

We can add this point as a node on our graph using the `sfnetworks::st_network_blend()` function:

```{r route_dg2}
route_dg2 = st_network_blend(route_dg, mid_edge_pt)
plot(route_dg2)
```

Now let's see what happens if we add that node to the graph, and then colour the graph by the node defined edges along the route:

```{r route_dg2_col,  message=FALSE}
#https://luukvdmeer.github.io/sfnetworks/articles/preprocess_and_clean.html
edge_colors = function(x) rep(sf.colors(12, categorical = TRUE)[-2],
                              2)[c(1:igraph::ecount(x))]

plot(st_geometry(route_dg2, "edges"),
     col = edge_colors(route_dg2), lwd = 4)

plot(st_geometry(route_dg2, "nodes"),
     col= 'black', pch = 20, cex = 1, add = TRUE)
```

This suggests that if we have a set of split points, for example, we can add them as nodes to the graph and then colour the graph edges differently for each edge that connects nodes along the route.

It also suggests we can plot separate splits. For example, here's the second half of the route:

```{r route_dg_fragment}
plot(st_geometry(route_dg2, "edges")[2],
     col = edge_colors(route_dg2), lwd = 4)
```

Split point locations are often given in terms of "distance into stage", so being able to easily add a node a certain distance along a route defined as a linestring would be really handy... Also being trivially able to select a node and found out how far it was along from the start of the route, to the end of the route, to the next node and to the previous node.

## Analysing Road Networks with `sfnetworks`

We can also represent a more complex set of roads as a network. For example, a set of roads retrieved from OpenStreetMap.

### Creating an `sfnetworks` Graph

To create the spatial network, we pass the "lines" retrieved using `osmdata::opq()` to the `sfnetworks::as_sfnetwork()` function, this time setting the graph as undirected:

```{r}
# Create the sfnetwork object
stage_osm_g <- as_sfnetwork(stage_osm$osm_lines,
                            directed = FALSE)

stage_osm_g
```

Let's see what it looks like...

```{r osm_g}
plot(stage_osm_g, col='grey', cex=0.5)
```

Well it looks like there's something there!

Can we transform the projection?

```{r}
stage_osm_g_utm =  stage_osm_g %>%
                    st_transform(st_crs(buffered_route_utm))

stage_osm_g_utm
```

### Filtering an `sfnetworks` Graph

Can we view the network in the buffered area around the stage route?

```{r osm_g_filtered}
filtered = st_filter(stage_osm_g_utm, 
                     buffered_route_utm,
                     .pred = st_intersects)

plot(filtered, cex=0.5)

# We can blend plots using an sfnetwork object
# As long as it has the same projected coordinate system...
plot(st_geometry(route_utm), col='red', add=TRUE)
```

A couple of things to note here. Firstly, the stage route points may not lay exactly on the OSM highway route, even if the routes are supposed to correspond to the same bit of road. Secondly, the rally stage route may go onto track surfaces that are not recorded by OSM as highways lines.

The challenge now is this: can we map out original route on the OSM network, and return a filtered part of the network that show the original route and the road junctions along it? If so, then we have the basis of a tulip diagrammer.

### Viewing a Buffered Area Around a Junction Node

Let's get a (carefully selected!) node, buffer around it and see what we can see:

```{r osm_g_fragment}
# Find a junction on the road network
n = st_geometry(filtered, "nodes")[85]

# Generate a buffered area around the road network
buffered_n = st_buffer(n, buffer_margin_200m)

# Filter the road network to the buffered area
filtered2 = st_filter(stage_osm_g_utm, 
                     buffered_n,
                     .pred = st_intersects)

plot(filtered2, cex=0.5, col = 'grey', lwd = 6)
```

If we crop our route to the buffered area, we should be able to overlay it on the road network visually at least:

```{r cropped-route}
# Crop the route to the buffered area
filtered3 = st_crop(route_utm, 
                     buffered_n)

# See what we've got
plot(filtered2, cex=0.5, col = 'grey', lwd = 6)
plot(st_geometry(filtered3), cex=0.5, col='red', add=TRUE)
```

Okay, so we have the road network and part of the stage route; the stage route passes a junction on the right.

This could be promising, *if* we can find a way to reliably snap routes to OSM lines and index nodes along a route.

One way to do this might be to crudely map a route onto the nearest OSM line and then hope that the OSM line is the appropriate track...

### Snapping a Route to a Road Network

The `sfnetworks::st_network_blend()` function looks like it will try to map points as new nodes onto the nearest part of a graph route.

Let's get the nodes from our cropped route. There must be a better way of doing this (it's such an obvious thing to want to do!) but I can't find a straightforward way to do it, so we'll just have to make something up! Cast the coordinates to a multipoint object then cast that a list of points:

```{r}
# Generate a multipoint from a list of coordinates
pois_mp = st_sfc(st_multipoint(st_coordinates(filtered3)),
                 crs=st_crs(filtered3))

# Generate a list of points from a multipoint
# Via: https://github.com/r-spatial/sf/issues/114
pois_points = st_cast(x = pois_mp, to = "POINT")
```

Let's see what happens if we try to snap those route points onto the road network:

```{r blended-network}
blended = st_network_blend(filtered2, pois_points)

plot(filtered2, cex=0.5, col = 'grey', lwd = 6)
plot(blended, cex=0.5, col='red', add=TRUE)
```

Okay, they seem to have snapped new nodes onto the route network.

What happens if we now buffer around that route fragment and just show the route snapped to the road network:

```{r buffered-blended}
# Buffered area around the route
filtered3_buffered = st_buffer(filtered3,  units::set_units(15, m))

# Limit the road network to the buffered area round the route
filtered4 = st_filter(blended, 
                     filtered3_buffered,
                     .pred = st_intersects)

# See what we've got
plot(filtered4, cex=0.5, col='red')
```

In the above example we see the snapped nodes are what the `sfnetworks` docs refer to as *pseudo nodes* that have only one incoming and one outgoing edge. (I guess this means we can also use network analysis to easily identify those nodes as nodes of degree 2?) 

The `sfnetworks` package provides a converter that can be applied via the `tidygraph::convert` function for cleaning ("smoothing") these pseudo nodes, `sfnetworks::to_spatial_smooth`, so let's see how that works:

```{r smoothed-network, message=FALSE}
library(tidygraph)

smoothed = convert(filtered4, to_spatial_smooth) %>%
              # Remove singleton nodes
              convert(to_spatial_subdivision, .clean = TRUE)

plot(smoothed, cex=0.5, col='red')
```

So that seems to work.

Can we plot also somehow fettle the layout algorithm so that the nodes along the main path (which we somehow need to distinguish with start and stop nodes) is horizontally or vertically laid out?


### Snapping a Full Stage Route to the Road Network

What happens now if we try that recipe with the full route?

```{r full-smoothed}
# Get a buffered region round the route
#buffer_margin_1km = units::set_units(1000, m)
buffered_route_utm <- st_buffer(route_utm, buffer_margin_200m)

# Filter the road network to the buffered area
full_filtered = st_filter(stage_osm_g_utm,
                          buffered_route_utm,
                          .pred = st_intersects)

# Route points
route_pois_mp = st_sfc(st_multipoint(st_coordinates(route_utm)),
                       crs=st_crs(route_utm))

# Generate a list of points from a multipoint
route_pois_points = st_cast(x = route_pois_mp, to = "POINT")

# Snap to road network
full_blended = st_network_blend(full_filtered, route_pois_points)

# Smooth
full_smoothed = convert(full_blended, to_spatial_smooth) %>%
                  # Remove singleton nodes
                convert(to_spatial_subdivision, .clean = TRUE)

# See what we've got
plot(full_smoothed, cex=0.5, col='red')
plot(route_utm$geometry,  col='black', add=TRUE)
```

So this *isn't* what we want. When we do the intersection, we drop the nodes outside the buffer. But what we want is for new nodes to be created where edges are cut by the filtering buffer.

This is perhaps a cropping function rather than a filter? Although cropping cuts to a rectangle, which is also not what we want...

```{r cropped-full-smoothed, warning=FALSE}
# Crop the road network to the buffered area
# https://luukvdmeer.github.io/sfnetworks/articles/join_filter.html
full_cropped =  st_crop(stage_osm_g_utm, buffered_route_utm)

# Snap to road network
full_cropblended_ = st_network_blend(full_cropped, route_pois_points)

# Smooth
full_cropsmoothed = convert(full_cropblended_, to_spatial_smooth) %>%
                      # Remove singleton nodes
                      convert(to_spatial_subdivision, .clean = TRUE)

# See what we've got
plot(full_cropsmoothed, cex=0.5, col='red')
plot(route_utm$geometry,  col='black', add=TRUE)
```

A solution to this, [as suggested by `@loreabad6`](https://gist.github.com/psychemedia/ddd95de9a3fbc3c1afae85a8a7a431d8#gistcomment-3639658), is to crop the OSM routes data *before* we create the road network:

```{r cropped-highways-on-stage}
stage_osm_cropped = stage_osm %>% trim_osmdata(buffered_route,
                                               exclude = T) 

stage_osm_g_cropped_utm = as_sfnetwork(stage_osm_cropped$osm_lines,
                                   directed = FALSE) %>% 
                          st_transform(st_crs(buffered_route_utm))

# Plo the actual route
plot(route_utm$geometry)

# Overlay the cropped OSM route
plot(stage_osm_g_cropped_utm,  col='red', add=TRUE)
```


## Using `dodgr` to Represent Routes and Road Networks

Although most current effort appears to be being placed on development of the `sfnetworks` package, two earlier packages exist for representing road networks: `stplanr` and `dodgr`. The seed data used by `dodgr` is typically a set of polyline objects generated from data returned from OpenStreetMap. We can optionally filter the data by our buffered route:

```{r}
net = stage_osm %>% osmdata::osm_poly2line()

# Optionally buffer the network
buffered_net = stage_osm %>%
                  osmdata::trim_osmdata (buffered_route)  %>%
                  osmdata::osm_poly2line()
```

We can plot the lines using `ggplot2`:

```{r dodgr-lines}
library(ggplot2)

ggplot(net$osm_lines) + geom_sf()
```

We then convert the lines to a `dodgr` network / graph object using the `dodgr:weight_streetnet()` function:

```{r}
library(dodgr)

graph <- weight_streetnet(stage_osm$osm_lines,
                          wt_profile = "motorcar")
```

The `dodgr` packages allows edges to be characterised by two values: the distance, and a weighted distance. The weighted distance may be of interest to us if we want to make time estimations or models based on road surface or road surface and tyre combination. For example, the time taken to travel 1km on snow using snow tyres may be expected to differ from the time taken to travel 1km on tarmac. The twistiness of of each section of a route may also be used to weight anticipated travel times.

The `dodgr` package provides a range of tricks for modifying travel times on normal road networks. In the [*Street networks and time-based routing* vignette
](https://atfutures.github.io/dodgr/articles/times.html)) the roadtype weight matrix and a *turn_penalty* weighting that introduces a time cost to turning across oncoming traffic might be a co-optable way of increasing travel time weights on curved sections by adding contraflow junction nodes to tight corners? 

It might be quite amusing to try to define [weight profiles ](https://atfutures.github.io/dodgr/articles/times.html#weighting-profiles-and-the-write_dodgr_wt_profile-function) for a new *rally_car* type or rally cars under different weather and/or tyre conditions, perhaps based on models created from datasets of previous rally stage times or even car telemetry? A weighting profile determines the weighting applied to different road types. The default weighting profiles are stored in the `dodgr::weighting_profiles` list.

## Route Stage Time Simulation

Road network representations, as well as curvature, distance and gradient measures for each step of a route set up some interesting possibility for very simple stage time simulations that might be interesting for storytelling purposes, if not actual stage time prediction.

The weight profiles in `dodgr` provide one way of exploring this off-the-shelf; the `sfnetworks` package can also support [`custom weighted routing`](https://luukvdmeer.github.io/sfnetworks/articles/routing.html#custom-routing).

A simpler way of accounting for different speeds along a route would be to just weight the distance of each line segment in the route by a speed value, perhaps identified as a function of curvature and elevation gradient? This would essentially map route segments onto distance onto distance / speed, which is to say time. A simple model might use a speed determined simply as a function of curvature and road type. A more complex model may try to model acceleration through a segment based on the previous and next segments, and calculate the time  also as a function of the segment distance and the input speed

<!--chapter:end:creating-a-road-book.Rmd-->

# Where Next?

From what started as a half hour hack, and turned into a two week learning journey and write-up, which also included how to use `bookdown` to publish web-browseable books, as well as PDFs, from Rmd documents, this book provides something of a travelogue around the bye-ways of working with geographical route data.

Having been on the journey, several things occur to me. Firstly, if I ever need a present for a rally fan, I should be able to make a 3D model of their favourite stage or a custom map showing paths, trails and picnic spots around a woodland stage. Secondly, the idea of *stage route analysis* may be worth pursuing in terms of looking for profile stories *from the stage route* in advance of a rally, or perhaps to support a rally journalism write up of the events that transpired on a particular stage. I suspect I've only just started to touch on what the ecologists get up to with their path analysis, so this will likely reward further reading. Using stage route metrics to tag stages in terms of twistiness and elevation change, and use these as factors to see if they impact on driver performance, is another exciting possibility, using stage maps retrieved from [*rally-maps.com*](https://www.rally-maps.com/home) and results from [*ewrc-results.com*](https://www.ewrc-results.com/).

One thing I haven't really touched on is adding infographics to stage maps. Elsewhere, I have dabbled with various ways of visually reporting on stage times and pace maps over a rally (the split times for for WRC are still on hold as a I repair my data scrapers!)

Another thing that is missing from this book is the spatial analysis of collected or sampled data. I do have a stash of old WRC+ telemetry data somewhere, so a couple of half hour hacks (?!) immediately suggest themselves to me: firstly, revisiting the simple plots I originally made of them and finding ways of integrating them with some of the `leaflet` map views in particular; secondly, analysing their "group" behaviour to see how that unusual beast, the rally driver, behaves in general on a particular stage, and how and why other drivers perhaps stand out.

What's certain is that this isn't the end of the story. With this book now in the state it is, its something I can continue to update and to add to... The telemetry style analysis will probably be the focus of another project, however. If holidays are locked out again, that could well be how I spend my  summer holiday fortnight!

<!--chapter:end:where-next.Rmd-->

